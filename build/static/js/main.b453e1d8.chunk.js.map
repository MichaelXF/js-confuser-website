{"version":3,"sources":["components/Code.js","components/Option.js","js-confuser/presets.ts","modals/ModalOptions.js","useCookie.js","js-confuser/parser.ts","js-confuser/util/insert.ts","js-confuser/util/identifiers.ts","js-confuser/traverse.ts","js-confuser/util/gen.ts","js-confuser/util/random.ts","js-confuser/transforms/transform.ts","js-confuser/transforms/label.ts","js-confuser/util/compare.ts","js-confuser/transforms/identifier/renameVariables.ts","js-confuser/transforms/preparation/preparation.ts","js-confuser/transforms/extraction/objectExtraction.ts","js-confuser/templates/template.ts","js-confuser/templates/crash.ts","js-confuser/transforms/lock/integrity.ts","js-confuser/transforms/lock/antiDebug.ts","js-confuser/transforms/lock/lock.ts","js-confuser/transforms/dispatcher.ts","js-confuser/transforms/deadCode.ts","js-confuser/transforms/opaquePredicates.ts","js-confuser/transforms/calculator.ts","js-confuser/transforms/controlFlowFlattening.ts","js-confuser/transforms/eval.ts","js-confuser/transforms/identifier/globalConcealing.ts","js-confuser/transforms/string/stringConcealing.ts","js-confuser/transforms/string/stringSplitting.ts","js-confuser/transforms/extraction/duplicateLiteralsRemoval.ts","js-confuser/transforms/shuffle.ts","js-confuser/transforms/identifier/movedDeclarations.ts","js-confuser/transforms/renameLabels.ts","js-confuser/transforms/minify.ts","js-confuser/transforms/es5.ts","js-confuser/transforms/string/stringEncoding.ts","js-confuser/obfuscator.ts","js-confuser/transforms/rgf.ts","js-confuser/transforms/flatten.ts","js-confuser/util/object.ts","js-confuser/index.ts","modals/ModalConfig.js","App.js","reportWebVitals.js","index.js","js-confuser/compiler.ts"],"names":["require","themeMap","Code","indent","code","className","readOnly","onChange","theme","useContext","ThemeContext","options","lineNumbers","mode","tabSize","value","onBeforeChange","editor","data","toTitleCase","camelCase","replace","match","toUpperCase","trim","Option","name","displayName","type","modes","initialValue","useState","setValue","percentEditor","setPercentEditor","adding","setAdding","updateValue","newValue","undefined","Error","Dropdown","title","map","x","Item","onSelect","Checkbox","indeterminate","InputNumber","step","min","max","defaultValue","style","width","postfix","_value","checked","defaultChecked","Button","onClick","size","appearance","DatePicker","date","valid","startsWith","href","target","Input","placeholder","push","Animation","Collapse","in","TagGroup","i","Tag","closable","onClose","splice","presets","high","preset","dispatcher","controlFlowFlattening","objectExtraction","renameVariables","identifierGenerator","calculator","deadCode","minify","opaquePredicates","duplicateLiteralsRemoval","globalConcealing","stringConcealing","stringEncoding","stringSplitting","eval","flatten","medium","low","Column","Table","HeaderCell","Cell","Pagination","Options","show","onHide","OptionContext","setOptions","custom","setCustom","Modal","Header","Title","Body","Object","keys","groups","Panel","bordered","overflowY","option","currentValue","parentField","description","RadioGroup","inline","cloned","Presets","Radio","Icon","icon","performance","sample","align","fixed","dataKey","Footer","setCookie","cname","cvalue","exdays","d","Date","setTime","getTime","expires","toUTCString","document","cookie","getCookie","ca","decodeURIComponent","split","length","c","charAt","substring","indexOf","useCookie","days","useDebugValue","JSON","parse","e","encodeURIComponent","stringify","acorn","parseJS","a","assert","parsed","parseSync","console","error","ecmaVersion","sourceType","isFunction","object","includes","getContext","parents","fn","find","getFunction","top","ok","Array","isArray","join","isContext","context","getBlockBody","block","body","getIndexDirect","parent","deleteDirect","validateChain","index","log","keyName","prepend","nodes","decs","forEach","stmt","unshift","clone","newArray","element","newObject","key","values","isWithin","some","getIdentifierInfo","isAccessor","property","computed","propIndex","findIndex","isPropertyKey","varIndex","isVariableDeclaration","id","forIndex","isForInitializer","init","functionIndex","isFunctionDeclaration","isFunctionParameter","params","isClauseParameter","clauseIndex","param","isImportSpecifier","local","isFunctionCall","callee","isAssignmentLeft","left","isAssignmentValue","right","isUpdateExpression","isClassDeclaration","isMethodDefinition","isMetaProperty","isLabel","label","spec","isExported","isDefined","isModified","isReferenced","getDefiningIdentifier","seen","Set","l","bestScore","Infinity","walk","slice","o","p","info","contexts","filter","definingContext","add","getBlocks","isBlock","getBlock","onEnter","has","newParents","onExit","copy","traverse","tree","Literal","UnaryExpression","Math","abs","Identifier","toString","BlockStatement","LogicalExpression","operator","BinaryExpression","SwitchCase","test","consequent","LabeledStatement","SwitchStatement","discriminant","cases","BreakStatement","Property","kind","method","shorthand","ObjectExpression","properties","VariableDeclarator","VariableDeclaration","declarations","WhileStatement","IfStatement","alternate","FunctionExpression","generator","expression","async","FunctionDeclaration","ReturnStatement","argument","ConditionalExpression","ExpressionStatement","SequenceExpression","expressions","MemberExpression","CallExpression","args","arguments","NewExpression","AssignmentExpression","ArrayExpression","elements","SpreadElement","choice","choices","floor","random","shuffle","array","sort","getRandomInteger","getRandom","reservedKeywords","reservedIdentifiers","alphabeticalGenerator","t","String","fromCharCode","Transform","obfuscator","priority","before","after","concurrent","Obfuscator","this","node","state","apply","verbose","fns","input","transform","offset","count","generate","generateIdentifier","varCount","identifier","ComputeProbabilityMap","characters","numbers","combined","result","genRanHex","keyWords","safe","repeat","base","syntax","getToStringValue","text","debugComments","leadingComments","assign","AddComment","node1","node2","objectAssign","comments1","comments2","comments","_transform","messages","message","__proto__","constructor","Label","isLoop","currentLabel","getPlaceholder","loop","isValidIdentifier","VariableAnalysis","defined","references","Map","globalVariables","fnIndex","set","get","delete","RenameVariables","ObfuscateOrder","gen","generated","changed","variableAnalysis","getGenerator","isGlobal","newNames","create","possible","allReferences","nope","ref","def","passed","changes","first","next","g","newName","check","$renamed","FunctionsFirst","functionDeclarations","indices","isTop","ExplicitIdentifiers","ExplicitDeclarations","NameConflicts","declared","counts","changing","chain","thisNodes","y","Preparation","ObjectExtraction","contextParents","objectDefs","prop","illegalName","objectDefChanges","isMemberExpression","isIllegal","newVariableDeclarations","newPropNames","nn","addComment","list","declaratorIndex","declarator","deleteDeclaration","change","memberExpression","declaration","Template","template","neededVariables","vars","fill","variables","bracketName","reg","RegExp","compile","allowReturnOutsideFunction","parseSnippet","single","CrashTemplate1","CrashTemplate2","CrashTemplate3","HashTemplate","ImulTemplate","StringTemplate","Integrity","lock","hashFn","imulFn","stringFn","seed","hashingUtils","imulName","imulVariableDeclaration","_hiddenId","hashName","hashFunctionDeclaration","imul","stringName","stringFunctionDeclaration","functionExpression","_hiddenHashingUtils","$eval","functionName","functionDeclaration","$dispatcherSkip","minified","hash","str","ch","h1","h2","charCodeAt","cyrb53","DevToolsDetection","AntiDebug","Lock","LockStrings","strings","fnName","objectExpression","shift","ensureNumber","parseInt","start","startDate","diff","endDate","now","keyArg","mapName","keyVar","getKey","currentVar","outputVar","xVar","xorKey","globalVar","integrity","antiDebug","opt","countermeasures","varName","var","domainLock","nativeFunctions","dateNow","from","getCounterMeasuresCode","locationHref","regex","pattern","source","path","removeSlashes","flags","randomIndex","Dispatcher","isInsideType","maxArgs","identifiers","illegalFnNames","newFnNames","isWithinClass","$integritySkip","oo","pp","varArgs","dispatcherFnName","expectedGet","expectedClearArgs","expectedNew","returnProp","newReturnMemberName","shuffledKeys","defParents","variableDeclaration","ifStatement","signature","getterArgNames","z","getAccessor","_","assignmentExpressions","dispatcherArgs","vName","callExpression","expr","templates","DeadCode","usedNames","OpaquePredicates","undefinedVar","nullVar","numberVar","predicateName","predicate","predicates","ForStatement","DoWhileStatement","ConditionExpression","isTestExpression","accessor","arrayProp","Calculator","ops","calculatorFn","opArg","leftArg","rightArg","switchCases","newState","SwitchCaseObfuscation","factor","newVar","newStates","ControlFlowObfuscation","$controlFlowObfuscation","containsLexicallyBoundVariables","update","stateVar","states","goto","nextState","to","contains","ControlFlowFlattening","chunks","fraction","current","pop","selection","deadCases","endState","order","caseObject","thisState","switchStatement","statements","Eval","compileJsSync","literal","dynamicallyObfuscate","GlobalAnalysis","notGlobals","globals","GlobalConcealing","globalAnalysis","del","used","global","globalFn","locations","encode_ascii85","b","f","h","j","k","Ascii85Template","isModuleSource","StringConcealing","arrayExpression","getterName","arrayName","decodeFn","decodeNode","w","decode_ascii85","warn","StringSplitting","joinPrototype","adders","currentLength","splitIntoChunks","assignment","reverse","DuplicateLiteralsRemoval","number","string","boolean","propertyIndex","toMember","Shuffle","prefix","UpdateExpression","inPlace","varDeclarator","varDec","MovedDeclarations","varDecs","varNames","dO","dP","RenameLabels","labelStatement","MinifyFlow","earlyReturn","MinifyBlock","justDefined","remove","exprs","startIndex","sequences","seq","last","isUndefined","stmts","lastDec","Minify","hasOwnProperty","es5","canTransform","$object","$parents","arrow","stmt1","lastStatement","stmt2","e1","e2","second","extra","removeExtra","obj","isEquivalent","AntiConstLet","AntiParameters","catchName","isDestructed","parameters","AntiDestructuring","temp","names","extracting","should","recursive","realm","condition","AntiArrow","usesThis","AntiES6Object","makerFn","helper","needsChanging","baseProps","computedProps","descriptors","FixedExpressions","ES5","pad","len","even","toHexRepresentation","escapedString","char","toUnicodeRepresentation","StringEncoding","RGF","collect","queue","definingNodes","location","referenceArray","hasName","transforms","newFunction","referenced","Flatten","executorName","prepareCases","unloadCases","resultName","argsName","makeExecutorFunction","functionsChanged","methods","$rgf","modified","definedTopLevel","returnStatements","definedAt","returnStatement","methodIndex","identifer","isProbabilityMapProbable","transformers","Transformer","movedDeclarations","rgf","debugMode","emit","EventEmitter","createObject","runner","customFnArgs","asObject","total","reduce","percentages","ticket","winner","parseFloat","isNaN","line","correctOptions","remove$Properties","compileJs","compact","frames","on","ModalConfig","orderedKeys","display","createContext","setTheme","Identifiers","Strings","Data","Functions","Output","App","setCode","setIndent","debug","setDebug","setFrames","themeValue","useMemo","optionsValue","setShow","showConfig","setShowConfig","Provider","placement","navigator","clipboard","writeText","Alert","success","closeAll","Menu","pullLeft","alert","warning","lines","startedAt","debugTransformations","then","hitError","frame","catch","err","JsConfuser","output","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById","escodegen","api","format","FORMAT_MINIFY","2","tabs","comment","fullCode"],"mappings":"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","file":"static/js/main.b453e1d8.chunk.js","sourcesContent":["\r\nimport { useContext, useState } from \"react\";\r\nimport {Controlled as CodeMirror} from \"react-codemirror2\";\r\nimport 'codemirror/mode/javascript/javascript.js';\r\n\r\n\r\nimport 'codemirror/theme/material.css';\r\nimport 'codemirror/theme/material-ocean.css';\r\nimport 'codemirror/theme/darcula.css';\r\nimport 'codemirror/theme/moxer.css';\r\nimport 'codemirror/theme/neat.css';\r\n\r\n\r\n\r\nimport { ThemeContext } from \"../App\";\r\n\r\n\r\nrequire('codemirror/lib/codemirror.css');\r\n\r\nexport const themeMap = {\r\n  \"Material\": \"material\",\r\n  \"Material Ocean\": \"material-ocean\",\r\n  \"Darcula\": \"darcula\",\r\n  \"Moxer\": \"moxer\",\r\n  \"Light Mode\": \"neat\"\r\n}\r\n\r\nexport default function Code({indent = 4, code = \"\", readOnly = false, className, onChange}){\r\n\r\n  var {theme} = useContext(ThemeContext);\r\n\r\n  return (\r\n    <CodeMirror options={{\r\n      lineNumbers: true,\r\n      theme: themeMap[theme] || \"default\",\r\n      mode: \"javascript\",\r\n      tabSize: indent,\r\n    }} value={code} onBeforeChange={(editor, data, value)=>{\r\n      onChange(value);\r\n    }} className={className} />\r\n  )\r\n};","import { useState, useMemo } from \"react\";\r\nimport { Button, Checkbox, DatePicker, Dropdown, Input, InputNumber, Tag, TagGroup, Toggle, Animation } from 'rsuite';\r\nimport './Option.scss';\r\n\r\nconst toTitleCase = (camelCase) => camelCase\r\n  .replace(/([A-Z])/g, (match) => ` ${match}`)\r\n  .replace(/^./, (match) => match.toUpperCase()).trim();\r\n\r\nexport default function Option({name, displayName, type = \"probability\", modes, initialValue = false, onChange}){\r\n\r\n  var displayName = displayName || toTitleCase(name);\r\n\r\n  var [value, setValue] = useState(initialValue);\r\n  var [percentEditor, setPercentEditor] = useState(typeof initialValue === \"number\");\r\n\r\n  var [adding, setAdding] = useState(\"/domain\\\\.com/\");\r\n\r\n  function updateValue(newValue){\r\n\r\n    if ( newValue === undefined ) {\r\n      throw new Error(\"undefined from \" + type + \" '\" + name + \"'\");\r\n    }\r\n\r\n    if ( newValue !== value ) {\r\n      setValue(newValue);\r\n      onChange(newValue);\r\n    }\r\n  }\r\n\r\n\r\n  if ( type == \"probability\" ) {\r\n\r\n    if ( !modes ) {\r\n      if ( percentEditor ) {\r\n        return <div className=\"option option-checkbox\">\r\n          <div className=\"flex\">\r\n          <Checkbox onChange={()=>{\r\n            updateValue(false);\r\n            setPercentEditor(false);\r\n          }} indeterminate={true}> {displayName}</Checkbox>\r\n          <InputNumber step={2} min={0} max={100} className=\"ml-2\" defaultValue={value*100} style={{width: \"120px\"}} onChange={(value)=>{\r\n            updateValue(value/100);\r\n          }} postfix=\"%\"/>\r\n          </div>\r\n        </div>;\r\n      }\r\n      return <div className=\"option option-checkbox\">\r\n        <div className=\"flex\">\r\n          <Checkbox onChange={(_value, checked)=>updateValue(checked)} defaultChecked={value}> {displayName}</Checkbox>\r\n          <Button onClick={()=>{\r\n            updateValue(1);\r\n            setPercentEditor(true);\r\n          }} className=\"ml-2\" size=\"sm\" appearance=\"link\" >Percent (%)</Button>\r\n        </div>\r\n      </div>\r\n      \r\n    } else {\r\n\r\n      return <div className=\"option\">\r\n        <p>{displayName}</p>\r\n        <Dropdown className=\"mt-2\" title={toTitleCase(value || \"\") || \"Choose one\"}>\r\n          {modes.map(x=>{\r\n            return <Dropdown.Item onSelect={()=>{\r\n              updateValue(x)\r\n            }}>{toTitleCase(x)}</Dropdown.Item>\r\n          })}\r\n        </Dropdown>\r\n      </div>;\r\n    }\r\n\r\n  } if ( type == \"date\") {\r\n\r\n    return <div className=\"option\">\r\n      <div className=\"flex items-center mt-3\">\r\n\r\n        <p className=\"mr-2\">{displayName}</p>\r\n\r\n        <DatePicker value={value} onChange={(date)=>{\r\n        updateValue(date);\r\n        }}/>\r\n\r\n      </div>\r\n    </div>;\r\n\r\n  } else if ( type == \"boolean\") {\r\n\r\n    return <div className=\"option option-checkbox\"><Checkbox onChange={(_value, checked)=>updateValue(checked)} defaultChecked={initialValue}> {displayName}</Checkbox></div>\r\n    \r\n  } else if ( type == \"number\") {\r\n    return <div className=\"option\">\r\n      <p>{displayName}</p>\r\n      <InputNumber onChange={updateValue} />\r\n    </div>\r\n  } else if ( type == \"regex[]\") {\r\n\r\n    var valid = adding.startsWith(\"/\");\r\n\r\n    return <div className=\"option mb-3\">\r\n\r\n      <div className=\"flex\">\r\n        <p className=\"mb-1\">{displayName}</p>\r\n        <small className=\"ml-auto\">\r\n          <a href=\"https://regexr.com/\" target=\"_blank\">Learn Regex</a>\r\n        </small>\r\n      </div>\r\n    \r\n      \r\n      <div className=\"mb-2\">\r\n        <div className=\"flex items-center\">\r\n          <Input placeholder=\"/^domain.com$/g\" defaultValue={adding} onChange={setAdding}></Input>\r\n          <Button appearance=\"primary\" className=\"ml-2 flex-shrink-0\" onClick={()=>{\r\n            if( !value ) {\r\n              value = [];\r\n            }\r\n            value.push(adding);\r\n            updateValue([...value]);\r\n          }}\r\n          >Add Regex</Button>\r\n        </div>\r\n        \r\n        <div className=\"mt-2\">\r\n          <Animation.Collapse in={!valid}>\r\n            <p className=\"text-danger\">\r\n              Invalid Regex.\r\n            </p>\r\n          </Animation.Collapse>\r\n        </div>\r\n      </div>\r\n   \r\n      <div className=\"mb-2\">\r\n        <TagGroup>\r\n          {(value || []).map((x,i)=>{\r\n            return <Tag closable onClose={()=>{\r\n              value.splice(i, 1);\r\n              updateValue([...value]);\r\n            }}>{x}</Tag>;\r\n          })}\r\n        </TagGroup>\r\n      </div>\r\n\r\n    </div>\r\n\r\n  }\r\n\r\n  return null;\r\n};","import { ObfuscateOptions } from \"./index\";\n\n/**\n * - High Obfuscation preset.\n * - **Average 90% performance reduction.**\n *\n * ## **`Enabled features`**\n * 1. Control Flow Flattening\n * 2. Dispatcher\n * 4. Renamed Variables\n * 5. String Concealing\n * 6. Global variables concealed\n * 7. Concealed `new` expressions\n * 8. Minified\n *\n * ## **`Disabled features`**\n * - `eval` Use at your own risk!\n * - `renameProperties` Can break code.\n * - `globalize` Can break code.\n *\n * ### Potential Issues\n * 1. *String Encoding* can corrupt files. Disabled `stringEncoding` manually if this happens.\n * 2. *Dead Code* can bloat file size. Reduce or disable `deadCode`.\n */\nconst reduction_98_percent: ObfuscateOptions = {\n  target: \"node\",\n  preset: \"high\",\n\n  // heavy\n  dispatcher: true,\n  controlFlowFlattening: 0.75,\n\n  // extract\n  objectExtraction: true,\n\n  // variables\n  renameVariables: true,\n  identifierGenerator: \"randomized\",\n\n  // Simple\n  calculator: true,\n  deadCode: 0.25,\n\n  minify: true,\n  opaquePredicates: 0.75,\n\n  duplicateLiteralsRemoval: 0.75,\n  globalConcealing: true,\n  stringConcealing: true,\n  stringEncoding: true,\n  stringSplitting: 0.75,\n\n  // Use at own risk!\n  eval: false,\n  flatten: true,\n};\n\n/**\n * - Medium Obfuscation preset.\n * - Average 50% performance reduction.\n */\nconst reduction_52_percent: ObfuscateOptions = {\n  target: \"node\",\n  preset: \"medium\",\n\n  // heavy\n  dispatcher: 0.75,\n  controlFlowFlattening: 0.5,\n\n  // extract\n  objectExtraction: true,\n\n  // variables\n  renameVariables: true,\n  identifierGenerator: \"randomized\",\n\n  // Simple\n  calculator: true,\n  deadCode: 0.05,\n\n  minify: true,\n  opaquePredicates: 0.5,\n\n  duplicateLiteralsRemoval: 0.5,\n  globalConcealing: true,\n  stringConcealing: true,\n\n  // Use at own risk!\n  eval: false,\n};\n\n/**\n * - Low Obfuscation preset.\n * - Average 30% performance reduction.\n */\nconst reduction_30_percent: ObfuscateOptions = {\n  target: \"node\",\n  preset: \"low\",\n\n  // heavy\n  dispatcher: 0.5,\n  controlFlowFlattening: 0.25,\n\n  // extract\n  objectExtraction: true,\n\n  // variables\n  renameVariables: true,\n  identifierGenerator: \"randomized\",\n\n  // Simple\n  calculator: true,\n\n  minify: true,\n  opaquePredicates: true,\n\n  duplicateLiteralsRemoval: true,\n  globalConcealing: true,\n\n  // Use at own risk!\n  eval: false,\n};\n\n/**\n * Built-in obfuscator presets.\n */\nconst presets = {\n  high: reduction_98_percent,\n  medium: reduction_52_percent,\n  low: reduction_30_percent,\n};\n\nexport default presets;\n","import { useContext, useState } from \"react\";\r\nimport { Button, Icon, IconButton, Modal, Panel, Radio, RadioGroup, Row, Table, Tooltip, Whisper } from \"rsuite\";\r\n\r\nimport {groups, OptionContext} from \"../App.js\";\r\nimport Option from \"../components/Option.js\";\r\nimport Presets from \"../js-confuser/presets.ts\";\r\n\r\n\r\nconst { Column, HeaderCell, Cell, Pagination } = Table;\r\n\r\n\r\nexport default function Options({show, onHide}){\r\n\r\n  var {options, setOptions} = useContext(OptionContext);\r\n  var [custom, setCustom] = useState(false);\r\n\r\n  return (\r\n    <Modal show={show} onHide={onHide}>\r\n      <Modal.Header>\r\n        <Modal.Title>Options</Modal.Title>\r\n      </Modal.Header>\r\n      <Modal.Body>\r\n        \r\n        {custom?<>\r\n\r\n          <Button appearance=\"link\" onClick={()=>setCustom(false)}>Use Preset</Button>\r\n        \r\n          {Object.keys(groups).map(name=>{\r\n\r\n            return <Panel bordered className=\"m-1\" style={{overflowY: \"scroll\"}}>\r\n              <h6>{name}</h6>\r\n\r\n              {groups[name].map((option, i)=>{\r\n\r\n                var currentValue = option.parentField ? options[option.parentField] && options[option.parentField][option.name] : options[option.name];\r\n\r\n                return <div className=\"option-container\">\r\n\r\n                  <Option {...option} initialValue={currentValue} onChange={value=>{\r\n                  \r\n                    if ( option.parentField ) {\r\n                      if ( !options[option.parentField] ) {\r\n                        options[option.parentField] = {};\r\n                      }\r\n                      options[option.parentField][option.name] = value;\r\n\r\n                      if ( value === false ) {\r\n                        delete options[option.parentField][option.name];\r\n                      }\r\n\r\n                    } else {\r\n                      options[option.name] = value;\r\n                      if ( value === false ) {\r\n                        delete options[option.name];\r\n                      }\r\n                    }\r\n                    setOptions({\r\n                      ...options,\r\n                      preset: null\r\n                    });\r\n                  }} />\r\n\r\n                  <small>{option.description}</small>\r\n                </div>\r\n              })}\r\n            </Panel>\r\n\r\n          })}\r\n\r\n        \r\n        </>:<>\r\n        <p className=\"mb-4\">Choose an obfuscation preset</p>\r\n\r\n        <div className=\"flex items-center\">\r\n          <RadioGroup name=\"radioList\" inline appearance=\"picker\" defaultValue={options.preset} onChange={(value)=>{\r\n            var cloned = {...Presets[value]};\r\n\r\n            setOptions({\r\n              ...options,\r\n              ...cloned\r\n            });\r\n          }}>\r\n            <Radio value=\"low\">Low</Radio>\r\n            <Radio value=\"medium\">Medium</Radio>\r\n            <Radio value=\"high\">High</Radio>\r\n          </RadioGroup>\r\n          <Button appearance={options.preset ? \"default\" : \"primary\"} className=\"ml-auto\" onClick={()=>setCustom(true)}>\r\n            <span className=\"flex items-center\">\r\n              <Icon icon=\"cog\" className=\"mr-1\" />\r\n              Custom Preset\r\n\r\n            </span>\r\n          </Button>\r\n        </div>\r\n  \r\n        <Table className=\"mt-6\"\r\n          data={[{\r\n            preset: \"Low\",\r\n            performance: \"-5% to -10%\",\r\n            sample: <a href=\"\">Sample</a>\r\n          }, {\r\n            preset: \"Medium\",\r\n            performance: \"-20% to -30%\",\r\n            sample: <a href=\"\">Sample</a>\r\n          }, {\r\n            preset: \"High\",\r\n            performance: \"-50% to -70%\",\r\n            sample: <a href=\"\">Sample</a>\r\n          }]}\r\n          >\r\n          <Column width={130} align=\"center\" fixed>\r\n            <HeaderCell>Preset</HeaderCell>\r\n            <Cell dataKey=\"preset\" />\r\n          </Column>\r\n\r\n          <Column width={200}>\r\n            <HeaderCell>Performance Hit</HeaderCell>\r\n            <Cell dataKey=\"performance\" />\r\n          </Column>\r\n\r\n          <Column width={100}>\r\n            <HeaderCell>Sample</HeaderCell>\r\n            <Cell dataKey=\"sample\" />\r\n          </Column>\r\n        </Table>\r\n        </>}\r\n\r\n      </Modal.Body>\r\n      <Modal.Footer>\r\n        <Button onClick={onHide} appearance=\"primary\">\r\n          Save\r\n        </Button>\r\n        <Button onClick={onHide} appearance=\"subtle\">\r\n          Cancel\r\n        </Button>\r\n      </Modal.Footer>\r\n    </Modal>\r\n  )\r\n}","import { useDebugValue, useState } from \"react\";\r\n\r\nfunction setCookie(cname, cvalue, exdays) {\r\n  var d = new Date();\r\n  d.setTime(d.getTime() + (exdays*24*60*60*1000));\r\n  var expires = \"expires=\"+ d.toUTCString();\r\n  document.cookie = cname + \"=\" + cvalue + \";\" + expires + \";path=/\";\r\n}\r\n\r\nfunction getCookie(cname) {\r\n  var name = cname + \"=\";\r\n  var decodedCookie = decodeURIComponent(document.cookie);\r\n  var ca = decodedCookie.split(';');\r\n  for(var i = 0; i <ca.length; i++) {\r\n    var c = ca[i];\r\n    while (c.charAt(0) == ' ') {\r\n      c = c.substring(1);\r\n    }\r\n    if (c.indexOf(name) == 0) {\r\n      return c.substring(name.length, c.length);\r\n    }\r\n  }\r\n  return \"\";\r\n}\r\n\r\nexport default function useCookie(name, defaultValue, days = 1000){\r\n  useDebugValue(\"useCookie\");\r\n\r\n  var [value, setValue] = useState(()=>{\r\n    var cookie = getCookie(name);\r\n\r\n    if ( cookie ) {\r\n      try {\r\n        return JSON.parse( decodeURIComponent(cookie) );\r\n      } catch ( e ) {\r\n\r\n      }\r\n    }\r\n\r\n\r\n    return defaultValue;\r\n  })\r\n\r\n\r\n  return [value, (newValue)=>{\r\n    setCookie(name, encodeURIComponent(JSON.stringify(newValue)), days)\r\n    setValue(newValue);\r\n  }]\r\n};","import * as assert from \"assert\";\r\nimport { Node } from \"./util/gen\";\r\n\r\nconst acorn = require(\"acorn\");\r\n\r\n/**\r\n * Uses `acorn` to parse Javascript Code. Returns an AST tree.\r\n * @param code\r\n * @returns\r\n */\r\nexport default async function parseJS(code: string) {\r\n  assert.ok(typeof code === \"string\", \"code must be a string\");\r\n\r\n  try {\r\n    var parsed = parseSync(code);\r\n    return parsed;\r\n  } catch (e) {\r\n    console.error(e);\r\n    throw new Error(\"Failed to parse code.\");\r\n  }\r\n}\r\n\r\n/**\r\n * Parses a snippet code. Returns an AST Tree.\r\n * @param code\r\n * @returns\r\n */\r\nexport function parseSnippet(code: string): Node {\r\n  return acorn.parse(code, {\r\n    ecmaVersion: \"latest\",\r\n    allowReturnOutsideFunction: true,\r\n    sourceType: \"module\",\r\n  });\r\n}\r\n\r\n/**\r\n * Parses synchronously. Attempts to parse as a es-module, then fallbacks to a script.\r\n * @param code\r\n * @returns\r\n */\r\nexport function parseSync(code): Node {\r\n  try {\r\n    return acorn.parse(code, { ecmaVersion: \"latest\", sourceType: \"module\" });\r\n  } catch (e) {\r\n    return acorn.parse(code, { ecmaVersion: \"latest\", sourceType: \"script\" });\r\n  }\r\n}\r\n","import { ok } from \"assert\";\r\nimport { getBlock, isBlock, getBlocks } from \"../traverse\";\r\nimport { Node, Location } from \"./gen\";\r\nimport { validateChain } from \"./identifiers\";\r\n\r\nexport function isFunction(object: Node): boolean {\r\n  return [\r\n    \"FunctionDeclaration\",\r\n    \"FunctionExpression\",\r\n    \"ArrowFunctionExpression\",\r\n  ].includes(object.type);\r\n}\r\n\r\nexport function isStatement(object: Node): boolean {\r\n  return [\r\n    \"ExpressionStatement\",\r\n    \"VariableDeclaration\",\r\n    \"FunctionDeclaration\",\r\n  ].includes(object.type);\r\n}\r\n\r\n/**\r\n * The function context where the object is.\r\n *\r\n * - Determines if async context.\r\n * - Determines variable context.\r\n *\r\n * @param object\r\n * @param parents\r\n */\r\nexport function getFunction(object: Node, parents: Node[]): Node {\r\n  return parents.find((x) => isFunction(x));\r\n}\r\n\r\n/**\r\n * Refers to the current function or Root node\r\n * @param parents\r\n */\r\nexport function getContext(object: Node, parents: Node[]): Node {\r\n  var fn = getFunction(null, parents);\r\n  if (fn) {\r\n    return fn;\r\n  }\r\n\r\n  var top = parents[parents.length - 1];\r\n\r\n  if (top) {\r\n    ok(\r\n      top.type == \"Program\",\r\n      \"Should be Program found \" +\r\n        top.type +\r\n        \" (\" +\r\n        parents\r\n          .map((x) =>\r\n            x.type || Array.isArray(x) ? \"<array>\" : \"<\" + typeof x + \">\"\r\n          )\r\n          .join(\", \") +\r\n        \" parents, \" +\r\n        (object && object.type) +\r\n        \" object)\"\r\n    );\r\n\r\n    return top;\r\n  }\r\n\r\n  ok(object, \"No parents and no object\");\r\n\r\n  return object;\r\n}\r\n\r\nexport function isContext(context: Node) {\r\n  return (\r\n    isFunction(context) ||\r\n    context.type == \"Program\" ||\r\n    context.type == \"DoExpression\"\r\n  ); // Stage 1\r\n}\r\n\r\nexport function getBlockBody(block: Node): Node[] {\r\n  if (!block) {\r\n    throw new Error(\"no block body\");\r\n  }\r\n  if (Array.isArray(block)) {\r\n    return block;\r\n  }\r\n  return getBlockBody(block.body);\r\n}\r\n\r\n/**\r\n * Returns a human readable path.\r\n * - Example: `Program.anonymous.Rectangle.Rectangle#getVolume`\r\n * @param object\r\n * @param parents\r\n */\r\nexport function getBlockPathName(object: Node, parents: Node[]): string {\r\n  return getBlockPathArray(object, parents)\r\n    .reverse()\r\n    .join(\".\")\r\n    .replace(\"<root>.<root>\", \"<root>\");\r\n}\r\n\r\n/**\r\n * [\"NestedFunction\", \"MainFunction\", \"Program\"].\r\n * - See **`getBlockPathName`** for a human readable version.\r\n * @param object\r\n * @param parents\r\n */\r\nexport function getBlockPathArray(object: Node, parents: Node[]): string[] {\r\n  var list = [object, ...parents];\r\n  var path = [];\r\n\r\n  for (var i = 0; i < list.length; i++) {\r\n    if (isBlock(list[i])) {\r\n      var nObject = list[i];\r\n      var nParents = list.slice(i + 1);\r\n\r\n      path.push(getBlockName(nObject, nParents));\r\n    }\r\n  }\r\n\r\n  return path;\r\n}\r\n\r\nexport function getBlockName(object: Node, parents: Node[]): string {\r\n  var list = [object, ...parents];\r\n\r\n  var idName = new Set([\r\n    \"FunctionDeclaration\",\r\n    \"VariableDeclarator\",\r\n    \"ClassDeclaration\",\r\n  ]);\r\n  var types = {\r\n    WhileStatement: \"<while>\",\r\n    DoWhileStatement: \"<do while>\",\r\n    TryStatement: \"<try>\",\r\n    ForStatement: \"<for>\",\r\n    ForInStatement: \"<for in>\",\r\n    ForOfStatement: \"<for of>\",\r\n    CatchClause: \"<catch>\",\r\n    ThrowStatement: \"<throw>\",\r\n    IfStatement: \"<if>\",\r\n    DoStatement: \"<do>\",\r\n  };\r\n  for (var i = 0; i < list.length; i++) {\r\n    var node = list[i];\r\n    var next = list[i + 1];\r\n\r\n    if (types[node.type]) {\r\n      return types[node.type];\r\n    }\r\n\r\n    if (\r\n      node.type == \"BlockStatement\" &&\r\n      list[i + 1].type == \"TryStatement\" &&\r\n      list[i + 1].finalizer == node\r\n    ) {\r\n      return \"<finally>\";\r\n    }\r\n\r\n    if (next && next.alternate == node) {\r\n      if (node.type == \"IfStatement\") {\r\n        return \"<else-if>\";\r\n      }\r\n      return \"<else>\";\r\n    }\r\n\r\n    // Function calling\r\n    if (node.type == \"FunctionExpression\") {\r\n      // iife\r\n      if (next) {\r\n        if (next.type == \"ExpressionStatement\") {\r\n          return \"anonymous\";\r\n        }\r\n        // callbacks\r\n        if (next.type == \"CallExpression\") {\r\n          var callee = next.callee;\r\n          if (callee.name) {\r\n            return callee.name;\r\n          }\r\n          return \"(intermediate value)\";\r\n        }\r\n        if (next.type == \"AssignmentExpression\") {\r\n          if (next.left.type == \"MemberExpression\") {\r\n            var r = next.left.object.name;\r\n            if (next.left.object.type == \"ThisExpression\") {\r\n              r = \"this\";\r\n            }\r\n            if (next.left.object.type == \"SuperExpression\") {\r\n              r = \"super\";\r\n            }\r\n            return (\r\n              r + \".\" + (next.left.property.value || next.left.property.name)\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      return \"function()\";\r\n    }\r\n\r\n    if (node.type == \"MethodDefinition\") {\r\n      var className = parents.find((x) => x.type == \"ClassDeclaration\").id.name;\r\n\r\n      return (\r\n        className +\r\n        \"#\" +\r\n        node.key.name +\r\n        ([\"set\", \"get\"].includes(node.kind) ? \"[\" + node.kind + \"]\" : \"\")\r\n      );\r\n    }\r\n\r\n    if (idName.has(node.type)) {\r\n      return node.id.name;\r\n    }\r\n\r\n    if (node.type == \"Program\") {\r\n      return i == list.length - 1 ? \"<root>\" : \"<block>\";\r\n    }\r\n  }\r\n\r\n  return \"\";\r\n}\r\n\r\nexport function getIndexAndBlock(\r\n  object: Node,\r\n  parents: Node[]\r\n): { block: Node; index: number } {\r\n  var index, block;\r\n  var search = [object, ...parents];\r\n  var last = object;\r\n\r\n  for (var i = 0; i < search.length; i++) {\r\n    if (isBlock(search[i])) {\r\n      block = search[i];\r\n      index = getBlockBody(block).findIndex((x) => x == last);\r\n\r\n      break;\r\n    }\r\n\r\n    last = search[i];\r\n  }\r\n\r\n  return {\r\n    block: block,\r\n    index: index,\r\n  };\r\n}\r\n\r\nexport function getIndexDirect(object: Node, parent: Node[]): string {\r\n  return Object.keys(parent).find((x) => parent[x] == object);\r\n}\r\n\r\n/**\r\n * Attempts to a delete a variable/functions declaration.\r\n * @param object\r\n * @param parents\r\n */\r\nexport function deleteDeclaration(object: Node, parents: Node[]) {\r\n  // variables\r\n  var list = [object, ...parents];\r\n\r\n  var declaratorIndex = list.findIndex((x) => x.type == \"VariableDeclarator\");\r\n  if (declaratorIndex != -1) {\r\n    var declarator = list[declaratorIndex]; // {type: VariableDeclarator, id: Identifier, init: Literal|Expression...}\r\n    var declarations = list[declaratorIndex + 1]; // declarator[]\r\n    var VariableDeclaration = list[declaratorIndex + 2];\r\n    var body = list[declaratorIndex + 3];\r\n\r\n    deleteDirect(declarator, declarations);\r\n\r\n    if (VariableDeclaration.declarations.length == 0) {\r\n      deleteDirect(VariableDeclaration, body);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Object must be directly nested in parent\r\n */\r\nexport function deleteDirect(object: Node, parent: Node) {\r\n  if (!object) {\r\n    throw new Error(\"object undefined\");\r\n  }\r\n\r\n  if (!parent) {\r\n    throw new Error(\"parent undefined\");\r\n  }\r\n\r\n  validateChain(object, [parent]);\r\n\r\n  if (typeof parent === \"object\") {\r\n    if (Array.isArray(parent)) {\r\n      var index = parent.indexOf(object);\r\n      if (index != -1) {\r\n        // delete\r\n        parent.splice(index, 1);\r\n      } else {\r\n        console.log(\"parent=\", parent);\r\n        console.log(\"object=\", object);\r\n        throw new Error(\"index -1\");\r\n      }\r\n    } else {\r\n      var keyName = Object.keys(parent).find((x) => parent[x] == object);\r\n\r\n      if (keyName) {\r\n        delete parent[keyName];\r\n      } else {\r\n        throw new Error(\"keyName undefined\");\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function replace(object, parents, newObject) {\r\n  // todo key based on body\r\n  Object.assign(newObject, object);\r\n}\r\n\r\nexport function prepend(block: Node, ...nodes: Node[]) {\r\n  ok(!Array.isArray(block), \"block should not be array\");\r\n\r\n  if (block.type == \"Program\") {\r\n    var decs = 0;\r\n    block.body.forEach((stmt, i) => {\r\n      if (stmt.type == \"ImportDeclaration\") {\r\n        if (decs == i) {\r\n          decs++;\r\n        }\r\n      }\r\n    });\r\n\r\n    block.body.splice(decs, 0, ...nodes);\r\n  } else {\r\n    getBlockBody(block).unshift(...nodes);\r\n  }\r\n}\r\n\r\nexport function append(block: Node, ...nodes: Node[]) {\r\n  getBlockBody(block).push(...nodes);\r\n}\r\n\r\nexport function insertBefore(object: Node, parents: Node[], node: Node) {\r\n  var { block, index } = getIndexAndBlock(object, parents);\r\n\r\n  getBlockBody(block).splice(index, 0, node);\r\n}\r\n\r\nexport function insertAfter(object: Node, parents: Node[], node: Node) {\r\n  var { block, index } = getIndexAndBlock(object, parents);\r\n\r\n  getBlockBody(block).splice(index + 1, 0, node);\r\n}\r\n\r\nexport function clone<T>(object: T): T {\r\n  if (typeof object === \"object\" && object) {\r\n    if (Array.isArray(object)) {\r\n      var newArray = [] as unknown as any;\r\n      object.forEach((element) => {\r\n        newArray.push(clone(element));\r\n      });\r\n\r\n      return newArray;\r\n    } else {\r\n      var newObject = {} as T;\r\n\r\n      Object.keys(object).forEach((key) => {\r\n        newObject[key] = clone(object[key]);\r\n      });\r\n\r\n      return newObject;\r\n    }\r\n  }\r\n\r\n  return object as any;\r\n}\r\n","import { ok } from \"assert\";\r\nimport traverse, { walk } from \"../traverse\";\r\nimport { Location, Node } from \"./gen\";\r\nimport { getContext, isContext, isFunction } from \"./insert\";\r\n\r\n/**\r\n * Ensures the chain (object and parents) are connected.\r\n * @param object\r\n * @param parents\r\n */\r\nexport function validateChain(object: Node, parents: Node[]) {\r\n  if (!Array.isArray(parents)) {\r\n    throw new Error(\"parents need to be an array\");\r\n  }\r\n\r\n  if (!object) {\r\n    throw new Error(\"object must be a node (not null)\");\r\n  }\r\n\r\n  if (parents.length > 0) {\r\n    if (object == parents[0]) {\r\n      throw new Error(\"parent overlap\");\r\n    }\r\n    if (!Object.values(parents[0]).includes(object)) {\r\n      console.log(\"parents=\", parents);\r\n      console.log(\"object=\", object);\r\n\r\n      throw new Error(\"parents[0] is not connected to object\");\r\n    }\r\n  }\r\n}\r\n\r\nexport function isWithinClass(object: Node, parents: Node[]) {\r\n  return (\r\n    isWithin(object, parents, \"ClassDeclaration\") ||\r\n    isWithin(object, parents, \"ClassExpression\")\r\n  );\r\n}\r\n\r\nexport function isWithinMethodDefinition(object: Node, parents: Node[]) {\r\n  return isWithin(object, parents, \"MethodDefinition\");\r\n}\r\n\r\nexport function isWithin(object: Node, parents: Node[], type: string): boolean {\r\n  return [object, ...parents].some((x) => x.type == type);\r\n}\r\n\r\n/**\r\n * Returns detailed information about the given Identifier node.\r\n * @param object\r\n * @param parents\r\n */\r\nexport function getIdentifierInfo(object: Node, parents: Node[]) {\r\n  if (object.type != \"Identifier\") {\r\n    console.log(object);\r\n    throw new Error(\"object is not an Identifier, its a type=\" + object.type);\r\n  }\r\n\r\n  var parent = parents[0] || ({} as Node);\r\n\r\n  var isAccessor =\r\n    parent.type == \"MemberExpression\" &&\r\n    parent.object != object &&\r\n    parent.property === object &&\r\n    !parent.computed;\r\n\r\n  var propIndex = parents.findIndex((x) => x.type == \"Property\");\r\n  var isPropertyKey =\r\n    propIndex != -1 &&\r\n    parents[propIndex].key == (parents[propIndex - 1] || object) &&\r\n    !parents[propIndex].computed;\r\n\r\n  var varIndex = parents.findIndex((x) => x.type == \"VariableDeclarator\");\r\n\r\n  var isVariableDeclaration =\r\n    varIndex != -1 && parents[varIndex].id == (parents[varIndex - 1] || object);\r\n\r\n  var forIndex = parents.findIndex((x) => x.type == \"ForStatement\");\r\n  var isForInitializer =\r\n    forIndex != -1 &&\r\n    parents[forIndex].init == (parents[forIndex - 1] || object);\r\n\r\n  var functionIndex = parents.findIndex((x) => isFunction(x));\r\n\r\n  var isFunctionDeclaration =\r\n    functionIndex != -1 &&\r\n    parents[functionIndex].type == \"FunctionDeclaration\" &&\r\n    parents[functionIndex].id == object;\r\n  var isFunctionParameter =\r\n    functionIndex != -1 &&\r\n    parents[functionIndex].params == parents[functionIndex - 1];\r\n  var isClauseParameter = false;\r\n\r\n  // Special case for Catch clauses\r\n  var clauseIndex = parents.findIndex((x) => x.type == \"CatchClause\");\r\n  if (clauseIndex != -1) {\r\n    if (parents[clauseIndex].param == (parents[clauseIndex - 1] || object)) {\r\n      isClauseParameter = true;\r\n    }\r\n  }\r\n\r\n  var isImportSpecifier =\r\n    (parent.type == \"ImportDefaultSpecifier\" ||\r\n      parent.type == \"ImportSpecifier\") &&\r\n    parent.local == object;\r\n\r\n  var isFunctionCall = parent.callee == object; // NewExpression and CallExpression\r\n\r\n  var isAssignmentLeft =\r\n    parent.type == \"AssignmentExpression\" && parent.left == object;\r\n  var isAssignmentValue =\r\n    parent.type == \"AssignmentExpression\" && parent.right == object;\r\n\r\n  var isUpdateExpression = parent.type == \"UpdateExpression\";\r\n\r\n  var isClassDeclaration =\r\n    parent.type == \"ClassDeclaration\" && parent.id == object;\r\n  var isMethodDefinition =\r\n    parent.type == \"MethodDefinition\" && parent.key == object;\r\n\r\n  var isMetaProperty = parent.type == \"MetaProperty\";\r\n\r\n  var isLabel = parent.type == \"LabeledStatement\" && parent.label == object;\r\n\r\n  // Fix 1\r\n  if (parent.type == \"BreakStatement\" || parent.type == \"ContinueStatement\") {\r\n    if (parent.label == object) {\r\n      isLabel = true;\r\n    }\r\n  }\r\n\r\n  return {\r\n    /**\r\n     * MemberExpression: `parent.identifier`\r\n     */\r\n    isAccessor,\r\n    /**\r\n     * Property: `{identifier: ...}`\r\n     */\r\n    isPropertyKey,\r\n    /**\r\n     * `var identifier = ...`\r\n     */\r\n    isVariableDeclaration,\r\n    /**\r\n     * `function identifier(){...}`\r\n     */\r\n    isFunctionDeclaration,\r\n    /**\r\n     * `function a(identifier){...}`\r\n     */\r\n    isFunctionParameter,\r\n\r\n    /**\r\n     * ```js\r\n     * try ... catch ( identifier ) {\r\n     *  ...\r\n     * }\r\n     * ```\r\n     */\r\n    isClauseParameter,\r\n\r\n    /**\r\n     * CallExpression: `identifier()`\r\n     */\r\n    isFunctionCall,\r\n    /**\r\n     * AssignmentExpression: `identifier = ...`\r\n     */\r\n    isAssignmentLeft,\r\n    /**\r\n     * AssignmentExpression (right): `x = identifier`\r\n     */\r\n    isAssignmentValue,\r\n    /**\r\n     * UpdateExpression: `identifier++`\r\n     */\r\n    isUpdateExpression,\r\n    /**\r\n     * ClassDeclaration `class identifier {...}`\r\n     */\r\n    isClassDeclaration,\r\n    /**\r\n     * Method Definition inside a class body\r\n     * ```js\r\n     * class Rectangle {\r\n     *     identifier(){...}\r\n     *\r\n     *     get identifier(){...}\r\n     * }\r\n     * ```\r\n     */\r\n    isMethodDefinition,\r\n\r\n    /**\r\n     * `new.target` or `yield.input`\r\n     */\r\n    isMetaProperty,\r\n\r\n    /**\r\n     * LabelStatement: `identifier: for ( var i...)`\r\n     */\r\n    isLabel,\r\n\r\n    /**\r\n     * ```js\r\n     * for (var i=0; ...) {\r\n     *  ...\r\n     * }\r\n     * ```\r\n     */\r\n    isForInitializer,\r\n\r\n    /**\r\n     * ```js\r\n     * import identifier from \"...\";\r\n     * import {key as identifier} from \"...\";\r\n     * ```\r\n     */\r\n    isImportSpecifier,\r\n\r\n    spec: {\r\n      /**\r\n       * - `export function identifier()...`\r\n       * - `export var identifier = ...`\r\n       */\r\n      isExported:\r\n        (isVariableDeclaration &&\r\n          parents[3].type == \"ExportNamedDeclaration\") ||\r\n        (isFunctionDeclaration &&\r\n          parents[1] &&\r\n          parents[1].type == \"ExportNamedDeclaration\"),\r\n\r\n      /**\r\n       * Is the Identifier defined, i.e a variable declaration, function declaration, parameter, or class definition\r\n       */\r\n      isDefined:\r\n        isVariableDeclaration ||\r\n        isFunctionDeclaration ||\r\n        isFunctionParameter ||\r\n        isClauseParameter ||\r\n        isMethodDefinition ||\r\n        isImportSpecifier,\r\n\r\n      /**\r\n       * Is the Identifier modified, either by an `AssignmentExpression` or `UpdateExpression`\r\n       */\r\n      isModified: isAssignmentLeft || isUpdateExpression,\r\n\r\n      /**\r\n       * Is the Identifier referenced as a variable.\r\n       *\r\n       * - true: `if ( identifier ) {...}`\r\n       * - false `if ( obj.identifier ) {...}`\r\n       * - false `identifier: for ( var ...)`\r\n       * - false `break identifier;`\r\n       */\r\n      isReferenced:\r\n        !isAccessor &&\r\n        !isPropertyKey &&\r\n        !isMetaProperty &&\r\n        !isLabel &&\r\n        !object.name.startsWith(\"0\") &&\r\n        !object.name.startsWith(\"'\"),\r\n    },\r\n  };\r\n}\r\n\r\nexport function getDefiningIdentifier(object: Node, parents: Node[]): Location {\r\n  ok(object.type == \"Identifier\", \"must be identifier\");\r\n  ok(typeof object.name === \"string\");\r\n  ok(\r\n    parents[parents.length - 1].type == \"Program\",\r\n    \"root node must be type Program\"\r\n  );\r\n\r\n  var seen = new Set<Node>();\r\n  var i = 0;\r\n  for (var parent of parents) {\r\n    var l;\r\n    var bestScore = Infinity;\r\n    walk(parent, parents.slice(i + 1), (o, p) => {\r\n      // if (seen.has(o)) {\r\n      //   return \"EXIT\";\r\n      // }\r\n\r\n      if (o.type == \"Identifier\" && o.name === object.name && o !== object) {\r\n        var info = getIdentifierInfo(o, p);\r\n        if (info.spec.isDefined) {\r\n          var contexts = p.filter((x) => isContext(x));\r\n          var definingContext = info.isFunctionDeclaration\r\n            ? getContext(p[0], p.slice(1))\r\n            : getContext(o, p);\r\n\r\n          if (parents.includes(definingContext)) {\r\n            var index = contexts.indexOf(definingContext);\r\n\r\n            if (index < bestScore) {\r\n              l = [o, p];\r\n              bestScore = index;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (l) {\r\n      // console.log(l[0].name, \"->\", l[0], bestScore);\r\n\r\n      return l;\r\n    }\r\n\r\n    seen.add(parent);\r\n    i++;\r\n  }\r\n}\r\n","import { Node } from \"./util/gen\";\r\nimport { validateChain } from \"./util/identifiers\";\r\n\r\n/**\r\n * Returns all the scopes given parents array.\r\n * - `[object, ...parents]` is recommended.\r\n *\r\n * @param parents\r\n */\r\nexport function getBlocks(parents: any[]): any[] {\r\n  return parents.filter((x) => isBlock(x));\r\n}\r\n\r\n/**\r\n * A block refers to any object that has a **`.body`** property where code is nested.\r\n *\r\n * Types: `BlockStatement`, `Program`\r\n *\r\n * @param object\r\n * @param parents\r\n */\r\nexport function getBlock(object: any, parents: any[]) {\r\n  if (!Array.isArray(parents)) {\r\n    throw new Error(\"parents must be an array\");\r\n  }\r\n  return getBlocks([object, ...parents])[0];\r\n}\r\n\r\n/**\r\n * Must have a **`.body`** property and be an array.\r\n *\r\n * - \"BlockStatement\"\r\n * - \"Program\"\r\n *\r\n * @param object\r\n */\r\nexport function isBlock(object: any) {\r\n  return object && !!object.body && Array.isArray(object.body);\r\n}\r\n\r\n/**\r\n * Returns a numerical representation of the depth.\r\n * - Depth is how many blocks nested.\r\n * - Program = 1 depth\r\n * -    First Fn = 2 depth\r\n * -        Nested Fn = 3 depth\r\n * -    Second Fn = 2 depth\r\n * -        etc...\r\n * @param object\r\n * @param parents\r\n */\r\nexport function getDepth(object: any, parents: any[]) {\r\n  if (!Array.isArray(parents)) {\r\n    throw new Error(\"parents should be an array\");\r\n  }\r\n  var scopes = getBlocks([object, ...parents].filter((x) => x));\r\n\r\n  return scopes.length;\r\n}\r\n\r\nexport function traverseBottomUp(\r\n  tree: any,\r\n  callback: (object: any, parents: any[], scope: any) => void\r\n) {\r\n  function recursive(object, parents) {\r\n    if (typeof object === \"object\" && object) {\r\n      var newParents = [object, ...parents];\r\n      if (Array.isArray(object)) {\r\n        var copy = [...object];\r\n        copy.forEach((x) => {\r\n          x && recursive(x, newParents);\r\n        });\r\n      } else {\r\n        Object.keys(object).forEach((key) => {\r\n          var nested = object[key];\r\n          nested && recursive(nested, newParents);\r\n        });\r\n      }\r\n      callback(object, parents, getBlock(object, parents));\r\n    }\r\n  }\r\n\r\n  recursive(tree, []);\r\n}\r\n\r\nexport type EnterCallback = (\r\n  object: Node,\r\n  parents: Node[]\r\n) => ExitCallback | \"EXIT\" | void;\r\nexport type ExitCallback = () => void;\r\n\r\nexport function walk(\r\n  object: Node | Node[],\r\n  parents: Node[],\r\n  onEnter: EnterCallback,\r\n  seen = new Set<Node>()\r\n): \"EXIT\" | void {\r\n  if (typeof object === \"object\" && object) {\r\n    if (seen.has(object as any)) {\r\n      console.log(object);\r\n      throw new Error(\"Already seen: \" + (object as any).type);\r\n    }\r\n    seen.add(object as any);\r\n\r\n    var newParents: Node[] = [object as Node, ...parents];\r\n\r\n    if (!Array.isArray(object)) {\r\n      validateChain(object, parents);\r\n    }\r\n\r\n    // 1. Call `onEnter` function and remember any onExit callback returned\r\n    var onExit = onEnter(object as Node, parents);\r\n\r\n    // 2. Traverse children\r\n    if (Array.isArray(object)) {\r\n      var copy = [...object];\r\n      for (var element of copy) {\r\n        if (walk(element, newParents, onEnter) === \"EXIT\") {\r\n          return \"EXIT\";\r\n        }\r\n      }\r\n      copy.forEach((x) => {});\r\n    } else {\r\n      var keys = Object.keys(object);\r\n      for (var key of keys) {\r\n        if (!key.startsWith(\"$\")) {\r\n          if (walk(object[key], newParents, onEnter) === \"EXIT\") {\r\n            return \"EXIT\";\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (onExit === \"EXIT\") {\r\n      return \"EXIT\";\r\n    }\r\n\r\n    // 3. Done with children, call `onExit` callback\r\n    if (onExit) {\r\n      onExit();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * The bare-bones walker.\r\n *\r\n * - Recursively traverse an AST object.\r\n * - Calls the `onEnter` function with:\r\n * - - `object` - The current node\r\n * - - `parents` - Array of ancestors `[closest, ..., root]`\r\n * - The `onEnter` callback can return an `onExit` callback for that node.\r\n *\r\n * - *Note*: Does not validate the property names.\r\n *\r\n * @param tree\r\n * @param onEnter\r\n */\r\nexport default function traverse(tree, onEnter: EnterCallback) {\r\n  walk(tree, [], onEnter);\r\n}\r\n","import { ok } from \"assert\";\r\nimport { isValidIdentifier } from \"./compare\";\r\n\r\nexport type Type =\r\n  | \"Identifier\"\r\n  | \"Literal\"\r\n  | \"VariableDeclaration\"\r\n  | \"VariableDeclarator\"\r\n  | \"IfStatement\"\r\n  | \"SwitchStatement\"\r\n  | \"SwitchCase\"\r\n  | \"FunctionDeclaration\"\r\n  | \"ClassDeclaration\"\r\n  | \"ClassExpression\"\r\n  | \"ClassBody\"\r\n  | \"BlockStatement\"\r\n  | \"Program\"\r\n  | \"ThisExpression\"\r\n  | \"SuperExpression\"\r\n  | \"ForInStatement\"\r\n  | \"ForOfStatement\"\r\n  | \"WhileStatement\"\r\n  | \"DoWhileStatement\"\r\n  | \"UnaryExpression\"\r\n  | \"ExpressionStatement\"\r\n  | \"AssignmentExpression\"\r\n  | \"NewExpression\"\r\n  | \"CallExpression\"\r\n  | \"ArrayPattern\"\r\n  | \"LogicalExpression\"\r\n  | \"BinaryExpression\"\r\n  | \"UpdateExpression\"\r\n  | \"ThrowStatement\"\r\n  | \"MethodDefinition\"\r\n  | \"LabeledStatement\";\r\n\r\nexport type Node = { type: string; [key: string]: any };\r\n\r\n/**\r\n * 0. First index is the Node.\r\n * 1. Second index is the parents as an array.\r\n */\r\nexport type Location = [Node, Node[]];\r\n\r\n/**\r\n * Eval Callbacks are called once all transformations are done.\r\n *\r\n * - Called with object, parents, and scope.\r\n * - Return value becomes the {$eval} object (Object assign)\r\n */\r\nexport type EvalCallback = {\r\n  $eval: (object: Node, parents: Node[], scope: Node) => any;\r\n  [key: string]: any;\r\n};\r\n\r\n/**\r\n * - 0. First index is the Node.\r\n * - ...1 Parent nodes.\r\n */\r\nexport type Chain = Node[];\r\n\r\nexport function Literal(value: string | number | boolean) {\r\n  if (typeof value === \"undefined\") {\r\n    throw new Error(\"value is undefined\");\r\n  }\r\n  if (typeof value == \"number\" && value < 0) {\r\n    return UnaryExpression(\"-\", Literal(Math.abs(value)));\r\n  }\r\n  return {\r\n    type: \"Literal\",\r\n    value: value,\r\n  };\r\n}\r\n\r\nexport function RegexLiteral(pattern: string, flags: string) {\r\n  return {\r\n    type: \"Literal\",\r\n    regex: {\r\n      pattern,\r\n      flags,\r\n    },\r\n  };\r\n}\r\n\r\nexport function Identifier(name: string) {\r\n  if (!name) {\r\n    throw new Error(\"name is null/empty\");\r\n  }\r\n  if (name == \"this\") {\r\n    throw new Error(\"Use ThisExpression\");\r\n  }\r\n  if (name == \"super\") {\r\n    throw new Error(\"Use SuperExpression\");\r\n  }\r\n  return {\r\n    type: \"Identifier\",\r\n    name: name.toString(),\r\n  };\r\n}\r\n\r\nexport function BlockStatement(body: Node[]) {\r\n  if (!Array.isArray(body)) {\r\n    throw new Error(\"not array\");\r\n  }\r\n  return {\r\n    type: \"BlockStatement\",\r\n    body: body,\r\n  };\r\n}\r\n\r\nexport function LogicalExpression(operator: string, left: Node, right: Node) {\r\n  return {\r\n    type: \"LogicalExpression\",\r\n    operator,\r\n    left,\r\n    right,\r\n  };\r\n}\r\n\r\nexport function BinaryExpression(operator: string, left: Node, right: Node) {\r\n  if (operator == \"||\" || operator == \"&&\") {\r\n    throw new Error(\"invalid operator, use LogicalExpression\");\r\n  }\r\n  return {\r\n    type: \"BinaryExpression\",\r\n    operator,\r\n    left,\r\n    right,\r\n  };\r\n}\r\n\r\nexport function ThisExpression() {\r\n  return { type: \"ThisExpression\" };\r\n}\r\n\r\n/**\r\n *\r\n * @param operator \"+\"\r\n * @param values [Literal(\"Hello\"), Literal(\" \"), Literal(\"World!\")]\r\n */\r\nexport function NestedBinaryExpression(operator: string, values: Node[]) {\r\n  values.reverse();\r\n  var nested: any = {\r\n    type: \"BinaryExpression\",\r\n  };\r\n  var top = nested;\r\n\r\n  values.slice(0, -1).forEach((x) => {\r\n    Object.assign(nested, {\r\n      type: \"BinaryExpression\",\r\n      operator: operator,\r\n      left: {\r\n        type: \"BinaryExpression\",\r\n      },\r\n    });\r\n\r\n    nested.right = x;\r\n    nested = nested.left;\r\n  });\r\n  Object.assign(nested, values[values.length - 1]);\r\n\r\n  return top;\r\n}\r\n\r\nexport function SwitchCase(test: any, consequent: any[]) {\r\n  return {\r\n    type: \"SwitchCase\",\r\n    test,\r\n    consequent,\r\n  };\r\n}\r\n\r\nexport function SwitchDefaultCase(consequent: any[]) {\r\n  return SwitchCase(null, consequent);\r\n}\r\n\r\nexport function LabeledStatement(label: string, body: Node) {\r\n  return {\r\n    type: \"LabeledStatement\",\r\n    label: Identifier(label),\r\n    body: body,\r\n  };\r\n}\r\n\r\nexport function SwitchStatement(discriminant: any, cases: Node[]) {\r\n  return {\r\n    type: \"SwitchStatement\",\r\n    discriminant: discriminant,\r\n    cases: cases,\r\n  };\r\n}\r\n\r\nexport function BreakStatement(label?: string) {\r\n  return {\r\n    type: \"BreakStatement\",\r\n    label: label ? Identifier(label) : null,\r\n  };\r\n}\r\n\r\nexport function Property(key: Node, value: Node, computed = false) {\r\n  if (!key) {\r\n    throw new Error(\"key is undefined\");\r\n  }\r\n  if (!value) {\r\n    throw new Error(\"value is undefined\");\r\n  }\r\n  return {\r\n    type: \"Property\",\r\n    key: key,\r\n    computed: computed,\r\n    value: value,\r\n    kind: \"init\",\r\n    method: false,\r\n    shorthand: false,\r\n  };\r\n}\r\n\r\nexport function ObjectExpression(properties: Node[]) {\r\n  if (!properties) {\r\n    throw new Error(\"properties is null\");\r\n  }\r\n  return {\r\n    type: \"ObjectExpression\",\r\n    properties: properties,\r\n  };\r\n}\r\n\r\nexport function VariableDeclarator(id: string | Node, init: Node = null) {\r\n  if (typeof id === \"string\") {\r\n    id = Identifier(id);\r\n  }\r\n  return {\r\n    type: \"VariableDeclarator\",\r\n    id,\r\n    init,\r\n  };\r\n}\r\n\r\nexport function VariableDeclaration(\r\n  declarations: Node | Node[],\r\n  kind: \"var\" | \"const\" | \"let\" = \"var\"\r\n) {\r\n  if (!Array.isArray(declarations)) {\r\n    declarations = [declarations];\r\n  }\r\n\r\n  ok(Array.isArray(declarations));\r\n  ok(declarations.length);\r\n\r\n  return {\r\n    type: \"VariableDeclaration\",\r\n    declarations: declarations,\r\n    kind: kind,\r\n  };\r\n}\r\n\r\nexport function ForStatement(\r\n  variableDeclaration: any,\r\n  test: any,\r\n  update: any,\r\n  body: any[]\r\n) {\r\n  ok(variableDeclaration);\r\n  ok(test);\r\n  ok(update);\r\n  return {\r\n    type: \"ForStatement\",\r\n    init: variableDeclaration,\r\n    test: test,\r\n    update: update,\r\n    body: BlockStatement(body),\r\n  };\r\n}\r\n\r\nexport function WhileStatement(test: any, body: Node[]) {\r\n  ok(test);\r\n  return {\r\n    type: \"WhileStatement\",\r\n    test,\r\n    body: BlockStatement(body),\r\n  };\r\n}\r\n\r\nexport function IfStatement(\r\n  test: Node,\r\n  consequent: Node[],\r\n  alternate: Node[] | null = null\r\n): Node {\r\n  if (!test) {\r\n    throw new Error(\"test is undefined\");\r\n  }\r\n\r\n  if (!consequent) {\r\n    throw new Error(\"consequent undefined, use empty array instead\");\r\n  }\r\n\r\n  if (!Array.isArray(consequent)) {\r\n    throw new Error(\r\n      \"consequent needs to be array, found \" + (consequent as any).type\r\n    );\r\n  }\r\n\r\n  if (alternate && !Array.isArray(alternate)) {\r\n    throw new Error(\r\n      \"alternate needs to be array, found \" + (alternate as any).type\r\n    );\r\n  }\r\n\r\n  return {\r\n    type: \"IfStatement\",\r\n    test: test,\r\n    consequent: BlockStatement(consequent),\r\n    alternate: alternate ? BlockStatement(alternate) : null,\r\n  };\r\n}\r\n\r\nexport function FunctionExpression(params: Node[], body: any[]) {\r\n  ok(Array.isArray(params), \"params should be an array\");\r\n\r\n  return {\r\n    type: \"FunctionExpression\",\r\n    id: null,\r\n    params: params,\r\n    body: BlockStatement(body),\r\n    generator: false,\r\n    expression: false,\r\n    async: false,\r\n  };\r\n}\r\n\r\n/**\r\n * ```js\r\n * function name(p[0], p[1], p[2], ...p[4]){\r\n *     body[0];\r\n *     body[1]...\r\n * }\r\n * ```\r\n * @param name\r\n * @param params\r\n * @param body\r\n */\r\nexport function FunctionDeclaration(\r\n  name: string,\r\n  params: Node[],\r\n  body: Node[]\r\n) {\r\n  if (!body) {\r\n    throw new Error(\"undefined body\");\r\n  }\r\n  if (body && Array.isArray(body[0])) {\r\n    throw new Error(\"nested array\");\r\n  }\r\n  ok(Array.isArray(params), \"params should be an array\");\r\n  return {\r\n    type: \"FunctionDeclaration\",\r\n    id: Identifier(name),\r\n    params: params,\r\n    body: BlockStatement(body),\r\n    generator: false,\r\n    expression: false,\r\n    async: false,\r\n  };\r\n}\r\n\r\nexport function DebuggerStatement() {\r\n  return {\r\n    type: \"DebuggerStatement\",\r\n  };\r\n}\r\n\r\nexport function ReturnStatement(argument: Node = null) {\r\n  if (argument) {\r\n    ok(argument.type, \"Argument should be a node\");\r\n  }\r\n  return {\r\n    type: \"ReturnStatement\",\r\n    argument: argument,\r\n  };\r\n}\r\n\r\nexport function AwaitExpression(argument: Node) {\r\n  ok(argument.type, \"Argument should be a node\");\r\n  return {\r\n    type: \"AwaitExpression\",\r\n    argument,\r\n  };\r\n}\r\n\r\nexport function ConditionalExpression(\r\n  test: Node,\r\n  consequent: Node,\r\n  alternate: Node\r\n) {\r\n  ok(test);\r\n  ok(consequent);\r\n  ok(alternate);\r\n  return {\r\n    type: \"ConditionalExpression\",\r\n    test,\r\n    consequent,\r\n    alternate,\r\n  };\r\n}\r\n\r\nexport function ExpressionStatement(expression: Node) {\r\n  ok(expression.type);\r\n  return {\r\n    type: \"ExpressionStatement\",\r\n    expression: expression,\r\n  } as Node;\r\n}\r\n\r\nexport function UnaryExpression(operator: string, argument: Node) {\r\n  ok(typeof operator === \"string\");\r\n  ok(argument.type);\r\n\r\n  return {\r\n    type: \"UnaryExpression\",\r\n    operator,\r\n    argument,\r\n  } as Node;\r\n}\r\n\r\nexport function UpdateExpression(\r\n  operator: string,\r\n  argument: Node,\r\n  prefix = false\r\n) {\r\n  return {\r\n    type: \"UpdateExpression\",\r\n    operator,\r\n    argument,\r\n    prefix,\r\n  } as Node;\r\n}\r\n\r\nexport function SequenceExpression(expressions: Node[]) {\r\n  if (!expressions) {\r\n    throw new Error(\"expressions undefined\");\r\n  }\r\n  if (!expressions.length) {\r\n    throw new Error(\"expressions length = 0\");\r\n  }\r\n  return {\r\n    type: \"SequenceExpression\",\r\n    expressions: expressions,\r\n  };\r\n}\r\n\r\nexport function MemberExpression(\r\n  object: Node,\r\n  property: Node,\r\n  computed = true\r\n) {\r\n  if (!object) {\r\n    throw new Error(\"object undefined\");\r\n  }\r\n  if (!property) {\r\n    throw new Error(\"property undefined\");\r\n  }\r\n  if (!computed && property.type == \"Literal\") {\r\n    throw new Error(\"literal must be computed property\");\r\n  }\r\n  if (object.name == \"new\" && property.name == \"target\") {\r\n    throw new Error(\"new.target is a MetaProperty\");\r\n  }\r\n  return {\r\n    type: \"MemberExpression\",\r\n    computed: computed,\r\n    object: object,\r\n    property: property,\r\n  };\r\n}\r\n\r\nexport function CallExpression(callee: Node, args: Node[]) {\r\n  ok(Array.isArray(args), \"args should be an array\");\r\n  return {\r\n    type: \"CallExpression\",\r\n    callee: callee,\r\n    arguments: args,\r\n  };\r\n}\r\n\r\nexport function NewExpression(callee: Node, args: Node[]) {\r\n  return {\r\n    type: \"NewExpression\",\r\n    callee,\r\n    arguments: args,\r\n  };\r\n}\r\n\r\nexport function AssignmentExpression(\r\n  operator: string,\r\n  left: Node,\r\n  right: Node\r\n) {\r\n  return {\r\n    type: \"AssignmentExpression\",\r\n    operator: operator,\r\n    left: left,\r\n    right: right,\r\n  };\r\n}\r\n\r\nexport function ArrayPattern(elements: Node[]) {\r\n  ok(Array.isArray(elements));\r\n  return {\r\n    type: \"ArrayPattern\",\r\n    elements: elements,\r\n  };\r\n}\r\n\r\nexport function ArrayExpression(elements: Node[]) {\r\n  ok(Array.isArray(elements));\r\n  return {\r\n    type: \"ArrayExpression\",\r\n    elements,\r\n  };\r\n}\r\n\r\nexport function AssignmentPattern(left: Node, right: Node) {\r\n  ok(left);\r\n  ok(right);\r\n  return {\r\n    type: \"AssignmentExpression\",\r\n    left: left,\r\n    right: right,\r\n  };\r\n}\r\n\r\nexport function AddComment(node: Node, text: string) {\r\n  if ((node as any).leadingComments) {\r\n    (node as any).leadingComments.push({\r\n      type: \"Block\",\r\n      value: text,\r\n    });\r\n  } else {\r\n    Object.assign(node, {\r\n      leadingComments: [\r\n        {\r\n          type: \"Block\",\r\n          value: text,\r\n        },\r\n      ],\r\n    });\r\n  }\r\n\r\n  return node;\r\n}\r\n\r\nexport function MethodDefinition(\r\n  identifier: Node,\r\n  functionExpression: Node,\r\n  kind: \"method\" | \"constructor\" | \"get\" | \"set\",\r\n  isStatic = true,\r\n  computed = false\r\n) {\r\n  return {\r\n    type: \"MethodDefinition\",\r\n    key: identifier,\r\n    computed: computed,\r\n    value: functionExpression,\r\n    kind: kind,\r\n    static: isStatic,\r\n  } as Node;\r\n}\r\n\r\nexport function ClassDeclaration(\r\n  id: Node,\r\n  superClass: Node = null,\r\n  body: Node[] = []\r\n) {\r\n  return {\r\n    type: \"ClassDeclaration\",\r\n    id: id,\r\n    superClass: superClass,\r\n    body: {\r\n      type: \"ClassBody\",\r\n      body: body,\r\n    },\r\n  } as Node;\r\n}\r\n\r\nexport function ThrowStatement(argument: Node) {\r\n  return {\r\n    type: \"ThrowStatement\",\r\n    argument: argument,\r\n  } as Node;\r\n}\r\n\r\nexport function WithStatement(object: Node, body: Node[]) {\r\n  ok(object, \"object\");\r\n  ok(object.type, \"object should be node\");\r\n\r\n  return {\r\n    type: \"WithStatement\",\r\n    object,\r\n    body: BlockStatement(body),\r\n  };\r\n}\r\n\r\nexport function SpreadElement(argument: Node) {\r\n  return {\r\n    type: \"SpreadElement\",\r\n    argument,\r\n  };\r\n}\r\n","import {\r\n  Literal,\r\n  ObjectExpression,\r\n  Identifier,\r\n  Property,\r\n  Node,\r\n  ArrayExpression,\r\n} from \"./gen\";\r\n\r\nexport function choice<T>(choices: T[]): T {\r\n  var index = Math.floor(Math.random() * choices.length);\r\n  return choices[index];\r\n}\r\n\r\n/**\r\n * **Mutates the given array**\r\n * @param array\r\n */\r\nexport function shuffle(array: any[]): any[] {\r\n  array.sort(() => Math.random() - 0.5);\r\n  return array;\r\n}\r\n\r\n/**\r\n * Returns a random string.\r\n */\r\nexport function getRandomString(length: number) {\r\n  var result = \"\";\r\n  var characters =\r\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n  var charactersLength = characters.length;\r\n  for (var i = 0; i < length; i++) {\r\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function getRandom(min, max) {\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\nexport function getRandomInteger(min, max) {\r\n  return Math.floor(getRandom(min, max));\r\n}\r\n\r\nexport function splitIntoChunks(array, min, max): any[] {\r\n  var chunks = [];\r\n  for (var i = 0; i < array.length; i += 0) {\r\n    var currentLength = getRandomInteger(min, max);\r\n\r\n    chunks.push(array.slice(i, i + currentLength));\r\n\r\n    i += currentLength;\r\n  }\r\n\r\n  return chunks;\r\n}\r\n\r\n/**\r\n * Returns a random expression that will test to `false`.\r\n */\r\nexport function getRandomFalseExpression() {\r\n  var type = choice([\"0\", \"false\", \"null\", \"undefined\", \"NaN\", \"emptyString\"]);\r\n\r\n  switch (type) {\r\n    case \"0\":\r\n      return Literal(0);\r\n    case \"false\":\r\n      return Literal(false);\r\n    case \"null\":\r\n      return Identifier(\"null\");\r\n    case \"undefined\":\r\n      return Identifier(\"undefined\");\r\n    case \"NaN\":\r\n      return Identifier(\"NaN\");\r\n    case \"emptyString\":\r\n      return Literal(\"\");\r\n  }\r\n\r\n  return Literal(false);\r\n}\r\n\r\n/**\r\n * Returns a random expression that will test to `true`\r\n */\r\nexport function getRandomTrueExpression() {\r\n  var type = choice([\r\n    \"number\",\r\n    \"true\",\r\n    \"Infinity\",\r\n    \"nonEmptyString\",\r\n    \"array\",\r\n    \"object\",\r\n  ]);\r\n\r\n  switch (type) {\r\n    case \"number\":\r\n      return Literal(getRandomInteger(1, 100));\r\n    case \"true\":\r\n      return Identifier(\"true\");\r\n    case \"undefined\":\r\n      return Identifier(\"undefined\");\r\n    case \"Infinity\":\r\n      return Identifier(\"Infinity\");\r\n    case \"nonEmptyString\":\r\n      return Literal(getRandomString(getRandomInteger(3, 9)));\r\n    case \"array\":\r\n      return ArrayExpression([]);\r\n    case \"object\":\r\n      return ObjectExpression([]);\r\n  }\r\n\r\n  return Literal(false);\r\n}\r\n\r\nexport function getRandomExpression(nested = false) {\r\n  var type = choice([\"object\", \"literal\"]);\r\n\r\n  if (type == \"object\") {\r\n    return ObjectExpression(\r\n      Array(getRandomInteger(2, 7))\r\n        .fill(0)\r\n        .map((x) => {\r\n          var key = Literal(getRandomString(getRandomInteger(3, 7)));\r\n          var computed = false;\r\n\r\n          // why is TypeScript so fucking dumb about isNaN\r\n          if (\r\n            typeof key.value == \"string\" &&\r\n            isNaN(key.value.charAt(0) as any)\r\n          ) {\r\n            key = Identifier(key.value);\r\n            computed = false;\r\n          }\r\n\r\n          return Property(\r\n            key,\r\n            nested ? getRandomExpression() : getRandomLiteral(),\r\n            computed\r\n          );\r\n        })\r\n    );\r\n  } else {\r\n    return getRandomLiteral();\r\n  }\r\n}\r\n\r\nexport function getRandomLiteral(): Node {\r\n  var type = choice([\"number\", \"string\", \"boolean\", \"undefined\", \"null\"]);\r\n\r\n  switch (type) {\r\n    case \"number\":\r\n      return Literal(getRandomInteger(1, 100));\r\n    case \"string\":\r\n      return Literal(getRandomString(getRandomInteger(5, 14)));\r\n    case \"boolean\":\r\n      return Literal(choice([true, false]));\r\n    case \"undefined\":\r\n      return Identifier(\"undefined\");\r\n    case \"null\":\r\n      return Identifier(\"null\");\r\n  }\r\n\r\n  throw new Error(\"type=\" + type);\r\n}\r\n","import { ComputeProbabilityMap, ObfuscateOptions } from \"../index\";\r\nimport traverse, { getDepth, getBlock, ExitCallback } from \"../traverse\";\r\nimport { AddComment, Node } from \"../util/gen\";\r\nimport { choice, getRandomInteger } from \"../util/random\";\r\nimport { getToStringValue } from \"../compiler\";\r\nimport { ok } from \"assert\";\r\nimport { isValidIdentifier } from \"../util/compare\";\r\nimport Obfuscator from \"../obfuscator\";\r\n\r\n/**\r\n * Keywords disallowed for variable names in ES5 and under.\r\n */\r\nexport const reservedKeywords = new Set([\r\n  \"abstract\",\r\n  \"arguments\",\r\n  \"await\",\r\n  \"boolean\",\r\n  \"break\",\r\n  \"byte\",\r\n  \"case\",\r\n  \"catch\",\r\n  \"char\",\r\n  \"class\",\r\n  \"const\",\r\n  \"continue\",\r\n  \"debugger\",\r\n  \"default\",\r\n  \"delete\",\r\n  \"do\",\r\n  \"double\",\r\n  \"else\",\r\n  \"enum\",\r\n  \"eval\",\r\n  \"export\",\r\n  \"extends\",\r\n  \"false\",\r\n  \"final\",\r\n  \"finally\",\r\n  \"float\",\r\n  \"for\",\r\n  \"function\",\r\n  \"goto\",\r\n  \"if\",\r\n  \"implements\",\r\n  \"import\",\r\n  \"in\",\r\n  \"instanceof\",\r\n  \"int\",\r\n  \"interface\",\r\n  \"let\",\r\n  \"long\",\r\n  \"native\",\r\n  \"new\",\r\n  \"null\",\r\n  \"package\",\r\n  \"private\",\r\n  \"protected\",\r\n  \"public\",\r\n  \"return\",\r\n  \"short\",\r\n  \"static\",\r\n  \"super\",\r\n  \"switch\",\r\n  \"synchronized\",\r\n  \"this\",\r\n  \"throw\",\r\n  \"throws\",\r\n  \"transient\",\r\n  \"true\",\r\n  \"try\",\r\n  \"typeof\",\r\n  \"var\",\r\n  \"void\",\r\n  \"volatile\",\r\n  \"while\",\r\n  \"with\",\r\n  \"yield\",\r\n]);\r\n\r\n/**\r\n * Identifiers that are not actually variables.\r\n */\r\nexport const reservedIdentifiers = new Set([\r\n  \"undefined\",\r\n  \"null\",\r\n  \"NaN\",\r\n  \"Infinity\",\r\n  \"eval\",\r\n  \"arguments\",\r\n]);\r\n\r\nexport function alphabeticalGenerator(index: number) {\r\n  let name = \"\";\r\n  while (index > 0) {\r\n    var t = (index - 1) % 26;\r\n    name = String.fromCharCode(65 + t) + name;\r\n    index = ((index - t) / 26) | 0;\r\n  }\r\n  if (!name) {\r\n    name = \"_\";\r\n  }\r\n  return name;\r\n}\r\n\r\n/**\r\n * Base-call for all transformations.\r\n * - Transformations can have preparation transformations `.before`\r\n * - Transformations can have cleanup transformations `.after`\r\n *\r\n * - `match()` function returns true/false if possible candidate\r\n * - `transform()` function modifies the object\r\n *\r\n * ```js\r\n * class Example extends Transform {\r\n *   constructor(o){\r\n *     super(o);\r\n *   }\r\n *\r\n *   match(object, parents){\r\n *     return object.type == \"...\";\r\n *   }\r\n *\r\n *   transform(object, parents){\r\n *     // onEnter\r\n *\r\n *     return ()=>{\r\n *       // onExit\r\n *     }\r\n *   }\r\n *\r\n *   apply(tree){\r\n *     // onStart\r\n *\r\n *     super.apply(tree);\r\n *\r\n *     // onEnd\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport default class Transform {\r\n  /**\r\n   * The obfuscator.\r\n   */\r\n  obfuscator: Obfuscator;\r\n\r\n  /**\r\n   * The user's options.\r\n   */\r\n  options: ObfuscateOptions;\r\n\r\n  /**\r\n   * Only required for top-level transformations.\r\n   */\r\n  priority: number;\r\n\r\n  /**\r\n   * Transforms to run before, such as `Variable Analysis`.\r\n   */\r\n  before: Transform[];\r\n\r\n  /**\r\n   * Transforms to run after.\r\n   */\r\n  after: Transform[];\r\n\r\n  /**\r\n   * Transformations to run at the same time (can cause conflicts so use sparingly)\r\n   */\r\n  concurrent: Transform[];\r\n\r\n  constructor(obfuscator, priority: number = -1) {\r\n    ok(obfuscator instanceof Obfuscator, \"obfuscator should be an Obfuscator\");\r\n\r\n    this.obfuscator = obfuscator;\r\n    this.options = this.obfuscator.options;\r\n\r\n    this.priority = priority;\r\n\r\n    this.before = [];\r\n    this.after = [];\r\n\r\n    this.concurrent = [];\r\n  }\r\n\r\n  /**\r\n   * A special method for fast-tracking a node through all the remaining transformations.\r\n   *\r\n   * For instance, while `eval` runs at order 8, it needs nodes that are completed when it converts to strings.\r\n   * @param node\r\n   */\r\n  dynamicallyObfuscate(node: Node) {\r\n    if (this.obfuscator.state == \"transform\") {\r\n      var index = this.obfuscator.array.indexOf(this);\r\n      ok(index != -1, \"index != -1\");\r\n\r\n      this.obfuscator.array.slice(0, index - 1).forEach((t) => {\r\n        t.apply(node);\r\n      });\r\n    } else {\r\n      this.obfuscator.array.forEach((t) => {\r\n        if (t != this) {\r\n          t.apply(node);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The transformation name.\r\n   */\r\n  get className() {\r\n    return (this as any).__proto__.constructor.name;\r\n  }\r\n\r\n  /**\r\n   * Run an AST through the transformation (including `pre` and `post` transforms)\r\n   * @param tree\r\n   */\r\n  apply(tree: Node) {\r\n    if (tree.type == \"Program\" && this.options.verbose) {\r\n      console.log(\"#\", this.priority, this.className);\r\n    }\r\n\r\n    /**\r\n     * Run through pre-transformations\r\n     */\r\n    this.before.forEach((x) => x.apply(tree));\r\n\r\n    traverse(tree, (object, parents) => {\r\n      var fns = [];\r\n      fns.push(this.input(object, parents));\r\n\r\n      // Fix 1. Increase performance with multiple transforms on one iteration.\r\n      this.concurrent.forEach((x) => fns.push(x.input(object, parents)));\r\n\r\n      return () => fns.forEach((x) => x && x());\r\n    });\r\n\r\n    /**\r\n     * Cleanup transformations\r\n     */\r\n    this.after.forEach((x) => x.apply(tree));\r\n  }\r\n\r\n  /**\r\n   * The `match` function filters for possible candidates.\r\n   *\r\n   * - If `true`, the node is sent to the `transform()` method\r\n   * - else it's discarded.\r\n   *\r\n   * @param object\r\n   * @param parents\r\n   * @param block\r\n   */\r\n  match(object: Node, parents: Node[]): boolean {\r\n    throw new Error(\"not implemented\");\r\n  }\r\n\r\n  /**\r\n   * Modifies the given node.\r\n   *\r\n   * - Return a function to be ran when the node is exited.\r\n   * - The node is safe to modify in most cases.\r\n   *\r\n   * @param object - Current node\r\n   * @param parents - Array of ancestors `[Closest, ..., Root]`\r\n   * @param block\r\n   */\r\n  transform(object: Node, parents: Node[]): ExitCallback | void {\r\n    throw new Error(\"not implemented\");\r\n  }\r\n\r\n  /**\r\n   * Calls `.match` with the given parameters, and then `.transform` if satisfied.\r\n   * @private\r\n   */\r\n  input(object: Node, parents: Node[]): ExitCallback | void {\r\n    if (this.match(object, parents)) {\r\n      return this.transform(object, parents);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a random string.\r\n   */\r\n  getPlaceholder() {\r\n    const genRanHex = (size) =>\r\n      [...Array(size)]\r\n        .map(() => Math.floor(Math.random() * 10).toString(10))\r\n        .join(\"\");\r\n    return \"_\" + genRanHex(10);\r\n  }\r\n\r\n  getGenerator(offset = 0) {\r\n    var count = offset;\r\n    return {\r\n      generate: () => {\r\n        count++;\r\n        return this.generateIdentifier(-1, count);\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generates a valid variable name.\r\n   * @param length Default length is 6 to 10 characters.\r\n   * @returns **`string`**\r\n   */\r\n  generateIdentifier(length: number = -1, count = -1): string {\r\n    if (length == -1) {\r\n      length = getRandomInteger(6, 8);\r\n    }\r\n    if (count == -1) {\r\n      this.obfuscator.varCount++;\r\n      count = this.obfuscator.varCount;\r\n    }\r\n\r\n    var identifier = ComputeProbabilityMap(\r\n      this.options.identifierGenerator,\r\n      (mode = \"randomized\") => {\r\n        switch (mode) {\r\n          case \"randomized\":\r\n            var characters =\r\n              \"_$ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".split(\r\n                \"\"\r\n              );\r\n            var numbers = \"0123456789\".split(\"\");\r\n\r\n            var combined = [...characters, ...numbers];\r\n\r\n            var result = \"\";\r\n            for (var i = 0; i < length; i++) {\r\n              result += choice(i == 0 ? characters : combined);\r\n            }\r\n            return result;\r\n\r\n          case \"hexadecimal\":\r\n            const genRanHex = (size) =>\r\n              [...Array(size)]\r\n                .map(() => Math.floor(Math.random() * 16).toString(16))\r\n                .join(\"\");\r\n\r\n            return \"_0x\" + genRanHex(length).toUpperCase();\r\n\r\n          case \"mangled\":\r\n            while (1) {\r\n              var result = alphabeticalGenerator(count);\r\n              count++;\r\n\r\n              if (\r\n                reservedKeywords.has(result) ||\r\n                reservedIdentifiers.has(result)\r\n              ) {\r\n              } else {\r\n                return result;\r\n              }\r\n            }\r\n\r\n            throw new Error(\"impossible but TypeScript insists\");\r\n\r\n          case \"number\":\r\n            return \"var_\" + count;\r\n\r\n          case \"zeroWidth\":\r\n            var keyWords = [\r\n              \"if\",\r\n              \"in\",\r\n              \"for\",\r\n              \"let\",\r\n              \"new\",\r\n              \"try\",\r\n              \"var\",\r\n              \"case\",\r\n              \"else\",\r\n              \"null\",\r\n              \"break\",\r\n              \"catch\",\r\n              \"class\",\r\n              \"const\",\r\n              \"super\",\r\n              \"throw\",\r\n              \"while\",\r\n              \"yield\",\r\n              \"delete\",\r\n              \"export\",\r\n              \"import\",\r\n              \"public\",\r\n              \"return\",\r\n              \"switch\",\r\n              \"default\",\r\n              \"finally\",\r\n              \"private\",\r\n              \"continue\",\r\n              \"debugger\",\r\n              \"function\",\r\n              \"arguments\",\r\n              \"protected\",\r\n              \"instanceof\",\r\n              \"function\",\r\n              \"await\",\r\n              \"async\",\r\n            ];\r\n\r\n            var safe = \"\\u200C\".repeat(count + 1);\r\n\r\n            var base = choice(keyWords) + safe;\r\n            return base;\r\n        }\r\n\r\n        throw new Error(\"Invalid 'identifierGenerator' mode: \" + mode);\r\n      }\r\n    );\r\n\r\n    if (!identifier) {\r\n      throw new Error(\"identifier null\");\r\n    }\r\n    return identifier;\r\n  }\r\n\r\n  getToStringValue(\r\n    tree: Node,\r\n    syntax: (code: string) => string = (x) => x\r\n  ): string {\r\n    ok(typeof syntax === \"function\");\r\n    return getToStringValue(tree, syntax, this.options);\r\n  }\r\n\r\n  /**\r\n   * Smartly appends a comment to a Node.\r\n   * - Includes the transformation's name.\r\n   * @param node\r\n   * @param text\r\n   * @param i\r\n   */\r\n  addComment(node: Node, text: string) {\r\n    if (this.options.debugComments) {\r\n      return AddComment(node, `[${this.className}] ${text}`);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  replace(node1: Node, node2: Node) {\r\n    for (var key in node1) {\r\n      delete node1[key];\r\n    }\r\n\r\n    this.objectAssign(node1, node2);\r\n  }\r\n\r\n  /**\r\n   * Smartly merges two Nodes.\r\n   * - Null checking\r\n   * - Preserves comments\r\n   * @param node1\r\n   * @param node2\r\n   */\r\n  objectAssign(node1: Node, node2: Node): Node {\r\n    ok(node1);\r\n    ok(node2);\r\n\r\n    var comments1 = node1.leadingComments || [];\r\n    var comments2 = node2.leadingComments || [];\r\n    var comments = [...comments1, ...comments2];\r\n\r\n    node2.leadingComments = comments;\r\n\r\n    node1._transform = node2._transform = this.className;\r\n\r\n    return Object.assign(node1, node2);\r\n  }\r\n\r\n  /**\r\n   * Logging utils below\r\n   */\r\n\r\n  /**\r\n   * Verbose logging for this transformation.\r\n   * @param messages\r\n   */\r\n  log(...messages: any[]) {\r\n    if (this.options.verbose) {\r\n      console.log(\"[\" + this.className + \"]\", ...messages);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verbose logging for warning/importing messages.\r\n   * @param messages\r\n   */\r\n  warn(...messages: any[]) {\r\n    if (this.options.verbose) {\r\n      console.log(\"[ WARN \" + this.className + \" ]\", ...messages);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Throws an error. Appends the transformation's name to the error's message.\r\n   * @param error\r\n   */\r\n  error(error: Error): never {\r\n    throw new Error(`${this.className} Error: ${error.message}`);\r\n  }\r\n}\r\n","import Transform from \"./transform\";\nimport { Identifier, LabeledStatement } from \"../util/gen\";\nimport { getBlock, walk } from \"../traverse\";\nimport { isLoop } from \"./preparation/preparation\";\nimport { clone } from \"../util/insert\";\n\n/**\n * Ensures every break; statement has a label to point to.\n *\n * This is because Control Flow Flattening adds For Loops which label-less break statements point to the nearest,\n * when they actually need to point to the original statement.\n *\n */\nexport default class Label extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object, parents) {\n    return isLoop(object);\n  }\n\n  transform(object, parents) {\n    return () => {\n      var currentLabel =\n        parents[0].type == \"LabeledStatement\" && parents[0].label.name;\n\n      var label = currentLabel || this.getPlaceholder();\n\n      walk(object, parents, (o, p) => {\n        var loop = p.find((x) => isLoop(x));\n        if (object == loop) {\n          if (o.type == \"BreakStatement\") {\n            if (!o.label) {\n              o.label = Identifier(label);\n            }\n          }\n        }\n      });\n\n      // Append label statement as this loop has none\n      if (!currentLabel) {\n        this.replace(object, LabeledStatement(label, clone(object)));\n      }\n    };\n  }\n}\n","import { walk } from \"../traverse\";\r\nimport { Node } from \"./gen\";\r\nimport { getBlockBody, isFunction } from \"./insert\";\r\n\r\nexport function isEquivalent(first: Node, second: Node){\r\n\r\n  var extra = {\r\n    \"start\": 1,\r\n    \"end\": 1,\r\n    \"loc\": 1\r\n  };\r\n\r\n  function removeExtra(obj) {\r\n    if ( typeof obj === \"object\") {\r\n      for (var property in obj) {\r\n        if (obj && obj.hasOwnProperty(property)) {\r\n          if (typeof obj[property] == \"object\") {\r\n            removeExtra(obj[property]);\r\n          } else {\r\n            if ( extra[property] ) {\r\n              delete obj[property];\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n\r\n    return obj;\r\n  }\r\n  return JSON.stringify(removeExtra(first)) == JSON.stringify(removeExtra(second));\r\n};\r\n\r\nexport function isValidIdentifier(name: string): boolean {\r\n  if ( typeof name !== \"string\") {\r\n    return false;\r\n  }\r\n  if ( name.includes(\".\") || name.includes(\" \") ) {\r\n    return false;\r\n  }\r\n\r\n  var x = name.match(/^[A-z$_][A-z0-9$_]*/);\r\n  return x && x[0] == name;\r\n}\r\n\r\nexport function isDeclaration(object: any): boolean {\r\n  if ( !object ) {\r\n    throw new Error(\"object is undefined\")\r\n  }\r\n  return [\"FunctionDeclaration\", \"VariableDeclaration\"].includes(object.type);\r\n}\r\n\r\n\r\nexport function isInsideType(type: string, object: Node, parents: Node[]): boolean {\r\n  return [object, ...parents].some(x=>x.type==type);\r\n};\r\n\r\nexport function isStrictMode(object: Node, parents: Node[]): boolean {\r\n  var functions = parents.filter(x=>isFunction(x));\r\n\r\n  for ( var fn of functions ) {\r\n    var first = getBlockBody(fn.body)[0];\r\n    if ( first && first.type == \"ExpressionStatement\" && first.expression.type == \"Literal\" && first.expression.value == \"strict mode\" ) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function isInside(finding: any, object: any, parents: any): boolean {\r\n  var found = false;\r\n  walk(object, parents, (object2, parents2)=>{\r\n    if ( object2 == finding ) {\r\n      found = true;\r\n    }\r\n  });\r\n\r\n  return found;\r\n};\r\n\r\nexport function isIndependent(object: Node, parents: Node[]){\r\n\r\n  if (object.type == \"Literal\") {\r\n    return true;\r\n  }\r\n\r\n  var parent = parents[0];\r\n\r\n  if ( object.type == \"Identifier\") {\r\n    var set = new Set([\"null\", \"undefined\"]);\r\n    if ( set.has(object.name) ) {\r\n      return true;\r\n    }\r\n    if (parent.type == \"Property\") {\r\n      if ( !parent.computed && parent.key == object ) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  if ( object.type == \"ArrayExpression\" || object.type == \"ObjectExpression\" || object.type == \"Property\") {\r\n    var allowIt = true;\r\n    walk(object, parents, ($object, $parents)=>{\r\n      if ( object != $object ) {\r\n        if ( !Array.isArray($object) && !isIndependent($object, $parents) ) {\r\n          allowIt = false;\r\n        }\r\n      }\r\n    });\r\n\r\n    return allowIt;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport function getFactors(num: number): number[] {\r\n  return Array.from(Array(num + 1), (_, i) => i).filter(i => num % i === 0)\r\n}","import { ok } from \"assert\";\nimport { ObfuscateOrder } from \"../../obfuscator\";\nimport { walk } from \"../../traverse\";\nimport { Location, Node } from \"../../util/gen\";\nimport { getIdentifierInfo } from \"../../util/identifiers\";\nimport { getContext, isContext, isFunction } from \"../../util/insert\";\nimport { isValidIdentifier } from \"../../util/compare\";\nimport Transform, { reservedIdentifiers } from \"../transform\";\n\n/**\n * Keeps track of what identifiers are defined and referenced in each context.\n */\nexport class VariableAnalysis extends Transform {\n  /**\n   * Node being the context.\n   *\n   * A context is:\n   * - Program (global context, the root node)\n   * - or Function\n   */\n  defined: Map<Node, Set<string>>;\n  references: Map<Node, Set<string>>;\n  nodes: Map<Node, Set<Location>>;\n\n  constructor(o) {\n    super(o);\n\n    this.defined = new Map();\n    this.references = new Map();\n    this.nodes = new Map();\n  }\n\n  match(object, parents) {\n    return isContext(object);\n  }\n\n  transform(object, parents) {\n    var isGlobal = object.type == \"Program\";\n\n    walk(object, parents, (o, p) => {\n      if (o.type == \"Identifier\") {\n        var name = o.name;\n        ok(typeof name === \"string\");\n        if (!isValidIdentifier(name)) {\n          return;\n        }\n\n        if (reservedIdentifiers.has(name)) {\n          return;\n        }\n        if (this.options.globalVariables.has(name)) {\n          return;\n        }\n\n        var c = getContext(o, p);\n        var info = getIdentifierInfo(o, p);\n        if (!info.spec.isReferenced) {\n          return;\n        }\n\n        if (info.spec.isExported) {\n          return;\n        }\n\n        // Since a function's `.id` is nested within the function(i.e a new context)\n        // we must go one context up\n        if (info.isFunctionDeclaration) {\n          var fnIndex = p.findIndex((x) => isFunction(x));\n          c = p.slice(fnIndex + 1).find((x) => isContext(x));\n        }\n\n        ok(isContext(c), `${c.type} is not a context`);\n\n        // Add to nodes array (its actually a set)\n        if (object.type == \"Program\") {\n          if (!this.nodes.has(c)) {\n            this.nodes.set(c, new Set());\n          }\n          this.nodes.get(c).add([o, p]);\n        }\n\n        if (info.spec.isDefined) {\n          // Add to defined Map\n          if (!this.defined.has(c)) {\n            this.defined.set(c, new Set());\n          }\n          this.defined.get(c).add(name);\n          this.references.has(c) && this.references.get(c).delete(name);\n        } else {\n          // Add to references Map\n          if (!this.defined.has(c) || !this.defined.get(c).has(name)) {\n            if (!this.references.has(c)) {\n              this.references.set(c, new Set());\n            }\n            this.references.get(c).add(name);\n          }\n        }\n      }\n    });\n\n    // console.log(isGlobal ? \"<Global>\" : object.id && object.id.name || \"<FunctionExpression>\", this.defined.get(object), this.references.get(object));\n\n    if (!this.defined.has(object)) {\n      this.defined.set(object, new Set());\n    }\n    if (!this.references.has(object)) {\n      this.references.set(object, new Set());\n    }\n  }\n}\n\n/**\n * Rename variables to randomly generated names.\n *\n * - Attempts to re-use already generated names in nested scopes.\n */\nexport default class RenameVariables extends Transform {\n  // Generator object\n  gen: any;\n\n  // Names already used\n  generated: string[];\n\n  // Map of Context->Object of changes\n  changed: Map<Node, { [name: string]: string }>;\n\n  // Ref to VariableAnalysis data\n  variableAnalysis: VariableAnalysis;\n\n  constructor(o) {\n    super(o, ObfuscateOrder.RenameVariables);\n\n    this.changed = new Map();\n    this.before.push((this.variableAnalysis = new VariableAnalysis(o)));\n    this.gen = this.getGenerator();\n    this.generated = [];\n  }\n\n  match(object, parents) {\n    return isContext(object);\n  }\n\n  transform(object, parents) {\n    var isGlobal = object.type == \"Program\";\n\n    var newNames = Object.create(null);\n\n    var defined = this.variableAnalysis.defined.get(object);\n    var references = this.variableAnalysis.references.get(object);\n\n    if (!defined && !this.changed.has(object)) {\n      this.changed.set(object, Object.create(null));\n      return;\n    }\n\n    var possible = new Set();\n\n    if (this.generated.length && !isGlobal) {\n      var allReferences = new Set(references || []);\n      var nope = new Set(defined);\n      walk(object, [], (o, p) => {\n        if (isContext(o)) {\n          var ref = this.variableAnalysis.references.get(o);\n          if (ref) {\n            ref.forEach((x) => allReferences.add(x));\n          }\n\n          var def = this.variableAnalysis.defined.get(o);\n          if (def) {\n            def.forEach((x) => allReferences.add(x));\n          }\n        }\n      });\n\n      var passed = new Set();\n      parents.forEach((p) => {\n        var changes = this.changed.get(p);\n        if (changes) {\n          Object.keys(changes).forEach((x) => {\n            var name = changes[x];\n\n            if (!allReferences.has(x)) {\n              passed.add(name);\n            } else {\n              nope.add(name);\n            }\n          });\n        }\n      });\n\n      nope.forEach((x) => passed.delete(x));\n\n      possible = passed;\n    }\n\n    defined.forEach((name) => {\n      if (possible.size) {\n        var first = possible.values().next().value;\n        possible.delete(first);\n        newNames[name] = first;\n      } else {\n        // Fix 1. Use `generateIdentifier` over `gen.generate()` so Integrity can get unique variable names\n        var g = this.generateIdentifier();\n        newNames[name] = g;\n        this.generated.push(g);\n      }\n    });\n\n    this.changed.set(object, newNames);\n\n    walk(object, parents, (o, p) => {\n      if (o.type == \"Identifier\") {\n        if (\n          reservedIdentifiers.has(o.name) ||\n          this.options.globalVariables.has(o.name)\n        ) {\n          return;\n        }\n\n        var info = getIdentifierInfo(o, p);\n\n        if (info.spec.isExported) {\n          return;\n        }\n\n        if (!info.spec.isReferenced) {\n          return;\n        }\n\n        var contexts = [o, ...p].filter((x) => isContext(x));\n        var newName = null;\n\n        for (var check of contexts) {\n          if (\n            this.variableAnalysis.defined.has(check) &&\n            this.variableAnalysis.defined.get(check).has(o.name)\n          ) {\n            if (this.changed.has(check) && this.changed.get(check)[o.name]) {\n              newName = this.changed.get(check)[o.name];\n              break;\n            }\n          }\n        }\n\n        if (newName) {\n          if (o.$renamed) {\n            return;\n          }\n\n          // console.log(o.name, \"->\", newName);\n          o.name = newName;\n          o.$renamed = true;\n        }\n      }\n    });\n  }\n}\n","/**\n * The file contains all preparation transformations\n */\nimport Transform, { reservedIdentifiers } from \"../transform\";\n\nimport {\n  BlockStatement,\n  Identifier,\n  LabeledStatement,\n  Literal,\n  Node,\n  ReturnStatement,\n} from \"../../util/gen\";\nimport { ObfuscateOrder } from \"../../obfuscator\";\nimport {\n  getIndexDirect,\n  getContext,\n  isContext,\n  getBlockBody,\n  clone,\n} from \"../../util/insert\";\nimport { ok } from \"assert\";\nimport { getIdentifierInfo } from \"../../util/identifiers\";\nimport { isBlock, walk } from \"../../traverse\";\nimport Label from \"../label\";\nimport { VariableAnalysis } from \"../identifier/renameVariables\";\n\n/**\n * Devs use shortcuts and its harder to parse.\n *\n * - `if (a) b()` -> `if (a) { b() }`\n * - Ensures all bodies are `BlockStatement`, not individual expression statements\n */\nclass Block extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object, parents) {\n    return !Array.isArray(object);\n  }\n\n  transform(object, parents) {\n    switch (object.type) {\n      case \"IfStatement\":\n        if (object.consequent.type != \"BlockStatement\") {\n          object.consequent = BlockStatement([clone(object.consequent)]);\n        }\n        if (object.alternate && object.alternate.type != \"BlockStatement\") {\n          object.alternate = BlockStatement([clone(object.alternate)]);\n        }\n        break;\n\n      case \"WhileStatement\":\n      case \"WithStatement\":\n      case \"ForStatement\":\n      case \"ForOfStatement\":\n      case \"ForInStatement\":\n        if (object.body.type != \"BlockStatement\") {\n          object.body = BlockStatement([clone(object.body)]);\n        }\n        break;\n\n      case \"ArrowFunctionExpression\":\n        if (object.body.type != \"BlockStatement\") {\n          if (object.body.type == \"ReturnStatement\") {\n            object.body = BlockStatement([clone(object.body)]);\n          } else {\n            object.body = BlockStatement([ReturnStatement(clone(object.body))]);\n          }\n          object.expression = false;\n        }\n        break;\n    }\n  }\n}\n\n/**\n * Brings all the function declarations to the top.\n *\n * - This is so the first Identifier traversed to is the definition.\n */\nclass FunctionsFirst extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object, parents) {\n    return isBlock(object);\n  }\n\n  transform(object, parents) {\n    return () => {\n      var body = getBlockBody(object.body);\n      var functionDeclarations: Node[] = [];\n      var indices: number[] = [];\n\n      var isTop = true;\n\n      body.forEach((stmt, i) => {\n        if (stmt.type == \"FunctionDeclaration\") {\n          if (!isTop) {\n            functionDeclarations.unshift(stmt);\n            indices.unshift(i);\n          }\n        } else {\n          isTop = false;\n        }\n      });\n\n      functionDeclarations.forEach((fn, i) => {\n        var index = indices[i];\n        body.splice(index, 1);\n      });\n\n      body.unshift(\n        ...functionDeclarations.map((x) => {\n          return clone(x);\n        })\n      );\n    };\n  }\n}\n\nclass ExplicitIdentifiers extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object, parents) {\n    return object.type == \"Identifier\";\n  }\n\n  transform(object, parents) {\n    var info = getIdentifierInfo(object, parents);\n    if (info.isPropertyKey || info.isAccessor || info.isMethodDefinition) {\n      this.log(object.name, \"->\", `'${object.name}'`);\n\n      this.replace(object, Literal(object.name));\n      parents[0].computed = true;\n    }\n  }\n}\n\n/**\n * Statements that allowed `break;` and `continue;` statements\n * @param object\n */\nexport function isLoop(object: Node) {\n  return [\n    \"SwitchStatement\",\n    \"WhileStatement\",\n    \"DoWhileStatement\",\n    \"ForStatement\",\n    \"ForInStatement\",\n    \"ForOfStatement\",\n  ].includes(object.type);\n}\n\n/**\n * Ensures all `break;` and `continue;` are labeled.\n * - Needed for complex CFF.\n */\nclass ExplicitLabel extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object, parents) {\n    return isLoop(object);\n  }\n\n  transform(object, parents) {\n    var parent = parents[0];\n    if (parent.type != \"LabeledStatement\") {\n      var label = this.getPlaceholder();\n\n      walk(object, parents, (o, p) => {\n        var context = p.find((x) => isLoop(x));\n        if (context == object) {\n          if (o.type == \"BreakStatement\") {\n            if (!o.label) {\n              o.label = Identifier(label);\n            }\n          }\n        }\n      });\n\n      var index = getIndexDirect(object, parent);\n      ok(index !== undefined, \"index cannot be undefined\");\n\n      this.replace(object, LabeledStatement(label, clone(object)));\n    }\n  }\n}\n\nclass ExplicitDeclarations extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object, parents) {\n    return object.type == \"VariableDeclaration\";\n  }\n\n  transform(object, parents) {\n    // for ( var x in ... ) {...}\n    var forIndex = parents.findIndex(\n      (x) => x.type == \"ForInStatement\" || x.type == \"ForOfStatement\"\n    );\n    if (\n      forIndex != -1 &&\n      parents[forIndex].left == (parents[forIndex - 1] || object)\n    ) {\n      object.declarations.forEach((x) => {\n        x.init = null;\n      });\n      return;\n    }\n\n    var body = parents[0];\n    if (isLoop(body) || body.type == \"LabeledStatement\") {\n      return;\n    }\n\n    if (body.type == \"ExportNamedDeclaration\") {\n      return;\n    }\n\n    if (!Array.isArray(body)) {\n      this.error(new Error(\"body is \" + body.type));\n    }\n\n    if (object.declarations.length > 1) {\n      // Make singular\n\n      var index = body.indexOf(object);\n      if (index == -1) {\n        this.error(new Error(\"index is -1\"));\n      }\n\n      var after = object.declarations.slice(1);\n\n      body.splice(\n        index + 1,\n        0,\n        ...after.map((x) => {\n          return {\n            type: \"VariableDeclaration\",\n            declarations: [clone(x)],\n            kind: object.kind,\n          };\n        })\n      );\n\n      object.declarations.length = 1;\n    }\n  }\n}\n\n/**\n * Renames variables & removes conflicts.\n *\n * - This helps transformations like `Dispatcher` not replace re-declared identifiers.\n */\nclass NameConflicts extends Transform {\n  declared: Set<string>;\n  counts: { [name: string]: number };\n  variableAnalysis: VariableAnalysis;\n\n  constructor(o) {\n    super(o);\n\n    this.before.push((this.variableAnalysis = new VariableAnalysis(o)));\n    this.declared = new Set();\n    this.counts = Object.create(null);\n  }\n\n  match(object, parents) {\n    return isContext(object);\n  }\n\n  transform(object, parents) {\n    // These properties are added to all context's by VariableAnalysis\n    var defined = this.variableAnalysis.defined.get(object);\n    var references = this.variableAnalysis.references.get(object);\n    var nodes = this.variableAnalysis.nodes.get(object);\n\n    if (!nodes) {\n      return;\n    }\n\n    if (!defined) {\n      return;\n    }\n\n    var changing = Object.create(null);\n\n    nodes.forEach(([node, p]) => {\n      var name = node.name;\n\n      if (!this.counts[name]) {\n        this.counts[name] = 0;\n      }\n      this.counts[name]++;\n\n      var newName = this.getPlaceholder() + \"_\" + name;\n      if (this.declared.has(name) && !changing[name]) {\n        newName = newName + \"_conflict_\" + this.counts[name];\n      }\n\n      // Change\n      changing[name] = newName;\n    });\n\n    defined.forEach((x) => this.declared.add(x));\n\n    var changes = Object.keys(changing).length;\n\n    if (changes > 0) {\n      walk(object, parents, (o, p) => {\n        var chain = [o, ...p];\n\n        if (isContext(o)) {\n          var thisNodes = this.variableAnalysis.nodes.get(o);\n\n          if (thisNodes) {\n            var contexts = chain.filter((x) => isContext(x));\n            thisNodes.forEach(([x, xP]) => {\n              var definedAt = contexts.find(\n                (y) =>\n                  this.variableAnalysis.defined.has(y) &&\n                  this.variableAnalysis.defined.get(y).has(x.name)\n              );\n              if (definedAt === object) {\n                if (changing[x.name]) {\n                  x.name = changing[x.name];\n                }\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n}\n\nexport default class Preparation extends Transform {\n  constructor(o) {\n    super(o, ObfuscateOrder.Preparation);\n\n    // this.before.push(new Block(o));\n    this.before.push(new Label(o));\n    this.before.push(new ExplicitIdentifiers(o));\n    // this.before.push(new ExplicitLabel(o));\n    this.before.push(new FunctionsFirst(o));\n    this.before.push(new ExplicitDeclarations(o));\n\n    if (this.options.renameVariables) {\n      this.before.push(new NameConflicts(o));\n    }\n  }\n\n  match() {\n    return false;\n  }\n}\n","import Transform from \"../transform\";\nimport { isBlock, getBlock, walk } from \"../../traverse\";\nimport {\n  Node,\n  Location,\n  Identifier,\n  VariableDeclaration,\n  FunctionDeclaration,\n  VariableDeclarator,\n} from \"../../util/gen\";\nimport { ComputeProbabilityMap } from \"../../index\";\nimport {\n  deleteDeclaration,\n  getContext,\n  isContext,\n  prepend,\n} from \"../../util/insert\";\nimport { ObfuscateOrder } from \"../../obfuscator\";\nimport { getIdentifierInfo } from \"../../util/identifiers\";\nimport { isValidIdentifier } from \"../../util/compare\";\n\n/**\n * Extracts keys out of an object if possible.\n * ```js\n * // Input\n * var utils = {\n *   isString: x=>typeof x === \"string\",\n *   isBoolean: x=>typeof x === \"boolean\"\n * }\n * if ( utils.isString(\"Hello\") ) {\n *   ...\n * }\n *\n * // Output\n * var utils_isString = x=>typeof x === \"string\";\n * var utils_isBoolean = x=>typeof x === \"boolean\"\n *\n * if ( utils_isString(\"Hello\") ) {\n *   ...\n * }\n * ```\n */\nexport default class ObjectExtraction extends Transform {\n  constructor(o) {\n    super(o, ObfuscateOrder.ObjectExtraction);\n  }\n\n  match(object: Node, parents: Node[]) {\n    return isContext(object);\n  }\n\n  transform(context: Node, contextParents: Node[]) {\n    // ObjectExpression Extractor\n\n    return () => {\n      // First pass through to find the maps\n      var objectDefs: { [name: string]: Location } = {};\n\n      walk(context, contextParents, (object: Node, parents: Node[]) => {\n        if (getContext(object, parents) != context) {\n          return;\n        }\n        if (object.type == \"ObjectExpression\") {\n          // this.log(object, parents);\n          if (\n            parents[0].type == \"VariableDeclarator\" &&\n            parents[0].init == object &&\n            parents[0].id.type == \"Identifier\"\n          ) {\n            var name = parents[0].id.name;\n            if (name) {\n              // check for computed properties\n\n              object.properties.forEach((prop) => {\n                if (prop.computed && prop.key.type == \"Literal\") {\n                  prop.computed = false;\n                }\n              });\n\n              var computed = object.properties.find((x) => x.computed);\n              if (computed) {\n                this.log(\n                  name + \" has computed property: \" + computed.key.name ||\n                    computed.key.value\n                );\n              } else {\n                var illegalName = object.properties\n                  .map((x) => x.key.name || x.key.value)\n                  .find((x) => !isValidIdentifier(x));\n\n                if (illegalName) {\n                  this.log(\n                    name + \" has an illegal property '\" + illegalName + \"'\"\n                  );\n                } else {\n                  objectDefs[name] = [object, parents];\n                }\n              }\n            }\n          }\n        }\n      });\n\n      // this.log(\"object defs\", objectDefs);\n      // huge map of changes\n      var objectDefChanges: {\n        [name: string]: { key: string; object: Node; parents: Node[] }[];\n      } = {};\n\n      if (Object.keys(objectDefs).length) {\n        // A second pass through is only required when extracting object keys\n\n        // Second pass through the exclude the dynamic map (counting keys, re-assigning)\n        walk(context, contextParents, (object: any, parents: Node[]) => {\n          if (getContext(object, parents) != context) {\n            return;\n          }\n          if (\n            object.type == \"Identifier\" &&\n            parents[0].type != \"VariableDeclarator\"\n          ) {\n            var info = getIdentifierInfo(object, parents);\n            if (!info.spec.isReferenced) {\n              return;\n            }\n            if (objectDefs[object.name]) {\n              var def = objectDefs[object.name];\n              var isMemberExpression =\n                parents[0].type == \"MemberExpression\" &&\n                parents[0].object == object;\n\n              var isIllegal = false;\n              if (\n                parents.some((x) => x.type == \"AssignmentExpression\") &&\n                !isMemberExpression\n              ) {\n                this.log(object.name, \"you can't re-assign the object\");\n\n                isIllegal = true;\n              } else if (isMemberExpression) {\n                var key = parents[0].property.value || parents[0].property.name;\n                if (\n                  ![\"Literal\", \"Identifier\"].includes(parents[0].property.type)\n                ) {\n                  // only allow literal and identifier accessors\n                  // Literal: obj[\"key\"]\n                  // Identifier: obj.key\n                  this.log(\n                    object.name,\n                    \"Only allowed literal and identifier accessors\"\n                  );\n                  isIllegal = true;\n                } else if (\n                  parents[0].property.type == \"Identifier\" &&\n                  parents[0].computed\n                ) {\n                  // no: object[key], only: object.key\n                  this.log(object.name, \"no: object[key], only: object.key\");\n\n                  isIllegal = true;\n                } else if (\n                  !def[0].properties.some(\n                    (x) => (x.key.value || x.key.name) == key\n                  )\n                ) {\n                  // check if initialized property\n                  // not in initialized object.\n                  this.log(\n                    object.name,\n                    \"not in initialized object.\",\n                    def[0].properties,\n                    key\n                  );\n                  isIllegal = true;\n                } else {\n                  // allowed.\n                  // start the array if first time\n                  if (!objectDefChanges[object.name]) {\n                    objectDefChanges[object.name] = [];\n                  }\n                  if (\n                    !objectDefChanges[object.name].some(\n                      (x) => x.object == object\n                    )\n                  ) {\n                    // add to array\n                    objectDefChanges[object.name].push({\n                      key: key,\n                      object: object,\n                      parents: parents,\n                    });\n                  }\n                }\n              } else {\n                this.log(\n                  object.name,\n                  \"you must access a property on the when referring to the identifier (accessors must be hard-coded literals)\"\n                );\n\n                isIllegal = true;\n              }\n\n              if (isIllegal) {\n                // this is illegal, delete it from being moved and delete accessor changes from happening\n                this.log(object.name + \" is illegal\");\n                delete objectDefs[object.name];\n                delete objectDefChanges[object.name];\n              }\n            }\n          }\n        });\n\n        var newVariableDeclarations: {\n          name: string;\n          map: string;\n          object: Node;\n          parents: Node[];\n        }[] = [];\n        Object.keys(objectDefs).forEach((name) => {\n          if (\n            !ComputeProbabilityMap(\n              this.options.objectExtraction,\n              (x) => x,\n              name\n            )\n          ) {\n            //continue;\n            return;\n          }\n\n          var [object, parents] = objectDefs[name];\n\n          var properties = object.properties;\n          // change the prop names while extracting\n          var newPropNames: { [key: string]: string } = {};\n          properties.forEach((property: Node) => {\n            var keyName = property.key.name || property.key.value;\n\n            var nn = name + \"_\" + keyName;\n            newPropNames[keyName] = nn + this.getPlaceholder();\n\n            newVariableDeclarations.push({\n              name: nn,\n              object: this.addComment(property.value, `${name}.${keyName}`),\n              parents: parents,\n              map: name,\n            });\n          });\n\n          // delete the original object declaration\n          // deleteDirect(object, parents[0]);\n          deleteDeclaration(object, parents);\n\n          // The array can be uninitialized (no accessors, this object has no purpose)\n          objectDefChanges[name] &&\n            objectDefChanges[name].forEach((change) => {\n              if (!change.key) {\n                throw new Error(\"key undefined\");\n              }\n              if (newPropNames[change.key]) {\n                var memberExpression = change.parents[0];\n                if (memberExpression.type == \"MemberExpression\") {\n                  this.replace(\n                    memberExpression,\n                    this.addComment(\n                      Identifier(newPropNames[change.key]),\n                      `Original Accessor: ${name}.${change.key}`\n                    )\n                  );\n                } else {\n                  // Provide error with more information:\n                  console.log(memberExpression);\n                  this.error(\n                    new Error(\n                      `should be MemberExpression, found type=${memberExpression.type}`\n                    )\n                  );\n                }\n              } else {\n                console.log(objectDefChanges[name], newPropNames);\n                this.error(\n                  new Error(\n                    `\"${change.key}\" not found in [${Object.keys(\n                      newPropNames\n                    ).join(\", \")}] while flattening ${name}.`\n                  )\n                );\n              }\n            });\n\n          this.log(\n            `Extracted ${\n              Object.keys(newPropNames).length\n            } properties from ${name}, affecting ${\n              Object.keys(objectDefChanges[name] || {}).length\n            } line(s) of code.`\n          );\n        });\n        // put the new ones in\n        newVariableDeclarations.forEach((x) => {\n          var declaration: Node = VariableDeclaration(\n            VariableDeclarator(x.name, x.object)\n          );\n          if (x.object.type == \"FunctionExpression\") {\n            // Use FunctionDeclaration for functions\n            declaration = {\n              ...x.object,\n              type: \"FunctionDeclaration\",\n              id: Identifier(x.name),\n            };\n          }\n\n          prepend(context, declaration);\n        });\n      }\n    };\n  }\n}\n","import { Node } from \"../util/gen\";\nimport { parseSnippet, parseSync } from \"../parser\";\n\n\n\nexport interface ITemplate {\n\n  fill(variables?: {[name: string]: string|number}): string;\n\n  compile(variables?: {[name: string]: string|number}): Node[];\n\n  single(variables?: {[name: string]: string|number}): Node;\n}\n\nexport default function Template(template: string): ITemplate {\n\n  var neededVariables = 0;\n  while ( template.includes(`{$${neededVariables+1}}`) ) {\n    neededVariables++;\n  }\n  var vars = Object.create(null);\n  new Array(neededVariables+1).fill(0).forEach((x,i)=>{\n    vars[\"\\\\$\" + i] = \"temp_\" + i;\n  });\n\n  function fill(variables?: {[name: string]: string|number}): string {\n\n    if ( !variables ) {\n      variables = Object.create(null);\n    }\n\n    var cloned = template;\n\n    var keys = {...variables, ...vars};\n\n    Object.keys(keys).forEach(name=>{\n\n      var bracketName = \"{\" + name + \"}\";\n      var value = keys[name] + \"\";\n\n      var reg = new RegExp(bracketName, \"g\");\n\n      cloned = cloned.replace(reg, value);\n    });\n\n    return cloned;\n  };\n\n  function compile(variables: {[name: string]: string|number}): Node[] {\n\n    var code = fill(variables);\n    try {\n      var program = parseSnippet(code);\n\n      return program.body;\n    } catch ( e ) {\n      console.error(e);\n      console.error(template);\n      throw new Error(\"Template failed to parse\");\n    }\n  }\n\n  function single(variables?: {[name: string]: string|number}): Node {\n    var nodes = compile(variables);\n    return nodes[0];\n  }\n\n  var obj: ITemplate = {\n    fill,\n    compile,\n    single\n  }\n\n  return obj;\n\n};","import Template from \"./template\";\n\n\n\nexport const CrashTemplate1 = Template(`\nMath.random() > 0.5 && process && process.exit();\nvar {var} = \"a\";\nwhile(1){\n    {var} = {var} += \"a\";    //add as much as the browser can handle\n}\n`);\n\nexport const CrashTemplate2 = Template(`\nwhile(true) {\n    for(var {var} = 99; {var} == {var}; {var} *= {var}) {\n        !{var} && console.log({var});\n        if ({var} <= 10){\n            break;\n        }\n    };\n };`);\n\nexport const CrashTemplate3 = Template(`\nfunction {$2}(y, x){\n  return x;\n}\n\nvar {$1} = {$2}(this, function () {\n  var {$3} = function () {\n      var regExp = {$3}\n          .constructor('return /\" + this + \"/')()\n          .constructor('^([^ ]+( +[^ ]+)+)+[^ ]}');\n      \n      return !regExp.call({$1});\n  };\n  \n  return {$3}();\n});\n\n{$1}();`);","import Transform from \"../transform\";\nimport Template from \"../../templates/template\";\nimport {\n  FunctionDeclaration,\n  VariableDeclaration,\n  IfStatement,\n  Identifier,\n  BinaryExpression,\n  Literal,\n  ReturnStatement,\n  CallExpression,\n  MemberExpression,\n  BlockStatement,\n  ThisExpression,\n  LogicalExpression,\n  ExpressionStatement,\n  Node,\n  FunctionExpression,\n  AssignmentExpression,\n  ConditionalExpression,\n  UnaryExpression,\n  VariableDeclarator,\n} from \"../../util/gen\";\nimport {\n  clone,\n  getBlockBody,\n  getBlockName,\n  isFunction,\n  prepend,\n} from \"../../util/insert\";\nimport { getRandomInteger } from \"../../util/random\";\nimport Lock from \"./lock\";\nimport { ok } from \"assert\";\n\n/**\n * Hashing Algorithm for function integrity\n * @param str\n * @param seed\n */\nfunction cyrb53(str, seed = 0) {\n  let h1 = 0xdeadbeef ^ seed,\n    h2 = 0x41c6ce57 ^ seed;\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 2654435761);\n    h2 = Math.imul(h2 ^ ch, 1597334677);\n  }\n  h1 =\n    Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^\n    Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n  h2 =\n    Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^\n    Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n}\n\n// In template form to be inserted into code\nconst HashTemplate = Template(`\nfunction {name}(str, seed) {\n  var h1 = 0xdeadbeef ^ seed;\n  var h2 = 0x41c6ce57 ^ seed;\n  for (var i = 0, ch; i < str.length; i++) {\n      ch = str.charCodeAt(i);\n      h1 = {imul}(h1 ^ ch, 2654435761);\n      h2 = {imul}(h2 ^ ch, 1597334677);\n  }\n  h1 = {imul}(h1 ^ (h1>>>16), 2246822507) ^ {imul}(h2 ^ (h2>>>13), 3266489909);\n  h2 = {imul}(h2 ^ (h2>>>16), 2246822507) ^ {imul}(h1 ^ (h1>>>13), 3266489909);\n  return 4294967296 * (2097151 & h2) + (h1>>>0);\n};`);\n\n// Math.imul polyfill for ES5\nconst ImulTemplate = Template(`\nvar {name} = Math.imul || function(opA, opB){\n  opB |= 0; // ensure that opB is an integer. opA will automatically be coerced.\n  // floating points give us 53 bits of precision to work with plus 1 sign bit\n  // automatically handled for our convienence:\n  // 1. 0x003fffff /*opA & 0x000fffff*/ * 0x7fffffff /*opB*/ = 0x1fffff7fc00001\n  //    0x1fffff7fc00001 < Number.MAX_SAFE_INTEGER /*0x1fffffffffffff*/\n  var result = (opA & 0x003fffff) * opB;\n  // 2. We can remove an integer coersion from the statement above because:\n  //    0x1fffff7fc00001 + 0xffc00000 = 0x1fffffff800001\n  //    0x1fffffff800001 < Number.MAX_SAFE_INTEGER /*0x1fffffffffffff*/\n  if (opA & 0xffc00000 /*!== 0*/) result += (opA & 0xffc00000) * opB |0;\n  return result |0;\n};`);\n\n// Simple function that returns .toString() value with spaces replaced out\nconst StringTemplate = Template(`\n  function {name}(x){\n    return x.toString().replace(/ |\\\\n|;|,|\\\\{|\\\\}|\\\\(|\\\\)/g, \"\");\n  }\n`);\n\n/**\n * Integrity protects functions by using checksum techniques to verify their code has not changed.\n *\n * If an attacker modifies a function, the modified function will not execute.\n *\n * How it works:\n *\n * - By using `.toString()` JavaScript will expose a function's source code.\n * - We can hash it and use an if statement in the code to ensure the function's code is unchanged.\n *\n * This is the most complicated Transformation for JSConfuser so here I'll explain:\n * - The Program is wrapped in an IIFE (Function Expression that is called instantly)\n * - Every function including ^ are generated out and evaluated for their .toString() value\n * - Hashed using cyrb53's hashing algorithm\n * - Check the checksum before running the code.\n *\n * - The hashing function is placed during this transformation,\n * - A hidden identifier is placed to keep track of the name.\n *\n *\n *\n */\nexport default class Integrity extends Transform {\n  hashFn: Node;\n  imulFn: Node;\n  stringFn: Node;\n  seed: number;\n  lock: Lock;\n\n  constructor(o, lock) {\n    super(o);\n    this.lock = lock;\n\n    this.seed = getRandomInteger(0, 1000);\n  }\n\n  match(object: Node, parents: Node[]) {\n    // ArrowFunctions are excluded!\n    return object.type == \"Program\" || isFunction(object);\n  }\n\n  transform(object: Node, parents: Node[]) {\n    if (object.type == \"Program\") {\n      return () => {\n        var hashingUtils: Node[] = [];\n\n        var imulName = this.getPlaceholder();\n        var imulVariableDeclaration = ImulTemplate.single({ name: imulName });\n        this.imulFn = imulVariableDeclaration._hiddenId = Identifier(imulName);\n        hashingUtils.push(imulVariableDeclaration);\n\n        var hashName = this.getPlaceholder();\n        var hashFunctionDeclaration = HashTemplate.single({\n          name: hashName,\n          imul: imulName,\n        });\n        this.hashFn = hashFunctionDeclaration._hiddenId = Identifier(hashName);\n        hashingUtils.push(hashFunctionDeclaration);\n\n        var stringName = this.getPlaceholder();\n        var stringFunctionDeclaration = StringTemplate.single({\n          name: stringName,\n        });\n        this.stringFn = stringFunctionDeclaration._hiddenId =\n          Identifier(stringName);\n        hashingUtils.push(stringFunctionDeclaration);\n\n        var functionExpression = FunctionExpression([], [...object.body]);\n\n        object.body = [CallExpression(functionExpression, [])];\n\n        object._hiddenHashingUtils = hashingUtils;\n\n        var ok = this.transform(functionExpression, [\n          object.body[0],\n          object.body,\n          object,\n        ]);\n        if (ok) {\n          ok();\n        }\n\n        object.$eval = () => {\n          functionExpression.body.body.unshift(...hashingUtils);\n        };\n      };\n    }\n    ok(isFunction(object));\n    if (object.generator || object.async) {\n      return;\n    }\n\n    return () => {\n      object.$eval = () => {\n        var functionName = this.generateIdentifier();\n        var hashName = this.generateIdentifier();\n\n        var functionDeclaration = {\n          ...clone(object),\n          type: \"FunctionDeclaration\",\n          id: Identifier(functionName),\n          params: object.params || [],\n          body: object.body || BlockStatement([]),\n          expression: false,\n          $dispatcherSkip: true,\n        };\n\n        var toString;\n        try {\n          toString = this.getToStringValue(\n            functionDeclaration,\n            (x) => \"(\" + x + \")\"\n          );\n        } catch (e) {\n          console.error(e);\n          return;\n        }\n\n        if (!toString) {\n          return;\n        }\n\n        var minified = toString.replace(/ |\\n|;|,|\\{|\\}|\\(|\\)/g, \"\");\n        var hash = cyrb53(minified, this.seed);\n\n        console.log(\n          (object.id ? object.id.name : \"function\") + \" -> \" + hash,\n          minified\n        );\n\n        object.body = BlockStatement([\n          functionDeclaration,\n          VariableDeclaration(\n            VariableDeclarator(\n              hashName,\n              CallExpression(clone(this.hashFn), [\n                CallExpression(clone(this.stringFn), [\n                  Identifier(functionName),\n                ]),\n                Literal(this.seed),\n              ])\n            )\n          ),\n          IfStatement(\n            BinaryExpression(\"==\", Identifier(hashName), Literal(hash)),\n            [\n              Template(`return {functionName}.apply(this, arguments)`).single({\n                functionName: functionName,\n              }),\n            ]\n          ),\n        ]);\n\n        if (object.type == \"ArrowFunctionExpression\") {\n          object.type = \"FunctionExpression\";\n          object.expression = false;\n        }\n      };\n    };\n  }\n}\n","import { ObfuscateOrder } from \"../../obfuscator\";\r\nimport Template from \"../../templates/template\";\r\nimport { isBlock } from \"../../traverse\";\r\nimport { DebuggerStatement } from \"../../util/gen\";\r\nimport { getBlockBody, prepend } from \"../../util/insert\";\r\nimport { getRandomInteger } from \"../../util/random\";\r\nimport Transform from \"../transform\";\r\n\r\nvar DevToolsDetection = Template(\r\n  `\r\n  function $jsc_debug(){\r\n    var startTime = new Date();\r\n    debugger;\r\n    var endTime = new Date();\r\n    var isDev = endTime-startTime > 400;\r\n  \r\n    while (isDev) {\r\n      debugger;\r\n      (function () {}). constructor (\"debugger\") ()\r\n    }\r\n  \r\n  }\r\n  if ( this.setInterval ) {\r\n    this.setInterval(()=>{\r\n      $jsc_debug();\r\n    }, 10000);\r\n  }\r\n`\r\n);\r\n\r\nexport default class AntiDebug extends Transform {\r\n  constructor(o) {\r\n    super(o, ObfuscateOrder.Lock);\r\n  }\r\n\r\n  apply(tree) {\r\n    super.apply(tree);\r\n\r\n    tree.body.unshift(...DevToolsDetection.compile());\r\n  }\r\n\r\n  match(object, parents) {\r\n    return isBlock(object);\r\n  }\r\n\r\n  transform(object, parents) {\r\n    var body = getBlockBody(object.body);\r\n\r\n    [...body].forEach((stmt) => {\r\n      if (Math.random() > 0.5) {\r\n        var index = getRandomInteger(0, body.length);\r\n        if (body[index].type != \"DebuggerStatement\") {\r\n          body.splice(index, 0, DebuggerStatement());\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\n","import Transform from \"../transform\";\nimport {\n  Node,\n  IfStatement,\n  ExpressionStatement,\n  AssignmentExpression,\n  Identifier,\n  BinaryExpression,\n  CallExpression,\n  MemberExpression,\n  Literal,\n  UnaryExpression,\n  NewExpression,\n  FunctionDeclaration,\n  ReturnStatement,\n  VariableDeclaration,\n  ObjectExpression,\n  Property,\n  ArrayExpression,\n  FunctionExpression,\n  ThisExpression,\n  SequenceExpression,\n  VariableDeclarator,\n} from \"../../util/gen\";\nimport { getBlock, isBlock, walk } from \"../../traverse\";\nimport { ok } from \"assert\";\nimport { choice, getRandomInteger, shuffle } from \"../../util/random\";\nimport {\n  CrashTemplate1,\n  CrashTemplate2,\n  CrashTemplate3,\n} from \"../../templates/crash\";\nimport { getBlockBody, prepend } from \"../../util/insert\";\nimport Template from \"../../templates/template\";\nimport { ObfuscateOrder } from \"../../obfuscator\";\nimport Integrity from \"./integrity\";\nimport { isLoop } from \"../preparation/preparation\";\nimport AntiDebug from \"./antiDebug\";\n\n/**\n * Strings are formulated to work only during the allowed time\n */\nclass LockStrings extends Transform {\n  strings: { [key: string]: string };\n  gen: any;\n  fnName: string;\n  objectExpression: Node;\n  shift: number;\n\n  constructor(o) {\n    super(o);\n\n    this.strings = Object.create(null);\n    this.gen = this.getGenerator();\n\n    this.fnName = null;\n    this.objectExpression = null;\n\n    this.shift = getRandomInteger(1, 5);\n  }\n\n  match(object) {\n    return (\n      object.type == \"Program\" ||\n      (object.type == \"Literal\" && typeof object.value === \"string\")\n    );\n  }\n\n  getKey() {\n    function ensureNumber(y: Date | number) {\n      if (y instanceof Date) {\n        return y.getTime();\n      }\n\n      // @ts-ignore\n      return parseInt(y);\n    }\n\n    var start = ensureNumber(this.options.lock.startDate);\n    var end = ensureNumber(this.options.lock.endDate);\n\n    var diff = end - start;\n\n    var now = Date.now();\n\n    return {\n      key: Math.floor(now / diff),\n      diff: diff,\n    };\n  }\n\n  transform(object: Node, parents: Node[]) {\n    if (!this.fnName) {\n      this.fnName = this.getPlaceholder();\n\n      this.objectExpression = ObjectExpression([]);\n    }\n\n    if (object.type == \"Program\") {\n      var keyArg = this.getPlaceholder();\n      var mapName = this.getPlaceholder();\n\n      return () => {\n        if (this.objectExpression.properties.length) {\n          var keyVar = this.getPlaceholder();\n\n          var { diff } = this.getKey();\n          prepend(\n            object,\n            VariableDeclaration([\n              VariableDeclarator(\n                Identifier(keyVar),\n                Template(`Math.floor(Date.now()/${diff})`).single().expression\n              ),\n            ])\n          );\n\n          var currentVar = this.getPlaceholder();\n          var outputVar = this.getPlaceholder();\n          var xVar = this.getPlaceholder();\n\n          prepend(\n            object,\n            FunctionDeclaration(\n              this.fnName,\n              [Identifier(keyArg)],\n              [\n                VariableDeclaration(\n                  VariableDeclarator(mapName, this.objectExpression)\n                ),\n                VariableDeclaration(\n                  VariableDeclarator(\n                    currentVar,\n                    MemberExpression(\n                      Identifier(mapName),\n                      Identifier(keyArg),\n                      true\n                    )\n                  )\n                ),\n                VariableDeclaration(VariableDeclarator(outputVar, Literal(\"\"))),\n                ExpressionStatement(\n                  CallExpression(\n                    MemberExpression(\n                      Identifier(currentVar),\n                      Identifier(\"forEach\"),\n                      false\n                    ),\n                    [\n                      FunctionExpression(\n                        [Identifier(xVar)],\n                        [\n                          ExpressionStatement(\n                            AssignmentExpression(\n                              \"+=\",\n                              Identifier(outputVar),\n                              CallExpression(\n                                MemberExpression(\n                                  Identifier(\"String\"),\n                                  Identifier(\"fromCharCode\"),\n                                  false\n                                ),\n                                [\n                                  BinaryExpression(\n                                    \"^\",\n                                    BinaryExpression(\n                                      \">>\",\n                                      Identifier(xVar),\n                                      Literal(this.shift)\n                                    ),\n                                    Identifier(keyVar)\n                                  ),\n                                ]\n                              )\n                            )\n                          ),\n                        ]\n                      ),\n                    ]\n                  )\n                ),\n                ReturnStatement(Identifier(outputVar)),\n              ]\n            )\n          );\n        }\n      };\n    }\n\n    if (!object.value) {\n      return;\n    }\n\n    if (\n      parents.find(\n        (x) => x.type == \"CallExpression\" && x.callee.name == this.fnName\n      )\n    ) {\n      return;\n    }\n\n    var key = this.strings[object.value];\n\n    if (!key) {\n      // New string found!\n      key = this.gen.generate();\n      this.strings[key] = object.value;\n\n      var xorKey = this.getKey().key;\n\n      var array = ArrayExpression(\n        object.value\n          .split(\"\")\n          .map((x) => x.charCodeAt(0))\n          .map((x) => x ^ xorKey)\n          .map((x) => x << this.shift)\n          .map((x) => Literal(x))\n      );\n\n      this.objectExpression.properties.push(\n        Property(Identifier(key), array, false)\n      );\n    }\n\n    if (parents[0].type == \"Property\") {\n      parents[0].computed = true;\n    }\n\n    this.objectAssign(\n      object,\n      CallExpression(Identifier(this.fnName), [Literal(key)])\n    );\n  }\n}\n\n/**\n * Applies browser & date locks.\n */\nexport default class Lock extends Transform {\n  globalVar: string;\n\n  constructor(o) {\n    super(o, ObfuscateOrder.Lock);\n\n    if (this.options.lock.startDate && this.options.lock.endDate) {\n      this.before.push(new LockStrings(o));\n    }\n\n    if (this.options.lock.integrity) {\n      this.before.push(new Integrity(o, this));\n    }\n\n    if (this.options.lock.antiDebug) {\n      this.before.push(new AntiDebug(o));\n    }\n  }\n\n  getCounterMeasuresCode(): Node[] {\n    var opt = this.options.lock.countermeasures;\n\n    if (!opt) {\n      return null;\n    }\n\n    // Call function\n    if (typeof opt === \"string\") {\n      // Since Lock occurs before variable renaming, we are using the pre-obfuscated function name\n      return [CallExpression(Identifier(opt), [])];\n    }\n\n    var type = choice([\"crash\", \"exit\", \"stutter\"]);\n\n    switch (type) {\n      case \"crash\":\n        var varName = this.getPlaceholder();\n        return choice([CrashTemplate1, CrashTemplate2, CrashTemplate3]).compile(\n          {\n            var: varName,\n          }\n        );\n\n      case \"exit\":\n        if (this.options.target == \"browser\") {\n          return Template(\"document.documentElement.innerHTML = '';\").compile();\n        }\n\n        return Template(\"process.exit()\").compile();\n\n      case \"stutter\":\n        return Template(\n          \"for ( var i=0; i < 1000; i++ ) { var x = Math.cos(i) }\"\n        ).compile();\n\n      case \"sideeffect\": // A Side effect involves disrupting the programs flow\n        return;\n    }\n  }\n\n  /**\n   * Converts Dates to numbers, then applies some randomness\n   * @param object\n   */\n  getTime(object: Date | number): number {\n    if (object instanceof Date) {\n      return this.getTime(object.getTime());\n    }\n\n    return object + getRandomInteger(-4000, 4000);\n  }\n\n  match(object: Node, parents: Node[]) {\n    return isBlock(object);\n  }\n\n  transform(object: Node, parents: Node[]) {\n    if (parents.find((x) => isLoop(x) && x.type != \"SwitchStatement\")) {\n      return;\n    }\n\n    var block = getBlock(object, parents);\n\n    var choices = [];\n    if (this.options.lock.startDate) {\n      choices.push(\"startDate\");\n    }\n    if (this.options.lock.endDate) {\n      choices.push(\"endDate\");\n    }\n    if (this.options.lock.domainLock && this.options.lock.domainLock.length) {\n      choices.push(\"domainLock\");\n    }\n    if (this.options.lock.nativeFunctions) {\n      choices.push(\"nativeFunction\");\n    }\n    if (this.options.lock.context) {\n      choices.push(\"context\");\n    }\n    if (!choices.length) {\n      return;\n    }\n\n    return () => {\n      var type = choice(choices);\n      var nodes = [];\n\n      var dateNow: Node = CallExpression(\n        MemberExpression(Identifier(\"Date\"), Literal(\"now\"), true),\n        []\n      );\n      if (Math.random() > 0.5) {\n        dateNow = CallExpression(\n          MemberExpression(\n            NewExpression(Identifier(\"Date\"), []),\n            Literal(\"getTime\")\n          ),\n          []\n        );\n      }\n      if (Math.random() > 0.5) {\n        dateNow = CallExpression(\n          MemberExpression(\n            MemberExpression(\n              MemberExpression(Identifier(\"Date\"), Literal(\"prototype\"), true),\n              Literal(\"getTime\"),\n              true\n            ),\n            Literal(\"call\"),\n            true\n          ),\n          [NewExpression(Identifier(\"Date\"), [])]\n        );\n      }\n\n      var test;\n\n      switch (type) {\n        case \"nativeFunction\":\n          var set = this.options.lock.nativeFunctions;\n          if (set == true) {\n            set = new Set([\"require\"]);\n          }\n          var fn = choice(Array.from(set));\n\n          test = Template(`(${fn}+\"\").indexOf(\"[native code]\") == -1`).single();\n\n          if (Math.random() > 0.5) {\n            test = Template(\n              `${fn}.toString().split(\"{ [native code] }\").length <= 1`\n            ).single();\n          }\n\n          nodes.push(\n            IfStatement(test, this.getCounterMeasuresCode() || [], null)\n          );\n\n          break;\n\n        case \"startDate\":\n          test = BinaryExpression(\n            \"<\",\n            dateNow,\n            Literal(this.getTime(this.options.lock.startDate))\n          );\n\n          nodes.push(\n            IfStatement(test, this.getCounterMeasuresCode() || [], null)\n          );\n\n          break;\n\n        case \"endDate\":\n          test = BinaryExpression(\n            \">\",\n            dateNow,\n            Literal(this.getTime(this.options.lock.endDate))\n          );\n\n          nodes.push(\n            IfStatement(test, this.getCounterMeasuresCode() || [], null)\n          );\n\n          break;\n\n        case \"context\":\n          var prop = choice(this.options.lock.context);\n\n          // Todo: Alternative to `this`\n          if (!this.globalVar) {\n            this.globalVar = this.getPlaceholder();\n            prepend(\n              parents[parents.length - 1] || block,\n              VariableDeclaration(\n                VariableDeclarator(this.globalVar, ThisExpression())\n              )\n            );\n          }\n\n          test = UnaryExpression(\n            \"!\",\n            MemberExpression(Identifier(this.globalVar), Literal(prop), true)\n          );\n          nodes.push(\n            IfStatement(test, this.getCounterMeasuresCode() || [], null)\n          );\n\n          break;\n\n        case \"domainLock\":\n          function removeSlashes(path: string) {\n            var count = path.length - 1;\n            var index = 0;\n\n            while (path.charCodeAt(index) === 47 && ++index);\n            while (path.charCodeAt(count) === 47 && --count);\n\n            return path.slice(index, count + 1);\n          }\n\n          var locationHref = MemberExpression(\n            Identifier(\"location\"),\n            Literal(\"href\"),\n            true\n          );\n\n          var random = choice(this.options.lock.domainLock);\n\n          test = CallExpression(\n            MemberExpression(locationHref, Literal(\"match\"), true),\n            [\n              {\n                type: \"Literal\",\n                regex: {\n                  pattern:\n                    random instanceof RegExp\n                      ? random.source\n                      : removeSlashes(random),\n                  flags: random instanceof RegExp ? \"\" : \"\",\n                },\n              },\n            ]\n          );\n\n          test = UnaryExpression(\"!\", test);\n          if (Math.random() > 0.5) {\n            test = BinaryExpression(\n              \"||\",\n              BinaryExpression(\n                \"==\",\n                UnaryExpression(\"typeof\", Identifier(\"location\")),\n                Literal(\"undefined\")\n              ),\n              test\n            );\n          }\n          nodes.push(\n            IfStatement(test, this.getCounterMeasuresCode() || [], null)\n          );\n          break;\n      }\n\n      var body = getBlockBody(block);\n      var randomIndex = getRandomInteger(0, body.length);\n\n      body.splice(randomIndex, 0, ...nodes);\n    };\n  }\n}\n","import { ComputeProbabilityMap } from \"../index\";\r\nimport { getDepth, getBlock, getBlocks, isBlock, walk } from \"../traverse\";\r\nimport {\r\n  ArrayExpression,\r\n  AssignmentExpression,\r\n  BinaryExpression,\r\n  CallExpression,\r\n  ExpressionStatement,\r\n  FunctionDeclaration,\r\n  FunctionExpression,\r\n  Identifier,\r\n  IfStatement,\r\n  Literal,\r\n  Node,\r\n  Location,\r\n  MemberExpression,\r\n  ObjectExpression,\r\n  Property,\r\n  ReturnStatement,\r\n  VariableDeclaration,\r\n  SequenceExpression,\r\n  NewExpression,\r\n  UnaryExpression,\r\n  BlockStatement,\r\n  LogicalExpression,\r\n  ThisExpression,\r\n  VariableDeclarator,\r\n} from \"../util/gen\";\r\nimport { getIdentifierInfo, isWithinClass } from \"../util/identifiers\";\r\nimport {\r\n  deleteDirect,\r\n  getBlockBody,\r\n  getContext,\r\n  getFunction,\r\n  isContext,\r\n  isFunction,\r\n  prepend,\r\n} from \"../util/insert\";\r\nimport Transform, { reservedIdentifiers } from \"./transform\";\r\nimport { isInsideType } from \"../util/compare\";\r\nimport { ObfuscateOrder } from \"../obfuscator\";\r\nimport { choice, shuffle } from \"../util/random\";\r\n\r\n/**\r\n * A Dispatcher processes function calls. All the function declarations are brought into a dictionary.\r\n *\r\n * We can use an argument payload to further decipher the trace.\r\n *\r\n * ```js\r\n * var param1;\r\n * function dispatcher(key){\r\n *     var fns = {\r\n *         'fn1': function(){\r\n *             var [arg1] = [param1];\r\n *             console.log(arg1);\r\n *         }\r\n *     }\r\n *     return fns[key]();\r\n * };\r\n * param1 = \"Hello World\";\r\n * dispatcher('fn1'); // > \"Hello World\"\r\n * ```\r\n *\r\n * Can break code with:\r\n *\r\n * 1. testing function equality,\r\n * 2. using arguments.callee,\r\n * 3. using this\r\n */\r\nexport default class Dispatcher extends Transform {\r\n  count: number;\r\n\r\n  constructor(o) {\r\n    super(o, ObfuscateOrder.Dispatcher);\r\n\r\n    this.count = 0;\r\n  }\r\n\r\n  match(object: Node, parents: Node[]) {\r\n    if (isInsideType(\"AwaitExpression\", object, parents)) {\r\n      return false;\r\n    }\r\n\r\n    return isContext(object) && !object.$dispatcherSkip;\r\n  }\r\n\r\n  transform(object: Node, parents: Node[]) {\r\n    return () => {\r\n      if (ComputeProbabilityMap(this.options.dispatcher, (mode) => mode)) {\r\n        if (object.type != \"Program\" && object.body.type != \"BlockStatement\") {\r\n          return;\r\n        }\r\n\r\n        var body = getBlockBody(object.body);\r\n\r\n        // Controls how many arg variables to make\r\n        var maxArgs = 0;\r\n\r\n        // Map of FunctionDeclarations\r\n        var functionDeclarations: { [name: string]: Location } = {};\r\n\r\n        // Array of Identifier nodes\r\n        var identifiers: Location[] = [];\r\n        var illegalFnNames: Set<string> = new Set();\r\n\r\n        // New Names for Functions\r\n        var newFnNames: { [name: string]: string } = {}; // [old name]: randomized name\r\n\r\n        var context = getContext(object, parents);\r\n\r\n        walk(object, parents, (o: Node, p: Node[]) => {\r\n          if (object == o) {\r\n            // Fix 1\r\n            return;\r\n          }\r\n          if (isWithinClass(o, p)) {\r\n            return;\r\n          }\r\n\r\n          var c = getContext(o, p);\r\n\r\n          if (context === c) {\r\n            if (o.type == \"FunctionDeclaration\") {\r\n              if (o.body.type != \"BlockStatement\") {\r\n                illegalFnNames.add(name);\r\n              }\r\n\r\n              var name = o.id.name;\r\n\r\n              // If dupe, no routing\r\n              if (functionDeclarations[name] || o.$integritySkip) {\r\n                illegalFnNames.add(name);\r\n                return;\r\n              }\r\n\r\n              walk(o, p, (oo, pp) => {\r\n                if (oo.type == \"Identifier\" && oo.name == \"arguments\") {\r\n                  illegalFnNames.add(name);\r\n                } else if (oo.type == \"ThisExpression\") {\r\n                  illegalFnNames.add(name);\r\n                }\r\n              });\r\n\r\n              functionDeclarations[name] = [o, p];\r\n            }\r\n          }\r\n\r\n          if (o.type == \"Identifier\") {\r\n            if (reservedIdentifiers.has(o.name)) {\r\n              return;\r\n            }\r\n            var info = getIdentifierInfo(o, p);\r\n            if (info.spec.isModified) {\r\n              illegalFnNames.add(o.name);\r\n            } else if (info.spec.isReferenced) {\r\n              identifiers.push([o, p]);\r\n            }\r\n          }\r\n        });\r\n\r\n        illegalFnNames.forEach((name) => {\r\n          delete functionDeclarations[name];\r\n        });\r\n\r\n        Object.keys(functionDeclarations).forEach((x) => {\r\n          maxArgs = Math.max(functionDeclarations[x][0].params.length, maxArgs);\r\n        });\r\n\r\n        // map original name->new game\r\n        var gen = this.getGenerator();\r\n        Object.keys(functionDeclarations).forEach((name) => {\r\n          newFnNames[name] = gen.generate();\r\n        });\r\n        // set containing new name\r\n        var set = new Set(Object.keys(newFnNames));\r\n\r\n        // Only make a dispatcher function if it caught any functions\r\n        if (set.size > 0) {\r\n          var varArgs = Array(maxArgs)\r\n            .fill(0)\r\n            .map((x, i) => `$jsc_d${this.count}_${i}`);\r\n          var dispatcherFnName =\r\n            this.getPlaceholder() + \"_dispatcher_\" + this.count;\r\n\r\n          this.log(dispatcherFnName, set);\r\n          this.count++;\r\n\r\n          var expectedGet = gen.generate();\r\n          var expectedClearArgs = gen.generate();\r\n          var expectedNew = gen.generate();\r\n\r\n          var returnProp = gen.generate();\r\n          var newReturnMemberName = gen.generate();\r\n\r\n          var shuffledKeys = shuffle(Object.keys(functionDeclarations));\r\n          var mapName = this.getPlaceholder();\r\n\r\n          // creating the dispatcher function\r\n          // 1. create function map\r\n          var map = VariableDeclaration(\r\n            VariableDeclarator(\r\n              mapName,\r\n              ObjectExpression(\r\n                shuffledKeys.map((name) => {\r\n                  var [def, defParents] = functionDeclarations[name];\r\n                  var body = getBlockBody(def.body);\r\n\r\n                  var functionExpression: Node = {\r\n                    ...def,\r\n                    expression: false,\r\n                    type: \"FunctionExpression\",\r\n                    id: null,\r\n                  };\r\n\r\n                  if (def.params.length > 0) {\r\n                    const fixParam = (param: Node) => {\r\n                      this.addComment(param, \"Unloader(param): \" + param.name);\r\n\r\n                      return param;\r\n                    };\r\n\r\n                    var variableDeclaration = VariableDeclaration(\r\n                      VariableDeclarator(\r\n                        {\r\n                          type: \"ArrayPattern\",\r\n                          elements: def.params.map(fixParam),\r\n                        },\r\n                        ArrayExpression(\r\n                          varArgs\r\n                            .slice(0, def.params.length)\r\n                            .map(Identifier as any)\r\n                        )\r\n                      )\r\n                    );\r\n\r\n                    prepend(def.body, variableDeclaration);\r\n\r\n                    // replace params with random identifiers\r\n                    var args = [0, 1, 2].map((x) => this.getPlaceholder());\r\n                    functionExpression.params = args.map((x) => Identifier(x));\r\n\r\n                    var deadCode = choice([\"fakeReturn\", \"ifStatement\"]);\r\n\r\n                    switch (deadCode) {\r\n                      case \"fakeReturn\":\r\n                        // Dead code...\r\n                        var ifStatement = IfStatement(\r\n                          UnaryExpression(\"!\", Identifier(args[0])),\r\n                          [\r\n                            ReturnStatement(\r\n                              CallExpression(Identifier(args[1]), [\r\n                                ThisExpression(),\r\n                                Identifier(args[2]),\r\n                              ])\r\n                            ),\r\n                          ],\r\n                          null\r\n                        );\r\n\r\n                        body.unshift(ifStatement);\r\n                        break;\r\n\r\n                      case \"ifStatement\":\r\n                        var test = LogicalExpression(\r\n                          \"||\",\r\n                          Identifier(args[0]),\r\n                          AssignmentExpression(\r\n                            \"=\",\r\n                            Identifier(args[1]),\r\n                            CallExpression(Identifier(args[2]), [])\r\n                          )\r\n                        );\r\n                        def.body = BlockStatement([\r\n                          IfStatement(test, [...body], null),\r\n                          ReturnStatement(Identifier(args[1])),\r\n                        ]);\r\n                        break;\r\n                    }\r\n                  }\r\n\r\n                  // For logging purposes\r\n                  var signature =\r\n                    name +\r\n                    \"(\" +\r\n                    def.params.map((x) => x.name || \"<>\").join(\",\") +\r\n                    \")\";\r\n                  this.log(\"Added\", signature);\r\n\r\n                  // delete ref in block\r\n                  if (defParents.length) {\r\n                    deleteDirect(def, defParents[0]);\r\n                  }\r\n\r\n                  this.addComment(functionExpression, signature);\r\n                  return Property(\r\n                    Literal(newFnNames[name]),\r\n                    functionExpression,\r\n                    false\r\n                  );\r\n                })\r\n              )\r\n            )\r\n          );\r\n\r\n          var getterArgNames = varArgs.map((x) => this.getPlaceholder());\r\n\r\n          var x = this.getPlaceholder();\r\n          var y = this.getPlaceholder();\r\n          var z = this.getPlaceholder();\r\n\r\n          function getAccessor() {\r\n            return MemberExpression(Identifier(mapName), Identifier(x), true);\r\n          }\r\n\r\n          // 2. define it\r\n          var fn = FunctionDeclaration(\r\n            dispatcherFnName,\r\n            [Identifier(x), Identifier(y), Identifier(z)],\r\n            [\r\n              // Define map of callable functions\r\n              map,\r\n\r\n              // Set returning variable to undefined\r\n              VariableDeclaration(VariableDeclarator(returnProp)),\r\n\r\n              // Check for getter flag\r\n              varArgs.length\r\n                ? IfStatement(\r\n                    BinaryExpression(\r\n                      \"==\",\r\n                      Identifier(y),\r\n                      Literal(expectedClearArgs)\r\n                    ),\r\n                    [\r\n                      ExpressionStatement(\r\n                        SequenceExpression(\r\n                          varArgs.map((x) =>\r\n                            AssignmentExpression(\r\n                              \"=\",\r\n                              Identifier(x),\r\n                              Identifier(\"undefined\")\r\n                            )\r\n                          )\r\n                        )\r\n                      ),\r\n                    ],\r\n                    null\r\n                  )\r\n                : // Fake code\r\n                  IfStatement(\r\n                    BinaryExpression(\r\n                      \"==\",\r\n                      Identifier(y),\r\n                      Literal(gen.generate())\r\n                    ),\r\n                    [ReturnStatement(Identifier(z))],\r\n                    null\r\n                  ),\r\n              IfStatement(\r\n                BinaryExpression(\"==\", Identifier(y), Literal(expectedGet)),\r\n                [\r\n                  // Getter flag: return the function object\r\n                  ExpressionStatement(\r\n                    AssignmentExpression(\r\n                      \"=\",\r\n                      Identifier(returnProp),\r\n                      FunctionExpression(\r\n                        getterArgNames.map(Identifier as any),\r\n                        [\r\n                          // Arg setter\r\n                          ...getterArgNames.map((x, i) =>\r\n                            ExpressionStatement(\r\n                              AssignmentExpression(\r\n                                \"=\",\r\n                                Identifier(varArgs[i]),\r\n                                Identifier(x)\r\n                              )\r\n                            )\r\n                          ),\r\n\r\n                          // Call fn & return\r\n                          ReturnStatement(\r\n                            CallExpression(\r\n                              MemberExpression(\r\n                                getAccessor(),\r\n                                Identifier(\"call\"),\r\n                                false\r\n                              ),\r\n                              [ThisExpression(), Literal(gen.generate())]\r\n                            )\r\n                          ),\r\n                        ]\r\n                      )\r\n                    )\r\n                  ),\r\n                ],\r\n                [\r\n                  // Call the function, return result\r\n                  ExpressionStatement(\r\n                    AssignmentExpression(\r\n                      \"=\",\r\n                      Identifier(returnProp),\r\n                      CallExpression(getAccessor(), [Literal(gen.generate())])\r\n                    )\r\n                  ),\r\n                ]\r\n              ),\r\n\r\n              // Check how the function was invoked (new () vs ())\r\n              IfStatement(\r\n                BinaryExpression(\"==\", Identifier(z), Literal(expectedNew)),\r\n                [\r\n                  // Wrap in object\r\n                  ReturnStatement(\r\n                    ObjectExpression([\r\n                      Property(\r\n                        Identifier(newReturnMemberName),\r\n                        Identifier(returnProp),\r\n                        false\r\n                      ),\r\n                    ])\r\n                  ),\r\n                ],\r\n                [\r\n                  // Return raw result\r\n                  ReturnStatement(Identifier(returnProp)),\r\n                ]\r\n              ),\r\n            ]\r\n          );\r\n\r\n          prepend(object, fn);\r\n\r\n          if (varArgs.length) {\r\n            prepend(\r\n              object,\r\n              VariableDeclaration(varArgs.map((x) => VariableDeclarator(x)))\r\n            );\r\n          }\r\n\r\n          identifiers.forEach(([o, p]) => {\r\n            if (o.type != \"Identifier\") {\r\n              return;\r\n            }\r\n\r\n            var newName = newFnNames[o.name];\r\n            if (!newName) {\r\n              return;\r\n            }\r\n\r\n            if (!functionDeclarations[o.name]) {\r\n              this.error(new Error(\"newName, missing function declaration\"));\r\n            }\r\n\r\n            var info = getIdentifierInfo(o, p);\r\n            if (info.isFunctionCall && p[0].type == \"CallExpression\") {\r\n              // Invoking call expression: `a();`\r\n\r\n              if (o.name == dispatcherFnName) {\r\n                return;\r\n              }\r\n\r\n              this.log(\r\n                `${o.name}(${p[0].arguments\r\n                  .map((_) => \"<>\")\r\n                  .join(\",\")}) -> ${dispatcherFnName}('${newName}')`\r\n              );\r\n\r\n              var assignmentExpressions: Node[] = [];\r\n              var dispatcherArgs: Node[] = [Literal(newName)];\r\n\r\n              if (p[0].arguments.length) {\r\n                varArgs.forEach((vName, i) => {\r\n                  if (functionDeclarations[o.name][0].params.length > i) {\r\n                    assignmentExpressions.push(\r\n                      AssignmentExpression(\r\n                        \"=\",\r\n                        Identifier(vName),\r\n                        p[0].arguments[i] || Identifier(\"undefined\")\r\n                      )\r\n                    );\r\n                  }\r\n                });\r\n              } else {\r\n                dispatcherArgs.push(Literal(expectedClearArgs));\r\n              }\r\n\r\n              var type = choice([\"CallExpression\", \"NewExpression\"]);\r\n              var callExpression = null;\r\n\r\n              switch (type) {\r\n                case \"CallExpression\":\r\n                  callExpression = CallExpression(\r\n                    Identifier(dispatcherFnName),\r\n                    dispatcherArgs\r\n                  );\r\n                  break;\r\n\r\n                case \"NewExpression\":\r\n                  if (dispatcherArgs.length == 1) {\r\n                    dispatcherArgs.push(Identifier(\"undefined\"));\r\n                  }\r\n                  callExpression = MemberExpression(\r\n                    NewExpression(Identifier(dispatcherFnName), [\r\n                      ...dispatcherArgs,\r\n                      Literal(expectedNew),\r\n                    ]),\r\n                    Identifier(newReturnMemberName),\r\n                    false\r\n                  );\r\n                  break;\r\n              }\r\n\r\n              this.addComment(\r\n                callExpression,\r\n                \"Calling \" +\r\n                  o.name +\r\n                  \"(\" +\r\n                  p[0].arguments.map((x) => x.name).join(\", \") +\r\n                  \")\"\r\n              );\r\n\r\n              var expr: Node = assignmentExpressions.length\r\n                ? SequenceExpression([...assignmentExpressions, callExpression])\r\n                : callExpression;\r\n\r\n              // Replace the parent call expression\r\n              this.replace(p[0], expr);\r\n            } else {\r\n              // Non-invoking reference: `a`\r\n\r\n              if (info.spec.isDefined) {\r\n                if (info.isFunctionDeclaration) {\r\n                  this.log(\r\n                    \"Skipped getter \" + o.name + \" (function declaration)\"\r\n                  );\r\n                } else {\r\n                  this.log(\"Skipped getter \" + o.name + \" (defined)\");\r\n                }\r\n                return;\r\n              }\r\n              if (info.spec.isModified) {\r\n                this.log(\"Skipped getter \" + o.name + \" (modified)\");\r\n                return;\r\n              }\r\n\r\n              this.log(\r\n                `(getter) ${o.name} -> ${dispatcherFnName}('${newName}')`\r\n              );\r\n              this.replace(\r\n                o,\r\n                CallExpression(Identifier(dispatcherFnName), [\r\n                  Literal(newName),\r\n                  Literal(expectedGet),\r\n                ])\r\n              );\r\n            }\r\n          });\r\n        }\r\n      }\r\n    };\r\n  }\r\n}\r\n","import { ComputeProbabilityMap } from \"../index\";\r\nimport { ObfuscateOrder } from \"../obfuscator\";\r\nimport Template from \"../templates/template\";\r\nimport { isBlock } from \"../traverse\";\r\nimport {\r\n  Identifier,\r\n  IfStatement,\r\n  Literal,\r\n  Node,\r\n  VariableDeclaration,\r\n  VariableDeclarator,\r\n} from \"../util/gen\";\r\nimport { getBlockBody, isFunction, prepend } from \"../util/insert\";\r\nimport { choice, getRandomInteger } from \"../util/random\";\r\nimport Transform from \"./transform\";\r\n\r\nconst templates = [\r\n  Template(`\r\n  function curCSS( elem, name, computed ) {\r\n    var ret;\r\n  \r\n    computed = computed || getStyles( elem );\r\n  \r\n    if ( computed ) {\r\n      ret = computed.getPropertyValue( name ) || computed[ name ];\r\n  \r\n      if ( ret === \"\" && !isAttached( elem ) ) {\r\n        ret = redacted.style( elem, name );\r\n      }\r\n    }\r\n  \r\n    return ret !== undefined ?\r\n  \r\n      // Support: IE <=9 - 11+\r\n      // IE returns zIndex value as an integer.\r\n      ret + \"\" :\r\n      ret;\r\n  }`),\r\n  Template(`\r\n  function Example() {\r\n    var state = redacted.useState(false);\r\n    return x(\r\n      ErrorBoundary,\r\n      null,\r\n      x(\r\n        DisplayName,\r\n        null,\r\n      )\r\n    );\r\n  }`),\r\n\r\n  Template(`\r\n  const path = require('path');\r\nconst { version } = require('../../package');\r\nconst { version: dashboardPluginVersion } = require('@redacted/enterprise-plugin/package');\r\nconst { version: componentsVersion } = require('@redacted/components/package');\r\nconst { sdkVersion } = require('@redacted/enterprise-plugin');\r\nconst isStandaloneExecutable = require('../utils/isStandaloneExecutable');\r\nconst resolveLocalredactedPath = require('./resolve-local-redacted-path');\r\n\r\nconst redactedPath = path.resolve(__dirname, '../redacted.js');`),\r\n\r\n  Template(`\r\nmodule.exports = async () => {\r\n  const cliParams = new Set(process.argv.slice(2));\r\n  if (!cliParams.has('--version')) {\r\n    // Ideally we should output version info in whatever context \"--version\" or \"-v\" params\r\n    // are used. Still \"-v\" is defined also as a \"--verbose\" alias in some commands.\r\n    // Support for \"--verbose\" is expected to go away with\r\n    // https://github.com/redacted/redacted/issues/1720\r\n    // Until that's addressed we can recognize \"-v\" only as top-level param\r\n    if (cliParams.size !== 1) return false;\r\n    if (!cliParams.has('-v')) return false;\r\n  }\r\n\r\n  const installationModePostfix = await (async () => {\r\n    if (isStandaloneExecutable) return ' (standalone)';\r\n    if (redactedPath === (await resolveLocalredactedPath())) return ' (local)';\r\n    return '';\r\n  })();\r\n\r\n  return true;\r\n};`),\r\n  Template(`\r\nfunction setCookie(cname, cvalue, exdays) {\r\n  var d = new Date();\r\n  d.setTime(d.getTime() + (exdays*24*60*60*1000));\r\n  var expires = \"expires=\"+ d.toUTCString();\r\n  document.cookie = cname + \"=\" + cvalue + \";\" + expires + \";path=/\";\r\n}`),\r\n];\r\n\r\n/**\r\n * Adds dead code to blocks.\r\n *\r\n * - Adds fake variables.\r\n * - Adds fake predicates.\r\n * - Adds fake code from various samples.\r\n */\r\nexport default class DeadCode extends Transform {\r\n  usedNames: Set<string>;\r\n\r\n  constructor(o) {\r\n    super(o, ObfuscateOrder.DeadCode);\r\n\r\n    this.usedNames = new Set();\r\n  }\r\n\r\n  match(object: Node, parents: Node[]) {\r\n    return isFunction(object) && isBlock(object.body);\r\n  }\r\n\r\n  transform(object: Node, parents: Node[]) {\r\n    if (ComputeProbabilityMap(this.options.deadCode)) {\r\n      return () => {\r\n        var name = this.getPlaceholder();\r\n        var variableDeclaration = VariableDeclaration(\r\n          VariableDeclarator(name, Literal(false))\r\n        );\r\n\r\n        var body = getBlockBody(object);\r\n        var index = getRandomInteger(0, body.length);\r\n\r\n        var template = choice(templates);\r\n\r\n        var ifStatement = IfStatement(\r\n          Identifier(name),\r\n          template.compile(),\r\n          null\r\n        );\r\n\r\n        body.splice(index, 0, ifStatement);\r\n        prepend(object, variableDeclaration);\r\n      };\r\n    }\r\n  }\r\n}\r\n","import Transform from \"./transform\";\nimport {\n  Node,\n  BinaryExpression,\n  MemberExpression,\n  Identifier,\n  CallExpression,\n  Literal,\n  UnaryExpression,\n  UpdateExpression,\n  SequenceExpression,\n  VariableDeclaration,\n  ObjectExpression,\n  Property,\n  FunctionExpression,\n  ReturnStatement,\n  ExpressionStatement,\n  ArrayExpression,\n  LogicalExpression,\n  VariableDeclarator,\n} from \"../util/gen\";\nimport { choice, getRandomInteger, shuffle } from \"../util/random\";\nimport { ObfuscateOrder } from \"../obfuscator\";\nimport { clone, prepend } from \"../util/insert\";\nimport Template from \"../templates/template\";\nimport { ComputeProbabilityMap } from \"../index\";\n\nfunction isTestExpression(object: Node, parents: Node[]) {\n  if (!object || !parents[0]) {\n    return false;\n  }\n\n  if (parents[0].type == \"SwitchCase\" && parents[0].test == object) {\n    return true;\n  }\n\n  if (\n    {\n      SwitchStatement: 1,\n      ForStatement: 1,\n      WhileStatement: 1,\n      DoWhileStatement: 1,\n      IfStatement: 1,\n      ConditionExpression: 1,\n      SwitchCase: 1,\n    }[parents[0].type] &&\n    parents[0].test == object\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Changes test expression (such as if statements, for loops) to add predicates.\n *\n * Predicates are computed at runtime.\n */\nexport default class OpaquePredicates extends Transform {\n  undefinedVar: string;\n  nullVar: string;\n  numberVar: string;\n\n  predicateName: string;\n  predicate: Node;\n  predicates: { [name: string]: Node };\n\n  gen: any;\n\n  constructor(o) {\n    super(o, ObfuscateOrder.OpaquePredicates);\n\n    this.predicates = Object.create(null);\n    this.gen = this.getGenerator(getRandomInteger(0, 20));\n  }\n\n  match(object: Node, parents: Node[]) {\n    return isTestExpression(object, parents);\n  }\n\n  transform(object: Node, parents: Node[]) {\n    return () => {\n      if (ComputeProbabilityMap(this.options.opaquePredicates)) {\n        if (!this.predicateName) {\n          this.predicateName = this.getPlaceholder();\n          prepend(\n            parents[parents.length - 1] || object,\n            VariableDeclaration(\n              VariableDeclarator(\n                this.predicateName,\n                (this.predicate = ObjectExpression([]))\n              )\n            )\n          );\n        }\n\n        var expr = choice(Object.values(this.predicates));\n\n        if (\n          !expr ||\n          Math.random() < 0.5 / (Object.keys(this.predicates).length || 1)\n        ) {\n          var prop = this.gen.generate();\n          var accessor = MemberExpression(\n            Identifier(this.predicateName),\n            Identifier(prop),\n            false\n          );\n          switch (choice([\"array\", \"number\", \"string\"])) {\n            case \"array\":\n              var arrayProp = this.gen.generate();\n              this.predicate.properties.push(\n                Property(Identifier(arrayProp), ArrayExpression([]))\n              );\n              this.predicate.properties.push(\n                Property(\n                  Identifier(prop),\n                  FunctionExpression(\n                    [],\n                    Template(`\n                  if ( !${this.predicateName}.${arrayProp}[0] ) {\n                    ${this.predicateName}.${arrayProp}.push(${getRandomInteger(\n                      -100,\n                      100\n                    )});\n                  }\n                  return ${this.predicateName}.${arrayProp}.length;\n                `).compile()\n                  )\n                )\n              );\n              expr = CallExpression(accessor, []);\n              break;\n\n            case \"number\":\n              this.predicate.properties.push(\n                Property(Identifier(prop), Literal(getRandomInteger(10, 90)))\n              );\n              expr = BinaryExpression(\n                \">\",\n                accessor,\n                Literal(getRandomInteger(2, 9))\n              );\n              break;\n\n            case \"string\":\n              var str = this.getPlaceholder();\n              var index = getRandomInteger(0, str.length);\n              var fn = Math.random() > 0.5 ? \"charAt\" : \"charCodeAt\";\n\n              this.predicate.properties.push(\n                Property(Identifier(prop), Literal(str))\n              );\n              expr = BinaryExpression(\n                \"==\",\n                CallExpression(MemberExpression(accessor, Literal(fn), true), [\n                  Literal(index),\n                ]),\n                Literal(str[fn](index))\n              );\n              break;\n          }\n\n          this.predicates[prop] = expr;\n\n          if (Math.random() > 0.5) {\n            shuffle(this.predicate.properties);\n          }\n        }\n\n        var cloned = clone(expr);\n\n        if (object.type == \"Literal\" && object.value) {\n          this.replace(object, cloned);\n        } else {\n          this.replace(object, LogicalExpression(\"&&\", { ...object }, cloned));\n        }\n      }\n    };\n  }\n}\n","import Transform from \"./transform\";\nimport {\n  Node,\n  FunctionDeclaration,\n  ReturnStatement,\n  CallExpression,\n  Identifier,\n  Literal,\n  IfStatement,\n  BinaryExpression,\n  LogicalExpression,\n  SwitchCase,\n  SwitchStatement,\n  ThrowStatement,\n} from \"../util/gen\";\nimport { prepend } from \"../util/insert\";\nimport { ObfuscateOrder } from \"../obfuscator\";\nimport { getBlock } from \"../traverse\";\nimport { getRandomInteger } from \"../util/random\";\n\nexport default class Calculator extends Transform {\n  gen: any;\n  ops: { [operator: string]: string };\n  calculatorFn: string;\n\n  constructor(o) {\n    super(o, ObfuscateOrder.Calculator);\n\n    this.ops = Object.create(null);\n    this.calculatorFn = this.getPlaceholder();\n\n    this.gen = this.getGenerator();\n  }\n\n  match(object: Node, parents: Node[]) {\n    return object.type == \"Program\" || object.type == \"BinaryExpression\";\n  }\n\n  transform(object: Node, parents: Node[]) {\n    if (object.type == \"Program\") {\n      return () => {\n        var block = getBlock(object, parents);\n\n        if (Object.keys(this.ops).length == 0) {\n          return;\n        }\n\n        var opArg = this.getPlaceholder();\n        var leftArg = this.getPlaceholder();\n        var rightArg = this.getPlaceholder();\n        var switchCases = [];\n\n        Object.keys(this.ops).forEach((operator) => {\n          var code = this.ops[operator];\n\n          var factory =\n            operator == \"&&\" || operator == \"||\"\n              ? LogicalExpression\n              : BinaryExpression;\n\n          var body = [\n            ReturnStatement(\n              factory(operator, Identifier(leftArg), Identifier(rightArg))\n            ),\n          ];\n\n          switchCases.push(SwitchCase(Literal(code), body));\n        });\n\n        var func = FunctionDeclaration(\n          this.calculatorFn,\n          [opArg, leftArg, rightArg].map((x) => Identifier(x)),\n          [SwitchStatement(Identifier(opArg), switchCases)]\n        );\n\n        prepend(block, func);\n      };\n    }\n\n    if (object.type == \"BinaryExpression\") {\n      var operator = object.operator;\n      if (\n        !operator ||\n        operator == \"==\" ||\n        operator == \"!=\" ||\n        operator == \"===\"\n      ) {\n        return;\n      }\n      if (!this.ops[operator]) {\n        var newState;\n        do {\n          newState = getRandomInteger(\n            -1000,\n            1000 + Object.keys(this.ops).length * 5\n          );\n        } while (Object.values(this.ops).indexOf(newState) != -1);\n\n        this.ops[operator] = newState;\n        this.log(operator, `calc(${newState}, left, right)`);\n      }\n\n      return () => {\n        this.replace(\n          object,\n          CallExpression(Identifier(this.calculatorFn), [\n            Literal(this.ops[operator]),\n            { ...object.left },\n            { ...object.right },\n          ])\n        );\n      };\n    }\n  }\n}\n","import { ok } from \"assert\";\r\nimport { ComputeProbabilityMap } from \"../index\";\r\nimport { ObfuscateOrder } from \"../obfuscator\";\r\nimport Template from \"../templates/template\";\r\nimport { isBlock, walk } from \"../traverse\";\r\nimport {\r\n  AssignmentExpression,\r\n  BinaryExpression,\r\n  BlockStatement,\r\n  BreakStatement,\r\n  ExpressionStatement,\r\n  Identifier,\r\n  IfStatement,\r\n  Literal,\r\n  Node,\r\n  SwitchCase,\r\n  SwitchStatement,\r\n  VariableDeclaration,\r\n  VariableDeclarator,\r\n  WhileStatement,\r\n} from \"../util/gen\";\r\nimport { getBlockBody, prepend } from \"../util/insert\";\r\nimport { choice, getRandomInteger, shuffle } from \"../util/random\";\r\nimport Transform from \"./transform\";\r\n\r\n/**\r\n * Does complex math to the state variable, after both CFF and CFO have run.\r\n *\r\n * The switch statements are ones with numbered cases and a single identifier discriminant.\r\n */\r\nexport class SwitchCaseObfuscation extends Transform {\r\n  constructor(o) {\r\n    super(o);\r\n  }\r\n\r\n  match(object, parents) {\r\n    return (\r\n      object.type == \"SwitchStatement\" &&\r\n      object.discriminant.type == \"Identifier\" &&\r\n      !object.cases.find(\r\n        (x) => !(x.test.type == \"Literal\" && typeof x.test.value === \"number\")\r\n      )\r\n    );\r\n  }\r\n\r\n  transform(object, parents) {\r\n    var body = parents[0];\r\n\r\n    if (parents[0].type == \"LabelStatement\") {\r\n      body = parents[1];\r\n    }\r\n    if (!Array.isArray(body)) {\r\n      return;\r\n    }\r\n\r\n    var factor = getRandomInteger(-250, 250);\r\n    if (factor == 0) {\r\n      factor = 1;\r\n    }\r\n    var offset = getRandomInteger(-250, 250);\r\n\r\n    var newVar = this.getPlaceholder();\r\n\r\n    var newStates = [];\r\n    object.cases.forEach((x) => {\r\n      var current = x.test.value;\r\n      var value = current * factor + offset;\r\n\r\n      newStates.push(value);\r\n    });\r\n\r\n    if (new Set(newStates).size != newStates.length) {\r\n      // not possible because of clashing case test\r\n      return;\r\n    }\r\n\r\n    // State variable declaration\r\n    body.unshift(\r\n      VariableDeclaration(\r\n        VariableDeclarator(\r\n          newVar,\r\n          Template(\r\n            `${object.discriminant.name} * ${factor} + ${offset}`\r\n          ).single().expression\r\n        )\r\n      )\r\n    );\r\n\r\n    object.discriminant = Identifier(newVar);\r\n\r\n    // possible so override\r\n    object.cases.forEach((x, i) => {\r\n      x.test = Literal(newStates[i]);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Obfuscates For and While statements.\r\n */\r\nexport class ControlFlowObfuscation extends Transform {\r\n  constructor(o) {\r\n    super(o);\r\n  }\r\n\r\n  match(object, parents) {\r\n    return {\r\n      ForStatement: 1,\r\n    }[object.type];\r\n  }\r\n\r\n  transform(object, parents) {\r\n    if (object.$controlFlowObfuscation) {\r\n      // avoid infinite loop\r\n      return;\r\n    }\r\n\r\n    if (containsLexicallyBoundVariables(object)) {\r\n      return;\r\n    }\r\n\r\n    // No place to insert more statements\r\n    if (!Array.isArray(parents[0])) {\r\n      return;\r\n    }\r\n\r\n    if (!ComputeProbabilityMap(this.options.controlFlowFlattening)) {\r\n      return;\r\n    }\r\n\r\n    var init = [];\r\n    var update = [];\r\n    var test: Node = null;\r\n    var consequent = [];\r\n\r\n    if (object.type == \"ForStatement\") {\r\n      if (object.init) {\r\n        init.push({ ...object.init });\r\n      }\r\n      if (object.update) {\r\n        update.push(ExpressionStatement({ ...object.update }));\r\n      }\r\n      if (object.test) {\r\n        test = object.test;\r\n      }\r\n    }\r\n\r\n    if (object.type == \"WhileStatement\") {\r\n      if (object.test) {\r\n        test = object.test;\r\n      }\r\n    }\r\n\r\n    if (object.body.type == \"BlockStatement\") {\r\n      consequent.push(...getBlockBody(object.body));\r\n    } else {\r\n      consequent.push(object.body);\r\n    }\r\n\r\n    if (!test) {\r\n      test = Literal(true);\r\n    }\r\n\r\n    ok(test);\r\n\r\n    var stateVar = this.getPlaceholder();\r\n\r\n    //            init 0  test 1  run 2  update 3  end 4\r\n    var states: number[] = [];\r\n\r\n    // Create 4 random unique number\r\n    while (states.length <= 4) {\r\n      var newState;\r\n      do {\r\n        newState = getRandomInteger(0, 1000 + states.length);\r\n      } while (states.indexOf(newState) != -1);\r\n\r\n      states.push(newState);\r\n    }\r\n\r\n    getBlockBody(parents[1] || parents[0]).unshift(\r\n      VariableDeclaration(VariableDeclarator(stateVar, Literal(states[0])))\r\n    );\r\n\r\n    function goto(from: number, to: number) {\r\n      return ExpressionStatement(\r\n        AssignmentExpression(\"+=\", Identifier(stateVar), Literal(to - from))\r\n      );\r\n    }\r\n\r\n    var cases = [\r\n      SwitchCase(Literal(states[0]), [\r\n        ...init,\r\n        goto(states[0], states[1]),\r\n        BreakStatement(),\r\n      ]),\r\n      SwitchCase(Literal(states[1]), [\r\n        IfStatement(\r\n          { ...test },\r\n          [goto(states[1], states[2])],\r\n          [goto(states[1], states[4])]\r\n        ),\r\n        BreakStatement(),\r\n      ]),\r\n      SwitchCase(Literal(states[2]), [\r\n        ...consequent,\r\n        goto(states[2], states[3]),\r\n        BreakStatement(),\r\n      ]),\r\n      SwitchCase(Literal(states[3]), [\r\n        ...update,\r\n        goto(states[3], states[1]),\r\n        BreakStatement(),\r\n      ]),\r\n    ];\r\n\r\n    Array(getRandomInteger(0, 3))\r\n      .fill(0)\r\n      .map(() => {\r\n        var newState;\r\n        do {\r\n          newState = getRandomInteger(0, 1000 + states.length * 2);\r\n        } while (states.indexOf(newState) != -1);\r\n        states.push(newState);\r\n\r\n        var nextState;\r\n        do {\r\n          nextState = getRandomInteger(0, 1000 + states.length * 3);\r\n        } while (states.indexOf(nextState) != -1);\r\n        states.push(nextState);\r\n\r\n        var body = [];\r\n\r\n        body.push(\r\n          ExpressionStatement(\r\n            AssignmentExpression(\"=\", Identifier(stateVar), Literal(nextState))\r\n          ),\r\n          BreakStatement()\r\n        );\r\n\r\n        cases.push(SwitchCase(Literal(newState), body));\r\n      });\r\n\r\n    shuffle(cases);\r\n\r\n    this.replace(\r\n      object,\r\n      WhileStatement(\r\n        BinaryExpression(\r\n          \"!=\",\r\n          Identifier(stateVar),\r\n          Literal(states[states.length - 1])\r\n        ),\r\n        [SwitchStatement(Identifier(stateVar), cases)]\r\n      )\r\n    );\r\n\r\n    // Marked to not be infinite\r\n    object.$controlFlowObfuscation = 1;\r\n  }\r\n}\r\n\r\nfunction containsLexicallyBoundVariables(object: Node) {\r\n  var contains = false;\r\n  walk(object, [], (o, p) => {\r\n    if (o.type == \"VariableDeclaration\") {\r\n      if (o.kind === \"let\") {\r\n        // Control Flow Flattening changes the lexical block, therefore this is not possible\r\n        // Maybe a transformation to remove let\r\n        contains = true;\r\n      }\r\n    }\r\n  });\r\n\r\n  return contains;\r\n}\r\n\r\n/**\r\n * Breaks functions into DAGs (Directed Acyclic Graphs)\r\n *\r\n * - 1. Break functions into chunks\r\n * - 2. Shuffle order and assign a random number to each index\r\n * - 3. Create a Switch Case for each, with transition to next block.\r\n *\r\n * The Switch statement:\r\n *\r\n * - 1. The state variable controls which case will run next\r\n * - 2. At the end of each case, the state variable is updated to the next block of code.\r\n * - 3. The while loop continues until the the state variable is the end state.\r\n *\r\n */\r\nexport default class ControlFlowFlattening extends Transform {\r\n  constructor(o) {\r\n    super(o, ObfuscateOrder.ControlFlowFlattening);\r\n\r\n    this.before.push(new ControlFlowObfuscation(o));\r\n\r\n    this.after.push(new SwitchCaseObfuscation(o));\r\n  }\r\n\r\n  match(object, parents) {\r\n    return isBlock(object);\r\n  }\r\n\r\n  transform(object, parents) {\r\n    if (containsLexicallyBoundVariables(object)) {\r\n      return;\r\n    }\r\n\r\n    if (!ComputeProbabilityMap(this.options.controlFlowFlattening)) {\r\n      return;\r\n    }\r\n\r\n    var body = getBlockBody(object.body);\r\n    if (body.length) {\r\n      // First step is to reorder the body\r\n      // Fix 1. Bring hoisted functions up to be declared first\r\n\r\n      var functionDeclarations: Set<Node> = new Set();\r\n\r\n      body.forEach((stmt, i) => {\r\n        if (stmt.type == \"FunctionDeclaration\") {\r\n          functionDeclarations.add(stmt);\r\n        }\r\n      });\r\n\r\n      var chunks: Node[][] = [[]];\r\n\r\n      var fraction = 0.9;\r\n      if (body.length > 20) {\r\n        fraction /= body.length - 18;\r\n      }\r\n      fraction = Math.min(0.1, fraction);\r\n\r\n      body.forEach((x, i) => {\r\n        if (functionDeclarations.has(x)) {\r\n          return;\r\n        }\r\n\r\n        var current = chunks[chunks.length - 1];\r\n\r\n        if (!current.length || Math.random() < fraction) {\r\n          current.push(x);\r\n        } else {\r\n          chunks.push([x]);\r\n        }\r\n      });\r\n\r\n      if (!chunks[chunks.length - 1].length) {\r\n        chunks.pop();\r\n      }\r\n      if (chunks.length < 2) {\r\n        return;\r\n      }\r\n\r\n      // Add empty cases serving as transitions\r\n      Array(getRandomInteger(0, 3))\r\n        .fill(0)\r\n        .map((x) => {\r\n          var index = getRandomInteger(0, chunks.length);\r\n\r\n          // Empty chunk = no code\r\n          chunks.splice(index, 0, []);\r\n        });\r\n\r\n      var selection: Set<number> = new Set();\r\n\r\n      var deadCases = getRandomInteger(0, 3);\r\n\r\n      for (var i = 0; i < chunks.length + 1 + deadCases; i++) {\r\n        var newState;\r\n        do {\r\n          newState = getRandomInteger(1, chunks.length * 5);\r\n        } while (selection.has(newState));\r\n\r\n        selection.add(newState);\r\n      }\r\n\r\n      ok(selection.size == chunks.length + 1 + deadCases);\r\n\r\n      var states = Array.from(selection);\r\n      var stateVar = this.getPlaceholder();\r\n\r\n      var endState = states[states.length - 1 - deadCases];\r\n\r\n      interface Case {\r\n        state: number;\r\n        nextState: number;\r\n        body: Node[];\r\n        order: number;\r\n      }\r\n\r\n      var order = Object.create(null);\r\n      var cases: Case[] = chunks.map((body, i) => {\r\n        var caseObject = {\r\n          body: body,\r\n          state: states[i],\r\n          nextState: states[i + 1],\r\n          order: i,\r\n        };\r\n        order[i] = caseObject;\r\n\r\n        return caseObject;\r\n      });\r\n\r\n      // Add dead cases that can never be reached\r\n      Array(deadCases)\r\n        .fill(0)\r\n        .forEach((x, i) => {\r\n          var thisState = states[chunks.length + i];\r\n          var nextState;\r\n\r\n          do {\r\n            nextState = choice(states);\r\n          } while (nextState == thisState);\r\n\r\n          cases.push({\r\n            body: [],\r\n            state: thisState,\r\n            nextState: nextState,\r\n            order: -i,\r\n          });\r\n        });\r\n\r\n      shuffle(cases);\r\n\r\n      var discriminant = Identifier(stateVar);\r\n\r\n      return () => {\r\n        body.length = 0;\r\n\r\n        if (functionDeclarations.size) {\r\n          functionDeclarations.forEach((x) => {\r\n            body.unshift({ ...x });\r\n          });\r\n        }\r\n\r\n        var switchStatement: Node = SwitchStatement(\r\n          discriminant,\r\n          cases.map((x, i) => {\r\n            var state = x.state;\r\n            var nextState = x.nextState;\r\n            var diff = nextState - state;\r\n\r\n            var statements = [];\r\n\r\n            statements.push(...x.body);\r\n            statements.push(\r\n              ExpressionStatement(\r\n                AssignmentExpression(\"+=\", Identifier(stateVar), Literal(diff))\r\n              )\r\n            );\r\n\r\n            statements.push(BreakStatement());\r\n\r\n            var test = Literal(state);\r\n\r\n            return SwitchCase(test, statements);\r\n          })\r\n        );\r\n\r\n        body.push(\r\n          VariableDeclaration(VariableDeclarator(stateVar, Literal(states[0]))),\r\n\r\n          WhileStatement(\r\n            BinaryExpression(\"!=\", Identifier(stateVar), Literal(endState)),\r\n            [switchStatement]\r\n          )\r\n        );\r\n      };\r\n    }\r\n  }\r\n}\r\n","import { compileJsSync } from \"../compiler\";\nimport { ComputeProbabilityMap } from \"../index\";\nimport { ObfuscateOrder } from \"../obfuscator\";\nimport {\n  CallExpression,\n  ExpressionStatement,\n  Identifier,\n  Literal,\n  Node,\n} from \"../util/gen\";\nimport { isFunction } from \"../util/insert\";\nimport Transform from \"./transform\";\n\nexport default class Eval extends Transform {\n  constructor(o) {\n    super(o, ObfuscateOrder.Eval);\n  }\n\n  match(object, parents) {\n    return isFunction(object) && object.type != \"ArrowFunctionExpression\";\n  }\n\n  transform(object, parents) {\n    if (\n      !ComputeProbabilityMap(\n        this.options.eval,\n        (x) => x,\n        object.id && object.id.name\n      )\n    ) {\n      return;\n    }\n\n    object.$eval = () => {\n      var code = compileJsSync(object, this.options);\n\n      if (object.type == \"FunctionExpression\") {\n        code = \"(\" + code + \")\";\n      }\n\n      var literal = Literal(code);\n\n      this.dynamicallyObfuscate(literal);\n\n      var expr: Node = CallExpression(Identifier(\"eval\"), [literal]);\n      if (object.type == \"FunctionDeclaration\") {\n        expr = ExpressionStatement(expr);\n      }\n\n      this.replace(object, expr);\n    };\n  }\n}\n","import Template from \"../../templates/template\";\nimport Transform, { reservedIdentifiers } from \"../transform\";\nimport { ObfuscateOrder } from \"../../obfuscator\";\nimport {\n  Node,\n  Location,\n  CallExpression,\n  Identifier,\n  Literal,\n  FunctionDeclaration,\n  VariableDeclaration,\n  ObjectExpression,\n  Property,\n  ReturnStatement,\n  MemberExpression,\n  SwitchStatement,\n  SwitchCase,\n} from \"../../util/gen\";\nimport { prepend } from \"../../util/insert\";\nimport { getIdentifierInfo } from \"../../util/identifiers\";\nimport { getRandomInteger } from \"../../util/random\";\n\nclass GlobalAnalysis extends Transform {\n  notGlobals: Set<string>;\n  globals: { [name: string]: Location[] };\n\n  constructor(o) {\n    super(o);\n\n    this.globals = Object.create(null);\n    this.notGlobals = new Set();\n  }\n\n  match(object: Node, parents: Node[]) {\n    return object.type == \"Identifier\";\n  }\n\n  transform(object: Node, parents: Node[]) {\n    if (reservedIdentifiers.has(object.name)) {\n      return;\n    }\n\n    var info = getIdentifierInfo(object, parents);\n    if (!info.spec.isReferenced) {\n      return;\n    }\n\n    // Add to globals\n    if (!this.notGlobals.has(object.name)) {\n      if (!this.globals[object.name]) {\n        this.globals[object.name] = [];\n      }\n\n      this.globals[object.name].push([object, parents]);\n    }\n\n    if (info.spec.isDefined || info.spec.isModified) {\n      delete this.globals[object.name];\n\n      this.notGlobals.add(object.name);\n    }\n  }\n}\n\n/**\n * Global Concealing hides global variables being accessed.\n *\n * - Any variable that is not defined is considered \"global\"\n */\nexport default class GlobalConcealing extends Transform {\n  globalAnalysis: GlobalAnalysis;\n  globalVar: string;\n\n  constructor(o) {\n    super(o, ObfuscateOrder.GlobalConcealing);\n\n    this.globalAnalysis = new GlobalAnalysis(o);\n    this.before.push(this.globalAnalysis);\n\n    this.globalVar = null;\n  }\n\n  match(object: Node, parents: Node[]) {\n    return object.type == \"Program\";\n  }\n\n  transform(object: Node, parents: Node[]) {\n    return () => {\n      var globals: { [name: string]: Location[] } = this.globalAnalysis.globals;\n      this.globalAnalysis.notGlobals.forEach((del) => {\n        delete globals[del];\n      });\n\n      Object.keys(globals).forEach((x) => {\n        if (this.globalAnalysis.globals[x].length < 1) {\n          delete globals[x];\n        }\n      });\n\n      // this.log(Object.keys(globals).join(', '))\n\n      if (Object.keys(globals).length > 0) {\n        var used = new Set();\n\n        // 1. Make getter function\n\n        this.globalVar = this.getPlaceholder();\n        // \"window\" or \"global\" in node\n        var global =\n          this.options.globalVariables.values().next().value || \"window\";\n        var callee = this.getPlaceholder();\n\n        // Returns global variable or fall backs to `this`\n        var functionDeclaration = Template(`\n        function ${callee}(){\n          try {\n            return ${global};\n          } catch (e){\n            return this;\n          }\n        }`).single();\n\n        // 2. Replace old accessors\n\n        var variableDeclaration = Template(`\n        var ${this.globalVar} = ${callee}.call(this);\n        `).single();\n\n        var globalFn = this.getPlaceholder();\n\n        var newNames = Object.create(null);\n\n        Object.keys(globals).forEach((name) => {\n          var locations: Location[] = globals[name];\n          var state;\n          do {\n            state = getRandomInteger(-1000, 1000 + used.size);\n          } while (used.has(state));\n          used.add(state);\n\n          newNames[name] = state;\n\n          locations.forEach(([node, parents]) => {\n            this.replace(\n              node,\n              CallExpression(Identifier(globalFn), [Literal(state)])\n            );\n          });\n        });\n\n        // Adds all global variables to the switch statement\n        // this.options.globalVariables.forEach((name) => {\n        //   if (!newNames[name]) {\n        //     var state;\n        //     do {\n        //       state = getRandomInteger(\n        //         -1000,\n        //         1000 + used.size + this.options.globalVariables.size\n        //       );\n        //     } while (used.has(state));\n        //     used.add(state);\n\n        //     newNames[name] = state;\n        //   }\n        // });\n\n        prepend(\n          object,\n          FunctionDeclaration(\n            globalFn,\n            [Identifier(\"index\")],\n            [\n              SwitchStatement(\n                Identifier(\"index\"),\n                Object.keys(newNames).map((name) => {\n                  var code = newNames[name];\n\n                  return SwitchCase(Literal(code), [\n                    ReturnStatement(\n                      MemberExpression(\n                        Identifier(this.globalVar),\n                        Literal(name),\n                        true\n                      )\n                    ),\n                  ]);\n                })\n              ),\n            ]\n          )\n        );\n\n        prepend(object, variableDeclaration);\n        prepend(object, functionDeclaration);\n      }\n    };\n  }\n}\n","import { ok } from \"assert\";\nimport { ComputeProbabilityMap } from \"../../index\";\nimport { ObfuscateOrder } from \"../../obfuscator\";\nimport Template from \"../../templates/template\";\nimport { walk } from \"../../traverse\";\nimport {\n  ArrayExpression,\n  BinaryExpression,\n  CallExpression,\n  ExpressionStatement,\n  FunctionDeclaration,\n  Identifier,\n  Literal,\n  Location,\n  MemberExpression,\n  Node,\n  ReturnStatement,\n  UpdateExpression,\n  VariableDeclaration,\n  VariableDeclarator,\n  WhileStatement,\n} from \"../../util/gen\";\nimport { getBlockBody, isContext, prepend } from \"../../util/insert\";\nimport { getRandomInteger, shuffle } from \"../../util/random\";\nimport Transform from \"../transform\";\n\n/* eslint-disable @typescript-eslint/no-unused-expressions */\nfunction encode_ascii85(a) {\n  var b, c, d, e, f, g, h, i, j, k;\n  // @ts-ignore\n  for (\n    // @ts-ignore\n    !/[^\\x00-\\xFF]/.test(a),\n      b = \"\\x00\\x00\\x00\\x00\".slice(a.length % 4 || 4),\n      a += b,\n      c = [],\n      d = 0,\n      e = a.length;\n    e > d;\n    d += 4\n  )\n    (f =\n      (a.charCodeAt(d) << 24) +\n      (a.charCodeAt(d + 1) << 16) +\n      (a.charCodeAt(d + 2) << 8) +\n      a.charCodeAt(d + 3)),\n      0 !== f\n        ? ((k = f % 85),\n          (f = (f - k) / 85),\n          (j = f % 85),\n          (f = (f - j) / 85),\n          (i = f % 85),\n          (f = (f - i) / 85),\n          (h = f % 85),\n          (f = (f - h) / 85),\n          (g = f % 85),\n          c.push(g + 33, h + 33, i + 33, j + 33, k + 33))\n        : c.push(122);\n  return (\n    (function (a, b) {\n      for (var c = b; c > 0; c--) a.pop();\n    })(c, b.length),\n    \"<~\" + String.fromCharCode.apply(String, c) + \"~>\"\n  );\n}\n\nfunction decode_ascii85(a) {\n  var c,\n    d,\n    e,\n    f,\n    g,\n    h = String,\n    l = \"length\",\n    w = 255,\n    x = \"charCodeAt\",\n    y = \"slice\",\n    z = \"replace\";\n  for (\n    \"<~\" === a[y](0, 2) && \"~>\" === a[y](-2),\n      a = a[y](2, -2)[z](/s/g, \"\")[z](\"z\", \"!!!!!\"),\n      c = \"uuuuu\"[y](a[l] % 5 || 5),\n      a += c,\n      e = [],\n      f = 0,\n      g = a[l];\n    g > f;\n    f += 5\n  )\n    (d =\n      52200625 * (a[x](f) - 33) +\n      614125 * (a[x](f + 1) - 33) +\n      7225 * (a[x](f + 2) - 33) +\n      85 * (a[x](f + 3) - 33) +\n      (a[x](f + 4) - 33)),\n      e.push(w & (d >> 24), w & (d >> 16), w & (d >> 8), w & d);\n  return (\n    (function (a, b) {\n      for (var c = b; c > 0; c--) a.pop();\n    })(e, c[l]),\n    h.fromCharCode.apply(h, e)\n  );\n}\n\nvar Ascii85Template = Template(`\nfunction {name}(a) {\n  var c, d, e, f, g, h = String, l = \"length\", w = 255, x = \"charCodeAt\", y = \"slice\", z = \"replace\";\n  for (\"<~\" === a[y](0, 2) && \"~>\" === a[y](-2), a = a[y](2, -2)[z](/\\s/g, \"\")[z](\"z\", \"!!!!!\"), \n  c = \"uuuuu\"[y](a[l] % 5 || 5), a += c, e = [], f = 0, g = a[l]; g > f; f += 5) d = 52200625 * (a[x](f) - 33) + 614125 * (a[x](f + 1) - 33) + 7225 * (a[x](f + 2) - 33) + 85 * (a[x](f + 3) - 33) + (a[x](f + 4) - 33), \n  e.push(w & d >> 24, w & d >> 16, w & d >> 8, w & d);\n  return function(a, b) {\n    for (var c = b; c > 0; c--) a.pop();\n  }(e, c[l]), h.fromCharCode.apply(h, e);\n}\n`);\n\nexport function isModuleSource(object: Node, parents: Node[]) {\n  if (!parents[0]) {\n    return false;\n  }\n\n  if (parents[0].type == \"ImportDeclaration\" && parents[0].source == object) {\n    return true;\n  }\n\n  if (parents[0].type == \"ImportExpression\" && parents[0].source == object) {\n    return true;\n  }\n\n  return false;\n}\n\nexport default class StringConcealing extends Transform {\n  arrayExpression: Node;\n  set: Set<string>;\n  index: { [str: string]: number };\n\n  getterName = this.getPlaceholder();\n  arrayName = this.getPlaceholder();\n  decodeFn = this.getPlaceholder();\n\n  decodeNode: Node;\n\n  constructor(o) {\n    super(o, ObfuscateOrder.StringConcealing);\n\n    this.set = new Set();\n    this.index = Object.create(null);\n  }\n\n  match(object, parents) {\n    return (\n      object.type == \"Program\" ||\n      (object.type == \"Literal\" && typeof object.value === \"string\")\n    );\n  }\n\n  transform(object, parents) {\n    if (object.type == \"Program\") {\n      var encoding = true;\n      this.arrayExpression = ArrayExpression([]);\n\n      return () => {\n        prepend(\n          object,\n          FunctionDeclaration(\n            this.getterName,\n            [Identifier(\"x\")],\n            [\n              ReturnStatement(\n                encoding\n                  ? CallExpression(Identifier(this.decodeFn), [\n                      MemberExpression(\n                        Identifier(this.arrayName),\n                        Identifier(\"x\"),\n                        true\n                      ),\n                    ])\n                  : MemberExpression(\n                      Identifier(this.arrayName),\n                      Identifier(\"x\"),\n                      true\n                    )\n              ),\n            ]\n          )\n        );\n\n        prepend(\n          object,\n          VariableDeclaration(\n            VariableDeclarator(this.arrayName, this.arrayExpression)\n          )\n        );\n\n        prepend(\n          object,\n          (this.decodeNode = Ascii85Template.single({\n            name: this.decodeFn,\n          }))\n        );\n      };\n    }\n\n    return () => {\n      if (parents.find((x) => x == this.decodeNode)) {\n        return;\n      }\n\n      if (!object.value) {\n        return;\n      }\n\n      if (isModuleSource(object, parents)) {\n        return;\n      }\n\n      if (decode_ascii85(encode_ascii85(object.value)) != object.value) {\n        this.warn(object.value);\n        return;\n      }\n\n      // Fix 1. weird undefined error\n      if (object.value && object.value.length > 0) {\n        var index = -1;\n        if (!this.set.has(object.value)) {\n          this.arrayExpression.elements.push(\n            Literal(encode_ascii85(object.value))\n          );\n          index = this.arrayExpression.elements.length - 1;\n          this.index[object.value] = index;\n        } else {\n          index = this.index[object.value];\n          ok(index);\n        }\n\n        ok(index != -1, \"index == -1\");\n        this.replace(\n          object,\n          CallExpression(Identifier(this.getterName), [Literal(index)])\n        );\n\n        // Fix 1. Make parent property key computed\n        if (\n          parents[0] &&\n          parents[0].type == \"Property\" &&\n          parents[0].key == object\n        ) {\n          parents[0].computed = true;\n        }\n      }\n    };\n  }\n}\n","import Transform from \"../transform\";\nimport {\n  Node,\n  AssignmentExpression,\n  MemberExpression,\n  Identifier,\n  Literal,\n  FunctionExpression,\n  ReturnStatement,\n  CallExpression,\n  ArrayExpression,\n  VariableDeclaration,\n  ExpressionStatement,\n  ThisExpression,\n  SequenceExpression,\n} from \"../../util/gen\";\nimport { prepend } from \"../../util/insert\";\nimport { shuffle, splitIntoChunks } from \"../../util/random\";\nimport { ObfuscateOrder } from \"../../obfuscator\";\nimport { ComputeProbabilityMap } from \"../../index\";\nimport { isModuleSource } from \"./stringConcealing\";\n\nexport default class StringSplitting extends Transform {\n  joinPrototype: string;\n  strings: { [value: string]: string };\n\n  adders: Node[][];\n  vars: Node[];\n\n  constructor(o) {\n    super(o, ObfuscateOrder.StringSplitting);\n\n    this.joinPrototype = null;\n    this.strings = Object.create(null);\n\n    this.adders = [];\n    this.vars = [];\n  }\n\n  apply(tree) {\n    super.apply(tree);\n\n    if (this.vars.length) {\n      shuffle(this.adders);\n      shuffle(this.vars);\n\n      var body: Node[] = tree.body;\n\n      this.adders.forEach((nodes) => {\n        nodes.forEach((x) => body.unshift(x));\n      });\n\n      var variableDeclaration = {\n        type: \"VariableDeclaration\",\n        declarations: [],\n        kind: \"var\",\n      };\n      this.vars.forEach((node) => variableDeclaration.declarations.push(node));\n\n      body.unshift(variableDeclaration);\n    }\n  }\n\n  match(object: Node, parents: Node[]) {\n    return (\n      object.type == \"Literal\" &&\n      typeof object.value === \"string\" &&\n      !isModuleSource(object, parents)\n    );\n  }\n\n  transform(object: Node, parents: Node[]) {\n    return () => {\n      if (!object.value) {\n        return;\n      }\n      var chunks = splitIntoChunks(object.value, 5, 25);\n\n      var propIndex = parents.findIndex((x) => x.type == \"Property\");\n      if (propIndex != -1) {\n        if (parents[propIndex].key == (parents[propIndex - 1] || object)) {\n          parents[propIndex].computed = true;\n        }\n      }\n\n      if (this.strings[object.value]) {\n        this.replace(object, Identifier(this.strings[object.value]));\n        return;\n      }\n\n      if (\n        chunks.length >= 2 &&\n        chunks[1].length > 2 &&\n        ComputeProbabilityMap(\n          this.options.stringSplitting,\n          (x) => x,\n          object.value\n        )\n      ) {\n        this.log(\n          `'${object.value}' -> ${chunks.map((x) => `'${x}'`).join(\" + \")}`\n        );\n\n        if (Math.random() > 0.5) {\n          // use .join instead\n\n          if (!this.joinPrototype) {\n            this.joinPrototype = this.generateIdentifier();\n\n            var assignment = AssignmentExpression(\n              \"=\",\n              MemberExpression(\n                MemberExpression(Identifier(\"Array\"), Literal(\"prototype\")),\n                Identifier(this.joinPrototype),\n                false\n              ),\n              FunctionExpression(\n                [],\n                [\n                  ReturnStatement(\n                    CallExpression(\n                      MemberExpression(ThisExpression(), Literal(\"join\")),\n                      [Literal(\"\")]\n                    )\n                  ),\n                ]\n              )\n            );\n            prepend(\n              parents[parents.length - 1],\n              ExpressionStatement(assignment)\n            );\n          }\n\n          var arrayExpression = ArrayExpression(chunks.map(Literal));\n\n          this.replace(\n            object,\n            CallExpression(\n              MemberExpression(arrayExpression, Literal(this.joinPrototype)),\n              []\n            )\n          );\n        } else {\n          var newVar = this.getPlaceholder();\n\n          var adders = chunks\n            .slice(1)\n            .reverse()\n            .map((x) => {\n              return ExpressionStatement(\n                AssignmentExpression(\"+=\", Identifier(newVar), Literal(x))\n              );\n            });\n\n          this.adders.push(adders);\n          this.vars.push({\n            type: \"VariableDeclarator\",\n            id: Identifier(newVar),\n            init: Literal(chunks[0]),\n          });\n          this.strings[object.value] = newVar;\n\n          this.objectAssign(object, Identifier(newVar));\n        }\n      }\n    };\n  }\n}\n","import Transform, { reservedIdentifiers } from \"../transform\";\nimport {\n  Identifier,\n  Literal,\n  VariableDeclaration,\n  Node,\n  ArrayExpression,\n  MemberExpression,\n  VariableDeclarator,\n} from \"../../util/gen\";\nimport { prepend } from \"../../util/insert\";\nimport { ObfuscateOrder } from \"../../obfuscator\";\nimport { ComputeProbabilityMap } from \"../../index\";\nimport { isModuleSource } from \"../string/stringConcealing\";\n\nfunction isPrimitive(node: Node) {\n  if (node.type == \"Literal\") {\n    return { number: 1, string: 1, boolean: 1 }[typeof node.value];\n  } else if (node.type == \"Identifier\") {\n    return reservedIdentifiers.has(node.name);\n  }\n\n  return false;\n}\n\n/**\n * [Duplicate Literals Removal](https://docs.jscrambler.com/code-integrity/documentation/transformations/duplicate-literals-removal) replaces duplicate literals with a variable name.\n *\n * - Potency Medium\n * - Resilience Medium\n * - Cost Medium\n *\n * ```js\n * // Input\n * var foo = \"http://www.example.xyz\";\n * bar(\"http://www.example.xyz\");\n *\n * // Output\n * var a = \"http://www.example.xyz\";\n * var foo = a;\n * bar(a);\n * ```\n */\nexport default class DuplicateLiteralsRemoval extends Transform {\n  arrayName: string;\n  arrayExpression: Node;\n  map: Map<string, number>;\n  first: Map<string, Node[] | 0>;\n\n  constructor(o) {\n    super(o, ObfuscateOrder.DuplicateLiteralsRemoval);\n\n    this.map = new Map();\n    this.first = new Map();\n  }\n\n  match(object: Node, parents: Node[]) {\n    return isPrimitive(object) && !isModuleSource(object, parents);\n  }\n\n  toMember(object: Node, parents: Node[], index: number) {\n    this.replace(\n      object,\n      MemberExpression(Identifier(this.arrayName), Literal(index), true)\n    );\n  }\n\n  transform(object: Node, parents: Node[]) {\n    var value = object.value;\n    if (object.regex) {\n      return;\n    }\n\n    if (!ComputeProbabilityMap(this.options.duplicateLiteralsRemoval)) {\n      return;\n    }\n\n    if (\n      this.arrayName &&\n      parents[0].object &&\n      parents[0].object.name == this.arrayName\n    ) {\n      return;\n    }\n\n    var propertyIndex = parents.findIndex((x) => x.type == \"Property\");\n    if (propertyIndex != -1) {\n      if (\n        !parents[propertyIndex].computed &&\n        parents[propertyIndex].key == (parents[propertyIndex - 1] || object)\n      ) {\n        parents[propertyIndex].computed = true;\n      }\n    }\n\n    var value;\n    if (object.type == \"Literal\") {\n      value = typeof object.value + \":\" + object.value;\n    } else {\n      value = \"identifier:\" + object.name;\n    }\n\n    if (!this.first.has(value)) {\n      this.first.set(value, [object, ...parents]);\n    } else {\n      if (!this.arrayName) {\n        this.arrayName = this.getPlaceholder();\n        this.arrayExpression = ArrayExpression([]);\n\n        prepend(\n          parents[parents.length - 1] || object,\n          VariableDeclaration(\n            VariableDeclarator(this.arrayName, this.arrayExpression)\n          )\n        );\n      }\n\n      var first = this.first.get(value);\n      if (first) {\n        this.first.set(value, 0);\n        var index = this.map.size;\n        this.map.set(value, index);\n\n        this.toMember(first[0], first.slice(1), index);\n\n        this.arrayExpression.elements.push({ ...object });\n      }\n\n      this.toMember(object, parents, this.map.get(value));\n    }\n  }\n}\n","import { ok } from \"assert\";\r\nimport { ComputeProbabilityMap } from \"../index\";\r\nimport { ObfuscateOrder } from \"../obfuscator\";\r\nimport Template from \"../templates/template\";\r\nimport {\r\n  CallExpression,\r\n  ForStatement,\r\n  FunctionExpression,\r\n  Identifier,\r\n  Literal,\r\n  ReturnStatement,\r\n  UpdateExpression,\r\n  VariableDeclaration,\r\n  VariableDeclarator,\r\n} from \"../util/gen\";\r\nimport { clone } from \"../util/insert\";\r\nimport { getRandomInteger } from \"../util/random\";\r\nimport Transform from \"./transform\";\r\n\r\n/**\r\n * Shuffles arrays initial order of elements.\r\n *\r\n * \"Un-shuffles\" the array at runtime.\r\n */\r\nexport default class Shuffle extends Transform {\r\n  constructor(o) {\r\n    super(o, ObfuscateOrder.Shuffle);\r\n  }\r\n\r\n  match(object, parents) {\r\n    return object.type == \"ArrayExpression\";\r\n  }\r\n\r\n  transform(object, parents) {\r\n    if (object.elements.length < 3) {\r\n      // Min: 4 elements\r\n      return;\r\n    }\r\n\r\n    // Only arrays with only literals\r\n    var possible = !object.elements.find((x) => x.type != \"Literal\");\r\n\r\n    if (!possible) {\r\n      return;\r\n    }\r\n\r\n    if (ComputeProbabilityMap(this.options.shuffle)) {\r\n      return () => {\r\n        var shift = getRandomInteger(1, 100);\r\n\r\n        for (var i = 0; i < shift; i++) {\r\n          object.elements.push(object.elements.shift());\r\n        }\r\n\r\n        var name = this.getPlaceholder();\r\n\r\n        var code = [];\r\n\r\n        code.push(\r\n          ForStatement(\r\n            VariableDeclaration(VariableDeclarator(\"i\", Literal(shift))),\r\n            Identifier(\"i\"),\r\n            UpdateExpression(\"--\", Identifier(\"i\"), false),\r\n            [Template(`${name}.unshift(${name}.pop())`).single()]\r\n          )\r\n        );\r\n\r\n        if (!code.length) {\r\n          return;\r\n        }\r\n\r\n        var inPlace = false;\r\n\r\n        var varDeclarator = parents[0];\r\n        if (varDeclarator.type == \"VariableDeclarator\") {\r\n          var varDec = parents[2];\r\n          ok(varDec.type == \"VariableDeclaration\");\r\n\r\n          var body = parents[3];\r\n          if (varDec.declarations.length == 1 && Array.isArray(body)) {\r\n            inPlace = true;\r\n\r\n            var i = body.indexOf(varDec);\r\n            ok(i != -1);\r\n\r\n            body.splice(\r\n              i + 1,\r\n              0,\r\n              VariableDeclaration(\r\n                VariableDeclarator(name, Identifier(varDeclarator.id.name))\r\n              ),\r\n              ...code\r\n            );\r\n          }\r\n        }\r\n\r\n        if (!inPlace) {\r\n          this.replace(\r\n            object,\r\n            CallExpression(\r\n              FunctionExpression(\r\n                [Identifier(name)],\r\n                [...code, ReturnStatement(Identifier(name))]\r\n              ),\r\n              [clone(object)]\r\n            )\r\n          );\r\n        }\r\n      };\r\n    }\r\n  }\r\n}\r\n","import Transform from \"../transform\";\nimport { isBlock, getBlock, walk } from \"../../traverse\";\nimport {\n  Location,\n  ExpressionStatement,\n  SequenceExpression,\n  AssignmentExpression,\n  Literal,\n  Identifier,\n  Node,\n  VariableDeclaration,\n  VariableDeclarator,\n} from \"../../util/gen\";\nimport { deleteDeclaration, prepend } from \"../../util/insert\";\nimport { ok } from \"assert\";\nimport { ObfuscateOrder } from \"../../obfuscator\";\n\n/**\n * Defines all the names at the top of every lexical block.\n */\nexport default class MovedDeclarations extends Transform {\n  constructor(o) {\n    super(o, ObfuscateOrder.MovedDeclarations);\n  }\n\n  match(object, parents) {\n    return isBlock(object);\n  }\n\n  transform(object: Node, parents: Node[]) {\n    return () => {\n      var block = getBlock(object, parents);\n\n      var varDecs: Location[] = [];\n      var varNames: Set<string> = new Set();\n\n      walk(object, parents, (o: Node, p: Node[]) => {\n        var s = getBlock(o, p);\n        if (s != block) {\n          return;\n        }\n\n        if (o.type == \"VariableDeclaration\" && o.declarations.length) {\n          varDecs.push([o, p]);\n\n          o.declarations.forEach((declarator) => {\n            walk(declarator.id, [], (dO, dP) => {\n              if (dO.type == \"Identifier\") {\n                varNames.add(dO.name);\n              }\n            });\n          });\n\n          // Change this line to assignment expressions\n\n          var assignmentExpressions = o.declarations.map((x) =>\n            AssignmentExpression(\"=\", x.id, x.init || Identifier(\"undefined\"))\n          );\n\n          ok(assignmentExpressions.length, \"Should be at least 1\");\n\n          var value: Node = SequenceExpression(assignmentExpressions);\n          if (assignmentExpressions.length == 1) {\n            // If only 1, then single assignment expression\n            value = assignmentExpressions[0];\n          }\n\n          var forIndex = p.findIndex((x) => x.type == \"ForStatement\");\n          var inFor =\n            forIndex != -1 && p[forIndex].init == (p[forIndex - 1] || o);\n\n          if (!inFor) {\n            value = ExpressionStatement(value);\n          }\n\n          this.objectAssign(o, value);\n        }\n      });\n\n      // Define the names in this block as 1 variable declaration\n      if (varNames.size > 0) {\n        this.log(\"Moved\", varNames);\n\n        var switchCaseIndex = parents.findIndex((x) => x.type == \"SwitchCase\");\n        if (switchCaseIndex != -1) {\n          this.log(\"(Switch Edge Case)\", varNames);\n        }\n\n        var variableDeclaration = VariableDeclaration(\n          Array.from(varNames).map((x) => {\n            return VariableDeclarator(x);\n          })\n        );\n\n        prepend(block, variableDeclaration);\n      }\n    };\n  }\n}\n","import { ObfuscateOrder } from \"../obfuscator\";\r\nimport { walk } from \"../traverse\";\r\nimport { Identifier } from \"../util/gen\";\r\nimport { clone } from \"../util/insert\";\r\nimport { isLoop } from \"./preparation/preparation\";\r\nimport Transform from \"./transform\";\r\n\r\nexport default class RenameLabels extends Transform {\r\n  gen: any;\r\n\r\n  constructor(o) {\r\n    super(o, ObfuscateOrder.RenameLabels);\r\n\r\n    this.gen = this.getGenerator();\r\n  }\r\n\r\n  match(object, parents) {\r\n    return object.type == \"LabeledStatement\";\r\n  }\r\n\r\n  transform(object, parents) {\r\n    return () => {\r\n      var newName = null;\r\n\r\n      walk(object, parents, (o, p) => {\r\n        if (o.type == \"BreakStatement\" || o.type == \"ContinueStatement\") {\r\n          var labelStatement = p.find((x) => isLoop(x));\r\n\r\n          if (o.label && o.label.name == object.label.name) {\r\n            if (object.body == labelStatement) {\r\n              // In same loop\r\n\r\n              o.label = null;\r\n            } else {\r\n              if (!newName) {\r\n                newName = this.gen.generate();\r\n              }\r\n              o.label = Identifier(newName);\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      if (newName) {\r\n        object.label = Identifier(newName);\r\n      } else {\r\n        this.replace(object, clone(object.body));\r\n      }\r\n    };\r\n  }\r\n}\r\n","import Transform, { reservedIdentifiers } from \"./transform\";\nimport { ObfuscateOrder } from \"../obfuscator\";\nimport {\n  Node,\n  Location,\n  VariableDeclaration,\n  Identifier,\n  BinaryExpression,\n  ExpressionStatement,\n  SequenceExpression,\n  ForStatement,\n  Literal,\n  UpdateExpression,\n  UnaryExpression,\n  ConditionalExpression,\n  LogicalExpression,\n  BlockStatement,\n  ReturnStatement,\n  AssignmentExpression,\n  VariableDeclarator,\n} from \"../util/gen\";\nimport {\n  deleteDeclaration,\n  insertBefore,\n  deleteDirect,\n  getBlockBody,\n  isContext,\n  clone,\n} from \"../util/insert\";\nimport { getIdentifierInfo } from \"../util/identifiers\";\nimport { isValidIdentifier, isEquivalent } from \"../util/compare\";\nimport { walk, getBlock, isBlock } from \"../traverse\";\nimport { ok } from \"assert\";\n\nclass MinifyFlow extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object: Node, parents: Node[]) {\n    return isBlock(object) || object.type == \"SwitchCase\";\n  }\n\n  transform(object: Node, parents: Node[]) {\n    var body =\n      object.type == \"SwitchCase\" ? object.consequent : getBlockBody(object);\n    var earlyReturn = body.length;\n\n    body.forEach((stmt, i) => {\n      if (\n        stmt.type == \"ReturnStatement\" ||\n        stmt.type == \"BreakStatement\" ||\n        stmt.type == \"ContinueStatement\"\n      ) {\n        if (earlyReturn > i + 1) {\n          earlyReturn = i + 1;\n        }\n      }\n    });\n\n    body.length = earlyReturn;\n  }\n}\n\nclass MinifyBlock extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object: Node, parents: Node[]) {\n    return isBlock(object);\n  }\n\n  transform(object: Node, parents: Node[]) {\n    return () => {\n      // 1. Check for dead code (early return)\n      // 2. Check for re-assigning just-defined variable\n\n      var justDefined = new Set();\n      var decs: { [name: string]: Node } = Object.create(null);\n\n      var body = getBlockBody(object);\n      var earlyReturn = body.length;\n\n      var remove = [];\n      body.forEach((stmt, i) => {\n        if (\n          stmt.type == \"ReturnStatement\" ||\n          stmt.type == \"BreakStatement\" ||\n          stmt.type == \"ContinueStatement\"\n        ) {\n          if (earlyReturn > i + 1) {\n            earlyReturn = i + 1;\n          }\n        }\n        if (stmt.type == \"VariableDeclaration\") {\n          stmt.declarations.forEach((x) => {\n            if (x.id.type == \"Identifier\") {\n              justDefined.add(x.id.name);\n              decs[x.id.name] = x;\n            }\n          });\n        } else if (stmt.type == \"ExpressionStatement\") {\n          if (stmt.expression.type == \"AssignmentExpression\") {\n            var name = stmt.expression.left.name;\n            if (stmt.expression.operator == \"=\" && justDefined.has(name)) {\n              var possible = true;\n              walk(stmt.expression.right, [], (o, p) => {\n                if (\n                  o.type == \"Identifier\" &&\n                  !reservedIdentifiers.has(o.name) &&\n                  !this.options.globalVariables.has(o.name)\n                ) {\n                  var info = getIdentifierInfo(o, p);\n                  if (\n                    info.spec.isDefined ||\n                    info.spec.isModified ||\n                    info.spec.isReferenced\n                  ) {\n                    if (justDefined.has(o.name)) {\n                      possible = false;\n                    }\n                  }\n                }\n              });\n\n              if (possible) {\n                decs[name].init = stmt.expression.right;\n                remove.unshift(i);\n              }\n            }\n          }\n        }\n      });\n\n      body.length = earlyReturn;\n\n      remove.forEach((x) => {\n        body.splice(x, 1);\n      });\n\n      // Now combine ExpressionStatements\n\n      if (body.length > 1) {\n        var exprs = [];\n        var startIndex = -1;\n\n        var sequences: { index: number; exprs: Node[] }[] = [];\n\n        body.forEach((stmt, i) => {\n          if (stmt.type == \"ExpressionStatement\") {\n            exprs.push(stmt.expression);\n            if (startIndex == -1) {\n              startIndex = i;\n            }\n          } else {\n            if (exprs.length) {\n              sequences.push({ exprs: exprs, index: startIndex });\n            }\n            exprs = [];\n            startIndex = -1;\n          }\n        });\n\n        if (exprs.length) {\n          sequences.push({ exprs: exprs, index: startIndex });\n        }\n\n        sequences.reverse().forEach((seq) => {\n          ok(seq.index != -1);\n          body.splice(\n            seq.index,\n            seq.exprs.length,\n            ExpressionStatement(\n              seq.exprs.length == 1\n                ? seq.exprs[0]\n                : SequenceExpression(seq.exprs)\n            )\n          );\n        });\n      }\n\n      // Unnecessary return\n      if (body.length && body[body.length - 1]) {\n        var last = body[body.length - 1];\n        var isUndefined = last.argument == null;\n        if (last.type == \"ReturnStatement\" && isUndefined) {\n          body.pop();\n        }\n      }\n\n      // Part 3\n      var stmts = getBlockBody(object);\n      var lastDec = null;\n\n      var remove = [];\n\n      stmts.forEach((x, i) => {\n        if (x.type == \"VariableDeclaration\") {\n          if (!lastDec) {\n            lastDec = x;\n          } else {\n            lastDec.declarations.push(...x.declarations);\n            remove.unshift(i);\n          }\n        } else {\n          lastDec = null;\n        }\n      });\n\n      remove.forEach((x) => {\n        stmts.splice(x, 1);\n      });\n    };\n  }\n}\n\n/**\n * Basic transformations to reduce code size.\n *\n * Examples:\n * - `if(a) { b() }` **->** `a && b()`\n * - `if(a){b()}else{c()}` **->** `a?b():c()`\n * - `x['y']` **->** `x.y`\n */\nexport default class Minify extends Transform {\n  variables: Map<Node, Location[]>;\n\n  constructor(o) {\n    super(o, ObfuscateOrder.Minify);\n\n    this.variables = new Map();\n\n    /**\n     * Minify runs at every Node, making Expression-based minification.\n     * MinifyBlock runs only on Blocks, making Statement-based minification.\n     */\n    this.after.push(new MinifyBlock(o));\n    this.after.push(new MinifyFlow(o));\n  }\n\n  match(object: Node, parents: Node[]) {\n    return object.hasOwnProperty(\"type\");\n  }\n\n  transform(object: Node, parents: Node[]) {\n    /**\n     * ES6 and higher only\n     * - `function(){}` -> `()=>{}`\n     * - `function abc(){}` -> `var abc = ()=>{}`\n     */\n    if (\n      !this.options.es5 &&\n      (object.type == \"FunctionExpression\" ||\n        object.type == \"FunctionDeclaration\")\n    ) {\n      return () => {\n        var canTransform = true;\n        walk(object.body, [], ($object, $parents) => {\n          if ($object.type == \"ThisExpression\") {\n            canTransform = false;\n          } else if ($object.type == \"Identifier\") {\n            if ($object.name == \"arguments\") {\n              canTransform = false;\n            }\n            if ($object.name == \"this\") {\n              this.error(new Error(\"Use ThisExpression instead\"));\n            }\n          }\n        });\n\n        if (canTransform) {\n          if (object.type == \"FunctionExpression\") {\n            object.type = \"ArrowFunctionExpression\";\n          } else {\n            var arrow = { ...clone(object), type: \"ArrowFunctionExpression\" };\n            this.replace(\n              object,\n              VariableDeclaration(VariableDeclarator(object.id.name, arrow))\n            );\n\n            var x = this.transform(arrow, []);\n            x();\n          }\n        }\n      };\n    }\n\n    /**\n     * ()=>{ expr } -> ()=>expr\n     */\n    if (\n      object.type == \"ArrowFunctionExpression\" &&\n      object.body.type == \"BlockStatement\"\n    ) {\n      return () => {\n        var body = getBlockBody(object.body);\n        var stmt1 = body[0];\n\n        if (body.length == 1 && stmt1.type == \"ReturnStatement\") {\n          // x=>{a: 1} // Invalid syntax\n          if (stmt1.argument.type != \"ObjectExpression\") {\n            object.body = stmt1.argument;\n          }\n        } else {\n          // ()=>{exprStmt;exprStmt;} -> ()=>(expr, expr, expr, undefined)\n          var exprs = body.filter((x) => x.type == \"ExpressionStatement\");\n          if (exprs.length == body.length) {\n            var array: Node[] = [];\n            function flatten(expr) {\n              if (expr.type == \"SequenceExpression\") {\n                expr.expressions.forEach(flatten);\n              } else if (expr.type == \"ExpressionStatement\") {\n                flatten(expr.expression);\n              } else {\n                array.push(expr);\n              }\n            }\n\n            body.forEach(flatten);\n\n            object.body = SequenceExpression([\n              ...clone(array),\n              UnaryExpression(\"void\", Literal(0)),\n            ]);\n          }\n        }\n      };\n    }\n\n    // (a()) -> a()\n    if (object.type == \"SequenceExpression\") {\n      return () => {\n        if (object.expressions.length == 1) {\n          this.replace(object, clone(object.expressions[0]));\n        }\n      };\n    }\n\n    // a += -1 -> a -= 1\n    if (object.type == \"AssignmentExpression\") {\n      return () => {\n        if (\n          object.operator == \"+=\" &&\n          object.right.type == \"UnaryExpression\" &&\n          object.right.operator == \"-\"\n        ) {\n          object.operator = \"-=\";\n          object.right = object.right.argument;\n        }\n      };\n    }\n\n    if (\n      object.type == \"ForStatement\" ||\n      object.type == \"ForInStatement\" ||\n      object.type == \"ForOfStatement\" ||\n      object.type == \"WhileStatement\"\n    ) {\n      if (object.body.type == \"BlockStatement\") {\n        return () => {\n          if (object.body.body.length === 1) {\n            object.body = clone(object.body.body[0]);\n          }\n        };\n      }\n    }\n\n    // Last switch case does not need break\n    if (object.type == \"SwitchStatement\") {\n      var last = object.cases[object.cases.length - 1];\n      if (last) {\n        var lastStatement = last.consequent[last.consequent.length - 1];\n        if (\n          lastStatement.type == \"BreakStatement\" &&\n          lastStatement.label == null\n        ) {\n          last.consequent.pop();\n        }\n      } else {\n        if (object.cases.length == 0) {\n          if (\n            parents[0].type == \"LabeledStatement\" &&\n            Array.isArray(parents[1])\n          ) {\n            return () => {\n              parents[1].splice(parents[1].indexOf(parents[0]), 1);\n            };\n          } else if (Array.isArray(parents[0])) {\n            return () => {\n              parents[0].splice(parents[0].indexOf(object), 1);\n            };\n          }\n        }\n      }\n    }\n\n    // if ( x ) { y() } -> x && y()\n    // Todo Make this shit readable\n    if (object.type == \"IfStatement\") {\n      if (object.consequent.type != \"BlockStatement\") {\n        this.replace(\n          object.consequent,\n          BlockStatement([clone(object.consequent)])\n        );\n      }\n      if (object.alternate && object.alternate.type != \"BlockStatement\") {\n        this.replace(\n          object.alternate,\n          BlockStatement([clone(object.alternate)])\n        );\n      }\n      var body = getBlockBody(object.consequent);\n\n      // Check for hard-coded if statements\n      if (object.test.type == \"Literal\") {\n        if (object.test.value || object.test.regex) {\n          // Why would anyone test just a regex literal\n          object.alternate = null;\n        } else {\n          object.consequent = BlockStatement([]);\n        }\n      }\n\n      return () => {\n        // if ( a ) { } else {b()} -> if ( !a ) b();\n        if (body.length == 0 && object.alternate) {\n          object.test = UnaryExpression(\"!\", clone(object.test));\n          if (\n            object.alternate.type == \"BlockStatement\" &&\n            object.alternate.body.length == 1\n          ) {\n            object.alternate = clone(object.alternate.body[0]);\n          }\n          object.consequent = object.alternate;\n          object.alternate = null;\n        }\n\n        if (\n          object.consequent.body.length == 1 &&\n          object.alternate &&\n          object.alternate.body.length == 1\n        ) {\n          var stmt1 = clone(object.consequent.body[0]);\n          var stmt2 = clone(object.alternate.body[0]);\n\n          // if (a) {return b;} else {return c;} -> return a ? b : c;\n          if (\n            stmt1.type == \"ReturnStatement\" ||\n            stmt2.type == \"ReturnStatement\"\n          ) {\n            this.replace(\n              object,\n              ReturnStatement(\n                ConditionalExpression(\n                  clone(object.test),\n                  stmt1.argument,\n                  stmt2.argument\n                )\n              )\n            );\n          }\n\n          // if (a) {b = 0} else {b = 1} -> b = a ? 0 : 1;\n          if (\n            stmt1.type == \"ExpressionStatement\" &&\n            stmt2.type == \"ExpressionStatement\"\n          ) {\n            var e1 = stmt1.expression;\n            var e2 = stmt2.expression;\n\n            if (\n              e1.type == \"AssignmentExpression\" &&\n              e2.type == \"AssignmentExpression\"\n            ) {\n              if (\n                e1.operator == e2.operator &&\n                isEquivalent(e1.left, e2.left)\n              ) {\n                this.replace(\n                  object,\n                  ExpressionStatement(\n                    AssignmentExpression(\n                      e1.operator,\n                      e1.left,\n                      ConditionalExpression(\n                        clone(object.test),\n                        e1.right,\n                        e2.right\n                      )\n                    )\n                  )\n                );\n              }\n            }\n          }\n        }\n      };\n    }\n\n    // x[\"abc\"] -> x.abc\n    if (object.type == \"MemberExpression\") {\n      var { object: obj, property } = object;\n\n      if (property.type == \"Literal\" && isValidIdentifier(property.value)) {\n        object.computed = false;\n        object.property.type = \"Identifier\";\n        object.property.name = clone(object.property.value);\n\n        obj.name &&\n          this.log(\n            obj.name +\n              \"['\" +\n              object.property.name +\n              \"'] -> \" +\n              obj.name +\n              \".\" +\n              object.property.name\n          );\n      }\n    }\n\n    if (object.type == \"CallExpression\") {\n      if (object.callee.type == \"MemberExpression\") {\n        var key = object.callee.computed\n          ? object.callee.property.value\n          : object.callee.property.name;\n        if (key == \"toString\" && object.arguments.length == 0) {\n          this.replace(\n            object,\n            BinaryExpression(\"+\", clone(object.callee.object), Literal(\"\"))\n          );\n        }\n      }\n    }\n\n    // { \"x\": 1 } -> {x: 1}\n    if (object.type == \"Property\") {\n      if (\n        object.key.type == \"SequenceExpression\" &&\n        object.key.expressions.length == 1\n      ) {\n        object.key = object.key.expressions[0];\n        object.computed = true;\n      }\n\n      if (object.key.type == \"Literal\" && isValidIdentifier(object.key.value)) {\n        object.key.type = \"Identifier\";\n        object.key.name = object.key.value;\n        object.computed = false;\n      } else if (\n        object.key.type == \"Identifier\" &&\n        !isValidIdentifier(object.key.name)\n      ) {\n        object.key = Literal(object.key.name);\n      }\n    }\n\n    if (object.type == \"VariableDeclarator\") {\n      // undefined is not necessary\n      if (object.init && object.init.type == \"Identifier\") {\n        if (object.init.name == \"undefined\") {\n          object.init = null;\n        }\n      }\n\n      // check for redundant patterns\n      if (\n        object.id.type == \"ArrayPattern\" &&\n        object.init.type == \"ArrayExpression\"\n      ) {\n        if (\n          object.id.elements.length == 1 &&\n          object.init.elements.length == 1\n        ) {\n          object.id = object.id.elements[0];\n          object.init = object.init.elements[0];\n        }\n      }\n    }\n\n    if (object.type == \"Literal\") {\n      return () => {\n        switch (typeof object.value) {\n          case \"boolean\":\n            // this.replace(object, UnaryExpression(\"!\", Literal(object.value ? 0 : 1)));\n            break;\n        }\n      };\n    }\n    if (object.type == \"Identifier\") {\n      return () => {\n        if (object.name == \"undefined\") {\n          this.replace(object, UnaryExpression(\"void\", Literal(0)));\n        } else if (object.name == \"Infinity\") {\n          this.replace(object, BinaryExpression(\"/\", Literal(1), Literal(0)));\n        }\n      };\n    }\n\n    if (object.type == \"UnaryExpression\" && object.operator == \"!\") {\n      if (object.argument.type == \"Literal\" && !object.argument.regex) {\n        this.replace(object, Literal(!object.argument.value));\n      }\n    }\n\n    if (object.type == \"ConditionalExpression\") {\n      if (object.test.type == \"Literal\" && !object.test.regex) {\n        this.replace(\n          object,\n          object.test.value ? object.consequent : object.alternate\n        );\n      }\n    }\n  }\n}\n","import Transform, { reservedIdentifiers, reservedKeywords } from \"./transform\";\nimport {\n  Node,\n  ExpressionStatement,\n  UnaryExpression,\n  Literal,\n  VariableDeclaration,\n  SequenceExpression,\n  AssignmentExpression,\n  Identifier,\n  MemberExpression,\n  BlockStatement,\n  ReturnStatement,\n  CallExpression,\n  ArrayPattern,\n  ObjectExpression,\n  ArrayExpression,\n  BinaryExpression,\n  ConditionalExpression,\n  ThisExpression,\n  VariableDeclarator,\n} from \"../util/gen\";\nimport { clone, getBlockBody, getIndexDirect, prepend } from \"../util/insert\";\nimport { isBlock, getBlock, walk } from \"../traverse\";\nimport Template from \"../templates/template\";\nimport { ObfuscateOrder } from \"../obfuscator\";\nimport { ok } from \"assert\";\n\n/**\n * `Const` and `Let` are not allowed in ES5.\n */\nclass AntiConstLet extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object, parents) {\n    return object.type == \"VariableDeclaration\" && object.kind != \"var\";\n  }\n\n  transform(object) {\n    object.kind = \"var\";\n  }\n}\n\nclass AntiParameters extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object: Node, parents: Node[]) {\n    return (object.param || object.params) && object.body;\n  }\n\n  transform(object: Node, parents: Node[]) {\n    if (object.param) {\n      // Catch clause\n      if (object.param.type != \"Identifier\") {\n        var catchName = this.getPlaceholder();\n        var cloned = { ...object.param };\n\n        object.param = Identifier(catchName);\n\n        getBlockBody(object.body).unshift(\n          VariableDeclaration([\n            VariableDeclarator(cloned, Identifier(catchName)),\n          ])\n        );\n      }\n\n      return;\n    }\n\n    // For function parameters\n    var isDestructed = false;\n    var parameters = object.params;\n\n    walk(parameters, parents, (o, p) => {\n      if (\n        o.type == \"ArrayPattern\" ||\n        o.type == \"ObjectPattern\" ||\n        o.type == \"AssignmentPattern\" ||\n        o.type == \"RestElement\"\n      ) {\n        isDestructed = true;\n      }\n    });\n\n    if (isDestructed) {\n      object.params = [];\n      if (object.body.type != \"BlockStatement\") {\n        object.body = BlockStatement([ReturnStatement({ ...object.body })]);\n      }\n      getBlockBody(object.body).unshift({\n        type: \"VariableDeclaration\",\n        declarations: [\n          {\n            type: \"VariableDeclarator\",\n            id: ArrayPattern(parameters),\n            init: Template(`Array.prototype.slice.call(arguments)`).single()\n              .expression,\n          },\n        ],\n      });\n    }\n  }\n}\n\n/**\n * Removes destructuring so the script can work in ES5 environments.\n */\nclass AntiDestructuring extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object: Node, parents: Node[]) {\n    return (\n      object.type == \"AssignmentExpression\" ||\n      object.type == \"VariableDeclarator\"\n    );\n  }\n\n  transform(object: Node, parents: Node[]) {\n    var block = getBlock(object, parents);\n\n    var body = getBlockBody(block);\n\n    var temp = this.getPlaceholder();\n\n    var exprs = [];\n    var names: Set<string> = new Set();\n    var operator = \"=\";\n\n    var id = null; // The object being set\n    var extracting = null; // The object being extracted from\n    if (object.type == \"AssignmentExpression\") {\n      id = object.left;\n      extracting = object.right;\n      operator = object.operator;\n    } else if (object.type == \"VariableDeclarator\") {\n      id = object.id;\n      extracting = object.init;\n    } else {\n      ok(false);\n    }\n\n    var should = false;\n    walk(id, [], (o, p) => {\n      if (o.type && o.type.includes(\"Pattern\")) {\n        should = true;\n      }\n    });\n\n    if (should) {\n      prepend(\n        block,\n        VariableDeclaration([VariableDeclarator(Identifier(temp))])\n      );\n\n      const recursive = (x: Node, realm: Node) => {\n        realm = clone(realm);\n\n        if (x.type == \"Identifier\") {\n          exprs.push(AssignmentExpression(operator, clone(x), realm));\n\n          names.add(x.name);\n        } else if (x.type == \"ObjectPattern\") {\n          x.properties.forEach((property) => {\n            recursive(\n              property.value,\n              MemberExpression(realm, property.key, property.computed)\n            );\n          });\n        } else if (x.type == \"ArrayPattern\") {\n          x.elements.forEach((element, i) => {\n            if (element) {\n              if (element.type == \"RestElement\") {\n                if (i != x.elements.length - 1) {\n                  this.error(\n                    new Error(\n                      \"Uncaught SyntaxError: Rest element must be last element\"\n                    )\n                  );\n                }\n                recursive(\n                  element.argument,\n                  CallExpression(\n                    MemberExpression(realm, Identifier(\"slice\"), false),\n                    [Literal(i)]\n                  )\n                );\n              } else {\n                recursive(element, MemberExpression(realm, Literal(i), true));\n              }\n            }\n          });\n        } else if (x.type == \"AssignmentPattern\") {\n          var condition = ConditionalExpression(\n            BinaryExpression(\"==\", realm, Identifier(\"undefined\")),\n            x.right,\n            realm\n          );\n          recursive(x.left, condition);\n        } else {\n          throw new Error(\"unknown type: \" + x.type);\n        }\n      };\n\n      recursive(id, Identifier(temp));\n\n      return () => {\n        var seq = SequenceExpression([\n          AssignmentExpression(\n            \"=\",\n            Identifier(temp),\n            clone(extracting) || Identifier(\"undefined\")\n          ),\n          ...exprs,\n        ]);\n\n        if (object.type == \"VariableDeclarator\") {\n          var i = getIndexDirect(object, parents);\n\n          var extra = Array.from(names).map((x) => {\n            return {\n              type: \"VariableDeclarator\",\n              id: Identifier(x),\n              init: null,\n            };\n          });\n\n          extra.push({\n            type: \"VariableDeclarator\",\n            id: Identifier(this.getPlaceholder()),\n            init: seq,\n          });\n\n          parents[0].splice(i, 1, ...extra);\n        } else {\n          this.replace(object, seq);\n        }\n      };\n    }\n  }\n}\n\n/**\n * Converts arrow functions\n */\nexport class AntiArrow extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object, parents) {\n    return object.type == \"ArrowFunctionExpression\";\n  }\n\n  transform(object, parents) {\n    var usesThis = false;\n\n    if (object.body.type != \"BlockStatement\") {\n      if (object.body.type == \"ExpressionStatement\") {\n        object.body = BlockStatement([\n          ReturnStatement(clone(object.body.expression)),\n        ]);\n      } else if (object.body.type == \"ReturnStatement\") {\n        object.body = BlockStatement([clone(object.body)]);\n      } else {\n        object.body = BlockStatement([ReturnStatement(clone(object.body))]);\n      }\n    }\n\n    walk(object.body, [object, ...parents], (o, p) => {\n      if (p.filter((x) => isBlock(x))[0] == object.body) {\n        if (\n          o.type == \"ThisExpression\" ||\n          (o.type == \"Identifier\" && o.name == \"this\")\n        ) {\n          usesThis = true;\n        }\n      }\n    });\n\n    ok(object.body.type == \"BlockStatement\", \"Should be a BlockStatement\");\n    ok(Array.isArray(object.body.body), \"Body should be an array\");\n    ok(\n      !object.body.body.find((x) => Array.isArray(x)),\n      \"All elements should be statements\"\n    );\n\n    object.type = \"FunctionExpression\";\n    object.expression = false;\n\n    if (usesThis) {\n      this.objectAssign(\n        object,\n        CallExpression(\n          MemberExpression(clone(object), Identifier(\"bind\"), false),\n          [ThisExpression()]\n        )\n      );\n    }\n  }\n}\n\nvar HelperFunctions = Template(\n  `\n  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n  \n  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n  \n  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n  `\n);\n\nclass AntiES6Object extends Transform {\n  makerFn: string;\n  helper: boolean;\n\n  constructor(o) {\n    super(o);\n\n    this.makerFn = null;\n    this.helper = false;\n  }\n\n  match(object: Node, parents: Node[]) {\n    return object.type == \"ObjectExpression\";\n  }\n\n  transform(object: Node, parents: Node[]) {\n    return () => {\n      var block = getBlock(object, parents);\n      var needsChanging = false;\n\n      object.properties.forEach((property) => {\n        if (property.type == \"SpreadElement\") {\n          return;\n        }\n\n        // AntiShorthand\n        object.shorthand = false;\n\n        if (!property.key) {\n          this.error(new Error(\"Property missing key\"));\n        }\n\n        if (![\"Literal\", \"Identifier\"].includes(property.key.type)) {\n          property.computed = true;\n        }\n\n        if (property.computed && property.key.type == \"Literal\") {\n          property.computed = false;\n        }\n\n        if (property.kind != \"init\" || property.method || property.computed) {\n          needsChanging = true;\n        }\n      });\n\n      if (needsChanging) {\n        if (!this.makerFn) {\n          this.makerFn = this.getPlaceholder();\n\n          prepend(\n            parents[parents.length - 1] || block,\n            Template(`\n            function {name}(base, computedProps, descriptors){\n\n              for ( var i = 0; i < computedProps.length; i++ ) {\n                base[computedProps[i][0]] = computedProps[i][1];\n              }\n\n              for ( var i = 0; i < descriptors.length; i++ ) {\n                Object.defineProperty(base, descriptors[i][0], {\n                  set: descriptors[i][1],\n                  get: descriptors[i][2],\n                  configurable: true\n                });\n              }\n\n              return base; \n            }\n          `).single({ name: this.makerFn })\n          );\n        }\n\n        /** {a: 1} Es5 compliant properties */\n        var baseProps = [];\n        /** {[a]: 1} -> Computed props to array [a, 1] */\n        var computedProps = [];\n        /** {get a(){}} -> Property descriptors */\n        var descriptors = [];\n\n        object.properties.forEach((prop) => {\n          var key = prop.key;\n          if (!key) {\n            return;\n          }\n\n          if (key.type == \"Identifier\" && !prop.computed) {\n            key = Literal(key.name);\n          }\n\n          if (prop.computed) {\n            var array = [prop.key, prop.value];\n\n            computedProps.push(ArrayExpression(array));\n          } else if (prop.kind == \"get\" || prop.kind == \"set\") {\n            var array = [key, Identifier(\"undefined\"), Identifier(\"undefined\")];\n            if (prop.kind == \"get\") {\n              array[2] = prop.value;\n            } else {\n              array[1] = prop.value;\n            }\n            descriptors.push(array);\n          } else {\n            prop.method = false;\n\n            baseProps.push(prop);\n          }\n        });\n\n        if (descriptors.length || computedProps.length) {\n          this.objectAssign(\n            object,\n            CallExpression(Identifier(this.makerFn), [\n              ObjectExpression(baseProps),\n              ArrayExpression(computedProps),\n              ArrayExpression(descriptors.map((x) => ArrayExpression(x))),\n            ])\n          );\n        }\n      }\n    };\n  }\n}\n\nclass FixedExpressions extends Transform {\n  constructor(o) {\n    super(o);\n  }\n\n  match(object, parents) {\n    return true;\n  }\n\n  transform(object, parents) {\n    if (\n      object.type == \"ForStatement\" &&\n      object.init.type == \"ExpressionStatement\"\n    ) {\n      object.init = object.init.expression;\n    }\n\n    if (object.type == \"MemberExpression\") {\n      if (!object.computed && object.property.type == \"Identifier\") {\n        if (reservedKeywords.has(object.property.name)) {\n          object.property = Literal(object.property.name);\n          object.computed = true;\n        }\n      }\n    }\n\n    if (object.type == \"Property\") {\n      if (!object.computed && object.key.type == \"Identifier\") {\n        if (reservedIdentifiers.has(object.key.name)) {\n          object.key = Literal(object.key.name);\n        }\n      }\n    }\n  }\n}\n\nexport default class ES5 extends Transform {\n  constructor(o) {\n    super(o, ObfuscateOrder.ES5);\n\n    this.before.push(new AntiES6Object(o));\n    this.before.push(new AntiArrow(o));\n    this.before.push(new AntiParameters(o));\n    this.before.push(new AntiDestructuring(o));\n    this.before.push(new AntiConstLet(o));\n\n    this.concurrent.push(new FixedExpressions(o));\n  }\n\n  match(object: Node, parents: Node[]) {\n    return object.type == \"Program\";\n  }\n\n  transform(object: Node, parents: Node[]) {\n    var block = getBlock(object, parents);\n\n    getBlockBody(block).splice(\n      0,\n      0,\n      ...Template(`\n    !Array.prototype.forEach ? Array.prototype.forEach = function (callback, thisArg) {\n      thisArg = thisArg;\n      for (var i = 0; i < this.length; i++) {\n          callback.call(thisArg, this[i], i, this);\n      }\n    } : 0;\n  \n    !Array.prototype.map ? Array.prototype.map = function (callback, thisArg) {\n      thisArg = thisArg;\n      var array=[];\n      for (var i = 0; i < this.length; i++) {\n        array.push( callback.call(thisArg, this[i], i, this) );\n      }\n      return array;\n    } : 0;\n\n    !Array.prototype.reduce ? Array.prototype.reduce = function(fn, initial) {\n      var values = this;\n      if ( typeof initial === \"undefined\" ) {\n        initial = 0;\n      }\n\n      values.forEach(function(item, index){\n        initial = fn(initial, item, index, this);\n      });\n\n      return initial;\n    } : 0;\n  `).compile()\n    );\n  }\n}\n","import Transform from \"../transform\";\nimport { choice } from \"../../util/random\";\nimport { Identifier } from \"../../util/gen\";\nimport { ObfuscateOrder } from \"../../obfuscator\";\n\nfunction pad(x: string, len: number): string {\n  while (x.length < len) {\n    x = \"0\" + x;\n  }\n  return x;\n}\n\nfunction even(x: string) {\n  if (x.length % 2 != 0) {\n    return \"0\" + x;\n  }\n  return x;\n}\n\nfunction toHexRepresentation(str: string) {\n  var escapedString = \"\";\n  str.split(\"\").forEach((char) => {\n    var code = char.charCodeAt(0);\n    escapedString += \"\\\\x\" + even(pad(code.toString(16), 2));\n  });\n\n  return escapedString;\n}\n\nfunction toUnicodeRepresentation(str: string) {\n  var escapedString = \"\";\n  str.split(\"\").forEach((char) => {\n    var code = char.charCodeAt(0);\n    escapedString += \"\\\\u\" + even(pad(code.toString(16), 4));\n  });\n\n  return escapedString;\n}\n\n/**\n * [String Encoding](https://docs.jscrambler.com/code-integrity/documentation/transformations/string-encoding) transforms a string into an encoded representation.\n *\n * - Potency Low\n * - Resilience Low\n * - Cost Low\n */\nexport default class StringEncoding extends Transform {\n  seen: Set<Node>;\n\n  constructor(o) {\n    super(o, ObfuscateOrder.StringEncoding);\n  }\n\n  apply(tree) {\n    this.seen = new Set();\n    super.apply(tree);\n  }\n\n  match(object, parents) {\n    return object.type == \"Literal\" && typeof object.value === \"string\";\n  }\n\n  transform(object, parents) {\n    // Todo fix circular json problems\n    if (this.seen.has(object)) {\n      return;\n    }\n    this.seen.add(object);\n\n    var type = choice([\"hexadecimal\", \"unicode\"]);\n\n    var escapedString = (\n      type == \"hexadecimal\" ? toHexRepresentation : toUnicodeRepresentation\n    )(object.value);\n\n    // escodegen tries to escape backslashes, here is a work-around\n    this.replace(object, {\n      type: \"Identifier\",\n      name: `'${escapedString}'`,\n    });\n  }\n}\n","import { ok } from \"assert\";\r\nimport { EventEmitter } from \"events\";\r\nimport { Node } from \"./util/gen\";\r\nimport traverse from \"./traverse\";\r\nimport {\r\n  ObfuscateOptions,\r\n  ProbabilityMap,\r\n  isProbabilityMapProbable,\r\n} from \"./index\";\r\n\r\nimport Transform from \"./transforms/transform\";\r\n\r\nimport Preparation from \"./transforms/preparation/preparation\";\r\nimport ObjectExtraction from \"./transforms/extraction/objectExtraction\";\r\nimport Lock from \"./transforms/lock/lock\";\r\nimport Dispatcher from \"./transforms/dispatcher\";\r\nimport DeadCode from \"./transforms/deadCode\";\r\nimport OpaquePredicates from \"./transforms/opaquePredicates\";\r\nimport Calculator from \"./transforms/calculator\";\r\nimport ControlFlowFlattening from \"./transforms/controlFlowFlattening\";\r\nimport Eval from \"./transforms/eval\";\r\nimport GlobalConcealing from \"./transforms/identifier/globalConcealing\";\r\nimport StringConcealing from \"./transforms/string/stringConcealing\";\r\nimport StringSplitting from \"./transforms/string/stringSplitting\";\r\nimport DuplicateLiteralsRemoval from \"./transforms/extraction/duplicateLiteralsRemoval\";\r\nimport Shuffle from \"./transforms/shuffle\";\r\nimport MovedDeclarations from \"./transforms/identifier/movedDeclarations\";\r\nimport RenameVariables from \"./transforms/identifier/renameVariables\";\r\nimport RenameLabels from \"./transforms/renameLabels\";\r\nimport Minify from \"./transforms/minify\";\r\nimport ES5 from \"./transforms/es5\";\r\nimport StringEncoding from \"./transforms/string/stringEncoding\";\r\nimport RGF from \"./transforms/rgf\";\r\nimport Flatten from \"./transforms/flatten\";\r\n\r\n/**\r\n * Describes the order of transformations.\r\n */\r\nexport enum ObfuscateOrder {\r\n  Preparation = 0,\r\n\r\n  ObjectExtraction = 1,\r\n\r\n  Lock = 2, // Includes Integrity & Anti Debug\r\n\r\n  Dispatcher = 3,\r\n\r\n  OpaquePredicates = 4,\r\n  DeadCode = 5,\r\n\r\n  Calculator = 6,\r\n\r\n  // Fixes all If Statements\r\n  ControlFlowFlattening = 7,\r\n\r\n  Flatten = 7,\r\n  RGF = 8,\r\n\r\n  // Optional\r\n  Eval = 8,\r\n\r\n  GlobalConcealing = 9,\r\n\r\n  // Hides all strings\r\n  StringConcealing = 10,\r\n\r\n  StringSplitting = 20,\r\n\r\n  DuplicateLiteralsRemoval = 23,\r\n\r\n  Shuffle = 24,\r\n\r\n  MovedDeclarations = 25,\r\n\r\n  RenameVariables = 26,\r\n\r\n  RenameLabels = 27,\r\n\r\n  Minify = 30,\r\n\r\n  ES5 = 31,\r\n\r\n  StringEncoding = 32,\r\n}\r\n\r\n/**\r\n * The parent transformation holding the `state`.\r\n */\r\nexport default class Obfuscator extends EventEmitter {\r\n  varCount: number;\r\n  transforms: { [name: string]: Transform };\r\n  array: Transform[];\r\n\r\n  state: \"transform\" | \"eval\" = \"transform\";\r\n\r\n  constructor(public options: ObfuscateOptions) {\r\n    super();\r\n\r\n    this.varCount = 0;\r\n    this.transforms = Object.create(null);\r\n\r\n    this.push(new Preparation(this));\r\n    this.push(new RenameLabels(this));\r\n\r\n    const test = <T>(map: ProbabilityMap<T>, ...transformers: any[]) => {\r\n      if (isProbabilityMapProbable(map)) {\r\n        // options.verbose && console.log(\"+ Added \" + transformer.name);\r\n\r\n        transformers.forEach((Transformer) => this.push(new Transformer(this)));\r\n      } else {\r\n        // options.verbose && console.log(\"- Skipped adding \" + transformer.name);\r\n      }\r\n    };\r\n\r\n    // Optimization: Only add needed transformers. If a probability always return false, no need in running that extra code.\r\n    test(options.objectExtraction, ObjectExtraction);\r\n    test(options.deadCode, DeadCode);\r\n\r\n    test(options.dispatcher, Dispatcher);\r\n    test(options.controlFlowFlattening, ControlFlowFlattening);\r\n    test(options.globalConcealing, GlobalConcealing);\r\n    test(options.stringConcealing, StringConcealing);\r\n    test(options.stringEncoding, StringEncoding);\r\n    test(options.stringSplitting, StringSplitting);\r\n    test(options.renameVariables, RenameVariables);\r\n    test(options.eval, Eval);\r\n    test(options.opaquePredicates, OpaquePredicates);\r\n    test(options.duplicateLiteralsRemoval, DuplicateLiteralsRemoval);\r\n    test(options.minify, Minify);\r\n\r\n    test(options.calculator, Calculator);\r\n    test(options.movedDeclarations, MovedDeclarations);\r\n\r\n    test(options.es5, ES5);\r\n    test(options.shuffle, Shuffle);\r\n\r\n    test(options.flatten, Flatten);\r\n    test(options.rgf, RGF);\r\n\r\n    if (\r\n      options.lock &&\r\n      Object.keys(options.lock).filter((x) =>\r\n        x == \"domainLock\" ? options.lock.domainLock.length : options.lock[x]\r\n      ).length\r\n    ) {\r\n      test(true, Lock);\r\n    }\r\n\r\n    // Make array\r\n    this.array = Object.values(this.transforms);\r\n\r\n    // Sort transformations based on their priority\r\n    this.array.sort((a, b) => a.priority - b.priority);\r\n  }\r\n\r\n  push(transform: Transform) {\r\n    ok(!this.transforms[transform.className], \"Already have\");\r\n    this.transforms[transform.className] = transform;\r\n  }\r\n\r\n  async apply(tree: Node, debugMode = false) {\r\n    ok(tree.type == \"Program\", \"The root node must be type 'Program'\");\r\n    ok(Array.isArray(tree.body), \"The root's body property must be an array\");\r\n    ok(Array.isArray(this.array));\r\n\r\n    this.state = \"transform\";\r\n\r\n    for (var transform of this.array) {\r\n      await transform.apply(tree);\r\n\r\n      if (debugMode) {\r\n        this.emit(\"debug\", transform.className, tree);\r\n      }\r\n    }\r\n\r\n    if (this.options.verbose) {\r\n      console.log(\"-> Check for Eval Callbacks\");\r\n    }\r\n\r\n    this.state = \"eval\";\r\n\r\n    // Find eval callbacks\r\n    traverse(tree, (o, p) => {\r\n      if (o.$eval) {\r\n        return () => {\r\n          o.$eval();\r\n        };\r\n      }\r\n    });\r\n\r\n    if (this.options.verbose) {\r\n      console.log(\"<- Done\");\r\n    }\r\n  }\r\n}\r\n","import { ok } from \"assert\";\r\nimport { compileJsSync } from \"../compiler\";\r\nimport { ComputeProbabilityMap } from \"../index\";\r\nimport Obfuscator, { ObfuscateOrder } from \"../obfuscator\";\r\nimport { parseSnippet, parseSync } from \"../parser\";\r\nimport Template from \"../templates/template\";\r\nimport traverse, { getDepth, walk } from \"../traverse\";\r\nimport {\r\n  ArrayExpression,\r\n  AssignmentExpression,\r\n  BreakStatement,\r\n  CallExpression,\r\n  Chain,\r\n  ExpressionStatement,\r\n  FunctionDeclaration,\r\n  FunctionExpression,\r\n  Identifier,\r\n  Literal,\r\n  Location,\r\n  MemberExpression,\r\n  NewExpression,\r\n  Node,\r\n  ObjectExpression,\r\n  Property,\r\n  ReturnStatement,\r\n  SpreadElement,\r\n  SwitchCase,\r\n  SwitchStatement,\r\n  ThisExpression,\r\n  VariableDeclaration,\r\n  VariableDeclarator,\r\n} from \"../util/gen\";\r\nimport { getDefiningIdentifier, getIdentifierInfo } from \"../util/identifiers\";\r\nimport {\r\n  getBlockBody,\r\n  getContext,\r\n  isContext,\r\n  isFunction,\r\n  prepend,\r\n} from \"../util/insert\";\r\nimport RenameVariables from \"./identifier/renameVariables\";\r\nimport Transform, { reservedIdentifiers } from \"./transform\";\r\n\r\nexport default class RGF extends Transform {\r\n  collect: { location: Location; references: Set<string>; name?: string }[];\r\n\r\n  queue: Location[];\r\n  names: Map<string, number>;\r\n  definingNodes: Map<string, Node>;\r\n\r\n  constructor(o) {\r\n    super(o, ObfuscateOrder.RGF);\r\n\r\n    this.collect = [];\r\n    this.queue = [];\r\n    this.names = new Map();\r\n    this.definingNodes = new Map();\r\n  }\r\n\r\n  apply(tree) {\r\n    super.apply(tree);\r\n\r\n    if (!this.collect.length) {\r\n      return;\r\n    }\r\n\r\n    this.collect.forEach(({ name }) => {\r\n      this.collect.forEach(({ references }) => {\r\n        references.delete(name);\r\n      });\r\n    });\r\n\r\n    this.queue = [];\r\n    this.collect.forEach((o) => {\r\n      if (!o.references.size) {\r\n        var [object, parents] = o.location;\r\n\r\n        this.queue.push([object, parents]);\r\n        if (\r\n          object.type == \"FunctionDeclaration\" &&\r\n          typeof object.id.name === \"string\"\r\n        ) {\r\n          var index = this.names.size;\r\n\r\n          this.names.set(object.id.name, index);\r\n          this.definingNodes.set(object.id.name, object.id);\r\n        }\r\n      }\r\n    });\r\n\r\n    if (!this.queue.length) {\r\n      return;\r\n    }\r\n\r\n    var referenceArray = this.generateIdentifier();\r\n\r\n    traverse(tree, (o, p) => {\r\n      if (o.type == \"Identifier\" && !reservedIdentifiers.has(o.name)) {\r\n        var index = this.names.get(o.name);\r\n        if (typeof index === \"number\") {\r\n          var info = getIdentifierInfo(o, p);\r\n          if (info.spec.isReferenced && !info.spec.isDefined) {\r\n            var location = getDefiningIdentifier(o, p);\r\n            if (location) {\r\n              var pointingTo = location[0];\r\n              var shouldBe = this.definingNodes.get(o.name);\r\n\r\n              // console.log(pointingTo, shouldBe);\r\n\r\n              if (pointingTo == shouldBe) {\r\n                this.log(o.name, \"->\", `${referenceArray}[${index}]`);\r\n\r\n                this.replace(\r\n                  o,\r\n                  FunctionExpression(\r\n                    [],\r\n                    [\r\n                      ReturnStatement(\r\n                        CallExpression(\r\n                          MemberExpression(\r\n                            Identifier(referenceArray),\r\n                            Literal(index),\r\n                            true\r\n                          ),\r\n                          [\r\n                            Identifier(referenceArray),\r\n                            SpreadElement(Identifier(\"arguments\")),\r\n                          ]\r\n                        )\r\n                      ),\r\n                    ]\r\n                  )\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    var arrayExpression = ArrayExpression([]);\r\n    var variableDeclaration = VariableDeclaration([\r\n      VariableDeclarator(Identifier(referenceArray), arrayExpression),\r\n    ]);\r\n\r\n    prepend(tree, variableDeclaration);\r\n\r\n    this.queue.forEach(([object, parents]) => {\r\n      var name = object?.id?.name;\r\n      var hasName = !!name;\r\n      var params = object.params.map((x) => x.name) || [];\r\n\r\n      // Since `new Function` is completely isolated, create an entire new obfuscator and run remaining transformations.\r\n      // RGF runs early and needs completed code before converting to a string.\r\n      var o = new Obfuscator({\r\n        ...this.options,\r\n      });\r\n      var t = Object.values(o.transforms).filter(\r\n        (x) => x.priority > this.priority\r\n      );\r\n\r\n      var tree = {\r\n        type: \"Program\",\r\n        body: [\r\n          object,\r\n          ReturnStatement(\r\n            CallExpression(Identifier(object.id.name), [\r\n              SpreadElement(\r\n                Template(`Array.prototype.slice.call(arguments, 1)`).single()\r\n                  .expression\r\n              ),\r\n            ])\r\n          ),\r\n        ],\r\n      };\r\n\r\n      t.forEach((x) => {\r\n        x.apply(tree);\r\n      });\r\n\r\n      var toString = compileJsSync(tree, this.options);\r\n\r\n      var newFunction = NewExpression(Identifier(\"Function\"), [\r\n        Literal(referenceArray),\r\n        Literal(toString),\r\n      ]);\r\n\r\n      if (hasName) {\r\n        arrayExpression.elements[this.names.get(name)] = newFunction;\r\n\r\n        if (Array.isArray(parents[0])) {\r\n          parents[0].splice(parents[0].indexOf(object), 1);\r\n        }\r\n      } else {\r\n        this.replace(object, newFunction);\r\n      }\r\n    });\r\n  }\r\n\r\n  match(object, parents) {\r\n    return (\r\n      isFunction(object) &&\r\n      getContext(parents[0], parents.slice(1)) == parents[parents.length - 1]\r\n    );\r\n  }\r\n\r\n  transform(object, parents) {\r\n    var defined = new Set<string>(),\r\n      referenced = new Set<string>();\r\n\r\n    walk(object.body, [object, ...parents], (o, p) => {\r\n      if (\r\n        o.type == \"Identifier\" &&\r\n        !reservedIdentifiers.has(o.name) &&\r\n        !this.options.globalVariables.has(o.name)\r\n      ) {\r\n        var info = getIdentifierInfo(o, p);\r\n        if (info.spec.isDefined) {\r\n          defined.add(o.name);\r\n        } else if (info.spec.isReferenced) {\r\n          referenced.add(o.name);\r\n        }\r\n      }\r\n    });\r\n\r\n    defined.forEach((identifier) => {\r\n      referenced.delete(identifier);\r\n    });\r\n\r\n    object.params.forEach((param) => {\r\n      referenced.delete(param.name);\r\n    });\r\n\r\n    this.collect.push({\r\n      location: [object, parents],\r\n      references: referenced,\r\n      name: object.id?.name,\r\n    });\r\n  }\r\n}\r\n","import { ok } from \"assert\";\r\nimport { ObfuscateOrder } from \"../obfuscator\";\r\nimport Template from \"../templates/template\";\r\nimport { walk } from \"../traverse\";\r\nimport {\r\n  FunctionDeclaration,\r\n  Identifier,\r\n  ReturnStatement,\r\n  FunctionExpression,\r\n  SwitchStatement,\r\n  VariableDeclaration,\r\n  VariableDeclarator,\r\n  CallExpression,\r\n  MemberExpression,\r\n  ThisExpression,\r\n  ArrayExpression,\r\n  SwitchCase,\r\n  Literal,\r\n  ExpressionStatement,\r\n  BreakStatement,\r\n  AssignmentExpression,\r\n  Location,\r\n  Node,\r\n} from \"../util/gen\";\r\nimport { getDefiningIdentifier, getIdentifierInfo } from \"../util/identifiers\";\r\nimport {\r\n  getBlockBody,\r\n  getContext,\r\n  isContext,\r\n  isFunction,\r\n  prepend,\r\n} from \"../util/insert\";\r\nimport Transform, { reservedIdentifiers } from \"./transform\";\r\n\r\n/**\r\n * Brings every function to the global level.\r\n *\r\n * Functions take parameters, input, have a return value and return modified changes to the scoped variables.\r\n */\r\nexport default class Flatten extends Transform {\r\n  constructor(o) {\r\n    super(o, ObfuscateOrder.Flatten);\r\n  }\r\n\r\n  match(object, parents) {\r\n    return isContext(object) && object.type != \"Program\";\r\n  }\r\n\r\n  transform(context, contextParents) {\r\n    ok(isContext(context));\r\n\r\n    return () => {\r\n      var executorName;\r\n\r\n      var prepareCases = [];\r\n      var unloadCases = [];\r\n\r\n      var resultName = this.getPlaceholder();\r\n      var argsName = this.getPlaceholder();\r\n\r\n      const makeExecutorFunction = () => {\r\n        if (!executorName) {\r\n          executorName = \"execute\" + this.getPlaceholder();\r\n          prepend(\r\n            context,\r\n            FunctionDeclaration(\r\n              executorName,\r\n              [Identifier(\"fn\"), Identifier(\"methodIndex\")],\r\n              [\r\n                ReturnStatement(\r\n                  FunctionExpression(\r\n                    [],\r\n                    [\r\n                      Template(\r\n                        `var ${argsName} = Array.prototype.slice.call(arguments);`\r\n                      ).single(),\r\n                      SwitchStatement(Identifier(\"methodIndex\"), prepareCases),\r\n                      VariableDeclaration(\r\n                        VariableDeclarator(\r\n                          resultName,\r\n                          CallExpression(\r\n                            MemberExpression(\r\n                              Identifier(\"fn\"),\r\n                              Identifier(\"apply\"),\r\n                              false\r\n                            ),\r\n                            [ThisExpression(), Identifier(argsName)]\r\n                          )\r\n                        )\r\n                      ),\r\n                      SwitchStatement(Identifier(\"methodIndex\"), unloadCases),\r\n\r\n                      ReturnStatement(\r\n                        CallExpression(\r\n                          MemberExpression(\r\n                            Identifier(resultName),\r\n                            Identifier(\"pop\"),\r\n                            false\r\n                          ),\r\n                          []\r\n                        )\r\n                      ),\r\n                    ]\r\n                  )\r\n                ),\r\n              ]\r\n            )\r\n          );\r\n        }\r\n      };\r\n\r\n      var functionsChanged = new Set<string>();\r\n      var newNames: { [originalName: string]: string } = Object.create(null);\r\n      var methods: {\r\n        [newName: string]: {\r\n          referenced: Set<string>;\r\n          modified: Set<string>;\r\n          index: number;\r\n        };\r\n      } = Object.create(null);\r\n\r\n      walk(context, contextParents, (object, parents) => {\r\n        if (\r\n          object != context &&\r\n          isFunction(object) &&\r\n          getContext(parents[0], parents.slice(1)) == context &&\r\n          !object.$rgf\r\n        ) {\r\n          return () => {\r\n            var params = new Set<string>();\r\n\r\n            walk(object.params, [object, ...parents], (o, p) => {\r\n              if (\r\n                o.type == \"Identifier\" &&\r\n                getContext(o, p) == object &&\r\n                !reservedIdentifiers.has(o.name)\r\n              ) {\r\n                params.add(o.name);\r\n              }\r\n            });\r\n\r\n            // console.log(object?.id?.name, params);\r\n\r\n            var referenced = new Set<string>();\r\n            var modified = new Set<string>();\r\n            var definedTopLevel = new Set<string>();\r\n\r\n            var returnStatements: Location[] = [];\r\n\r\n            getBlockBody(object.body).push(ReturnStatement());\r\n\r\n            walk(object.body, [object, ...parents], (o, p) => {\r\n              if (o.type == \"Identifier\" && !reservedIdentifiers.has(o.name)) {\r\n                var info = getIdentifierInfo(o, p);\r\n\r\n                if (info.spec.isDefined) {\r\n                  var definingContext = getContext(o, p);\r\n                  if (info.isFunctionDeclaration) {\r\n                    definingContext = getContext(p[1], p.slice(2));\r\n                  }\r\n                  if (definingContext == object) {\r\n                    definedTopLevel.add(o.name);\r\n                  } else {\r\n                  }\r\n                } else if (info.spec.isModified || info.spec.isReferenced) {\r\n                  var definedAt = getDefiningIdentifier(o, p);\r\n                  if (definedAt) {\r\n                    // for variables defined inside the function, no external reference needed\r\n                    if (definedAt[1].includes(object)) {\r\n                      return;\r\n                    }\r\n                  }\r\n\r\n                  if (info.spec.isModified) {\r\n                    modified.add(o.name);\r\n                  }\r\n                  if (info.spec.isReferenced) {\r\n                    referenced.add(o.name);\r\n                  }\r\n                }\r\n              }\r\n\r\n              if (o.type == \"ReturnStatement\") {\r\n                if (getContext(o, p) == object) {\r\n                  returnStatements.push([o, p]);\r\n                }\r\n              }\r\n            });\r\n\r\n            // console.log(object?.id?.name, params, modified, referenced);\r\n\r\n            params.forEach((x) => {\r\n              modified.delete(x);\r\n              referenced.delete(x);\r\n            });\r\n\r\n            definedTopLevel.forEach((identifier) => {\r\n              modified.delete(identifier);\r\n              referenced.delete(identifier);\r\n            });\r\n\r\n            modified.forEach((identifier) => {\r\n              referenced.delete(identifier);\r\n            });\r\n\r\n            this.options.globalVariables.forEach((identifier) => {\r\n              if (!params.has(identifier) && !definedTopLevel.has(identifier)) {\r\n                referenced.delete(identifier);\r\n              }\r\n            });\r\n\r\n            returnStatements.forEach(([returnStatement, p]) => {\r\n              returnStatement.argument = ArrayExpression([\r\n                ...Array.from(modified).map((name) => {\r\n                  return Identifier(name);\r\n                }),\r\n                returnStatement.argument || Identifier(\"undefined\"),\r\n              ]);\r\n            });\r\n\r\n            var newName =\r\n              this.getPlaceholder() + \"_\" + (object?.id?.name || \"_\");\r\n\r\n            var methodIndex = Object.keys(methods).length;\r\n            methods[object?.id?.name] = {\r\n              referenced: referenced,\r\n              modified: modified,\r\n              index: methodIndex,\r\n            };\r\n\r\n            if (referenced.size || modified.size) {\r\n              prepareCases.push(\r\n                SwitchCase(Literal(methodIndex), [\r\n                  ...[...modified, ...referenced].reverse().map((identifer) => {\r\n                    return ExpressionStatement(\r\n                      CallExpression(\r\n                        MemberExpression(\r\n                          Identifier(argsName),\r\n                          Identifier(\"unshift\"),\r\n                          false\r\n                        ),\r\n                        [Identifier(identifer)]\r\n                      )\r\n                    );\r\n                  }),\r\n                  BreakStatement(),\r\n                ])\r\n              );\r\n            }\r\n\r\n            if (modified.size) {\r\n              unloadCases.push(\r\n                SwitchCase(Literal(methodIndex), [\r\n                  ...Array.from(modified).map((identifer, i) => {\r\n                    return ExpressionStatement(\r\n                      AssignmentExpression(\r\n                        \"=\",\r\n                        Identifier(identifer),\r\n                        MemberExpression(\r\n                          Identifier(resultName),\r\n                          Literal(i),\r\n                          true\r\n                        )\r\n                      )\r\n                    );\r\n                  }),\r\n                  BreakStatement(),\r\n                ])\r\n              );\r\n            }\r\n\r\n            var globalFn: Node = FunctionDeclaration(\r\n              newName,\r\n              [\r\n                ...Array.from(modified).map((x) => Identifier(x)),\r\n                ...Array.from(referenced).map((x) => Identifier(x)),\r\n                ...Array.from(params).map((x) => Identifier(x)),\r\n              ],\r\n              object.expression ? [object.body] : getBlockBody(object.body)\r\n            );\r\n\r\n            globalFn.$rgf = true;\r\n\r\n            prepend(\r\n              contextParents[contextParents.length - 1] || context,\r\n              globalFn\r\n            );\r\n\r\n            object.$rgf = true;\r\n\r\n            if (object.type == \"FunctionDeclaration\") {\r\n              functionsChanged.add(object.id.name);\r\n\r\n              if (Array.isArray(parents[0])) {\r\n                // console.log(\"Deleted\", object.id.name, \"->\", newName);\r\n                parents[0].splice(parents[0].indexOf(object), 1);\r\n\r\n                newNames[object.id.name] = newName;\r\n              } else {\r\n                // ?\r\n              }\r\n            } else {\r\n              makeExecutorFunction();\r\n\r\n              this.replace(\r\n                object,\r\n                CallExpression(Identifier(executorName), [\r\n                  Identifier(newName),\r\n                  Literal(methodIndex),\r\n                ])\r\n              );\r\n            }\r\n          };\r\n        }\r\n      });\r\n\r\n      walk(context, contextParents, (object, parents) => {\r\n        if (object.type == \"Identifier\" && newNames[object.name]) {\r\n          var info = getIdentifierInfo(object, parents);\r\n          if (info.spec.isReferenced) {\r\n            if (!info.spec.isDefined || !info.spec.isModified) {\r\n              makeExecutorFunction();\r\n\r\n              this.replace(\r\n                object,\r\n                CallExpression(Identifier(executorName), [\r\n                  Identifier(newNames[object.name]),\r\n                  Literal(methods[object.name]?.index),\r\n                ])\r\n              );\r\n            }\r\n          }\r\n        }\r\n      });\r\n    };\r\n  }\r\n}\r\n","export function createObject(\r\n  keys: string[],\r\n  values: any[]\r\n): { [key: string]: any } {\r\n  if (keys.length != values.length) {\r\n    throw new Error(\"length mismatch\");\r\n  }\r\n\r\n  var newObject = {};\r\n\r\n  keys.forEach((x, i) => {\r\n    newObject[x] = values[i];\r\n  });\r\n\r\n  return newObject;\r\n}\r\n","import compileJs, { compileJsSync } from \"./compiler\";\r\nimport parseJS, { parseSync } from \"./parser\";\r\nimport Obfuscator from \"./obfuscator\";\r\nimport { createObject } from \"./util/object\";\r\nimport presets from \"./presets\";\r\n\r\nimport * as assert from \"assert\";\r\n\r\n/**\r\n * Configurable probabilities for obfuscator options.\r\n * - **`false`** = this feature is disabled\r\n * - **`true`** = this feature is enabled, use default mode\r\n * - **`0.5`** = 50% chance\r\n * - **`\"mode\"`** = enabled, use specified mode\r\n * - **`[\"mode1\", \"mode2\"]`** - enabled, choose random mode each occurrence\r\n * - **`{\"mode1\": 0.5, \"mode2\": 0.5}`** - enabled, choose based on specified probabilities\r\n * - **`{\"mode1\": 50, \"mode2\": 50}`** - enabled, each is divided based on total\r\n * - **`function(x){ return \"custom_implementation\" }`** - enabled, use specified function\r\n */\r\nexport type ProbabilityMap<T> =\r\n  | false\r\n  | true\r\n  | number\r\n  | T\r\n  | T[]\r\n  | { [name: string]: number }\r\n  | ((object: any) => any);\r\n\r\n/**\r\n * Evaluates a ProbabilityMap.\r\n * @param map The setting object.\r\n * @param runner Custom function to determine return value\r\n * @param customFnArgs Args given to user-implemented function, such as a variable name.\r\n */\r\nexport function ComputeProbabilityMap<T>(\r\n  map: ProbabilityMap<T>,\r\n  runner: (mode?: T) => any = (x) => x,\r\n  ...customFnArgs: any[]\r\n): any {\r\n  if (!map) {\r\n    return runner();\r\n  }\r\n  if (map === true || map === 1) {\r\n    return runner(true as any);\r\n  }\r\n  if (typeof map === \"number\") {\r\n    return runner((Math.random() < map) as any);\r\n  }\r\n\r\n  if (typeof map === \"function\") {\r\n    return (map as any)(...customFnArgs);\r\n  }\r\n  if (typeof map === \"string\") {\r\n    return runner(map);\r\n  }\r\n  var asObject: { [mode: string]: number } = {};\r\n  if (Array.isArray(map)) {\r\n    map.forEach((x: any) => {\r\n      asObject[x.toString()] = 1;\r\n    });\r\n  } else {\r\n    asObject = map as any;\r\n  }\r\n\r\n  var total = Object.values(asObject).reduce((a, b) => a + b);\r\n  var percentages = createObject(\r\n    Object.keys(asObject),\r\n    Object.values(asObject).map((x) => x / total)\r\n  );\r\n\r\n  var ticket = Math.random();\r\n\r\n  var count = 0;\r\n  var winner = null;\r\n  Object.keys(percentages).forEach((key) => {\r\n    var x = parseFloat(percentages[key]);\r\n\r\n    if (ticket >= count && ticket < count + x) {\r\n      winner = key;\r\n    }\r\n    count += x;\r\n  });\r\n\r\n  return runner(winner);\r\n}\r\n\r\n/**\r\n * Determines if a probability map can return a positive result (true, or some string mode).\r\n * - Negative probability maps are used to remove transformations from running entirely.\r\n * @param map\r\n */\r\nexport function isProbabilityMapProbable<T>(map: ProbabilityMap<T>): boolean {\r\n  if (!map || typeof map === \"undefined\") {\r\n    return false;\r\n  }\r\n  if (typeof map === \"function\") {\r\n    return true;\r\n  }\r\n  if (typeof map === \"number\") {\r\n    if (map > 1 || map < 0) {\r\n      throw new Error(`Numbers must be between 0 and 1 for 0% - 100%`);\r\n    }\r\n    if (isNaN(map)) {\r\n      throw new Error(\"Numbers cannot be NaN\");\r\n    }\r\n  }\r\n  if (Array.isArray(map)) {\r\n    assert.ok(\r\n      map.length != 0,\r\n      \"Empty arrays are not allowed for options. Use false instead.\"\r\n    );\r\n\r\n    if (map.length == 1) {\r\n      return !!map[0];\r\n    }\r\n  }\r\n  if (typeof map === \"object\") {\r\n    var keys = Object.keys(map);\r\n    assert.ok(\r\n      keys.length != 0,\r\n      \"Empty objects are not allowed for options. Use false instead.\"\r\n    );\r\n\r\n    if (keys.length == 1) {\r\n      return !!keys[0];\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport interface ObfuscateOptions {\r\n  /**\r\n   * Built-in obfuscation presets.\r\n   *\r\n   * - **`high`** - Godtier obfuscation, -90% performance reduction.\r\n   * - **`medium`** - Moderate obfuscation, -50% performance reduction.\r\n   * - **`low`** - Lowest level of obfuscation, -30% performance reduction.\r\n   *\r\n   * Presets are optional, and can be extended off of by overriding their properties.\r\n   * ```js\r\n   * var code = await JsConfuser(\"console.log('Hello World!')\", {\r\n   *     target: \"node\",\r\n   *     preset: \"high\",\r\n   *     stringEncoding: false // <- Normally true\r\n   * });\r\n   * ```\r\n   */\r\n  preset?: \"high\" | \"medium\" | \"low\";\r\n\r\n  /**\r\n   * For web-browser related scripts, use the **`browser`** mode.\r\n   *\r\n   * - **`Node`** and **`Electron`** have identical meaning.\r\n   */\r\n  target: \"node\" | \"electron\" | \"browser\";\r\n\r\n  /**\r\n   * Removes whitespace.\r\n   */\r\n  compact?: boolean;\r\n\r\n  /**\r\n   * **Only for when compact is disabled**\r\n   *\r\n   * Controls the indentation style.\r\n   * - **`2`** - 2 spaces\r\n   * - **`4`** - 4 spaces (default)\r\n   * - **`\"tabs\"`** - tabs\r\n   */\r\n  indent?: 2 | 4 | \"tabs\";\r\n\r\n  /**\r\n   * Minifies output.\r\n   */\r\n  minify?: boolean;\r\n\r\n  /**\r\n   * An [Opaque Predicate](https://en.wikipedia.org/wiki/Opaque_predicate) is a predicate(true/false) that is evaluated at runtime, this can confuse reverse engineers\r\n   * understanding your code. Low cost, high performance.\r\n   *\r\n   * *This option is enabled in all presets*\r\n   */\r\n  opaquePredicates?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * Shuffles the initial order of arrays. The order is brought back to the original during runtime.\r\n   */\r\n  shuffle?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * Set of global variables, such as jQuery (`$`) or other external libraries.\r\n   * Defaults to: `window`, `parseInt`, `Math` etc...\r\n   */\r\n  globalVariables?: Set<string>;\r\n\r\n  /**\r\n   * Locks control where the program can be executed.\r\n   */\r\n  lock?: {\r\n    /**\r\n     * Set of global functions that are native. Such as `require`, `fetch`. If these\r\n     * variables are modified the program crashes.\r\n     *\r\n     * - Set to `true` to use the default list of native functions.\r\n     */\r\n    nativeFunctions?: Set<string> | true;\r\n\r\n    /**\r\n     * Array of properties that must be on the `window` or `global` object.\r\n     *\r\n     * - i.e `window['_customProperty']'`\r\n     * - If the property is undefined, the program crashes (based on `countermeasures` field)\r\n     */\r\n    context?: string[];\r\n\r\n    /**\r\n     * When the program is first able to be used.\r\n     *\r\n     * - Type: `Date` or `number` representing unix in ms.\r\n     */\r\n    startDate?: Date | number;\r\n\r\n    /**\r\n     * When the program is no longer able to be used.\r\n     *\r\n     * - Type: `Date` or `number` representing unix in ms.\r\n     */\r\n    endDate?: Date | number;\r\n\r\n    /**\r\n     * Array of regex strings that the `window.location.href` must follow.\r\n     *\r\n     * - Type: Array of `string` or `RegExp`\r\n     */\r\n    domainLock?: (string | RegExp)[];\r\n\r\n    /**\r\n     * Integrity ensures the source code is unchanged.\r\n     *\r\n     * - Can break if output is then minified by another program.\r\n     */\r\n    integrity?: boolean;\r\n\r\n    /**\r\n     * Does stuff.\r\n     */\r\n    antiDebug?: boolean;\r\n\r\n    /**\r\n     * If the client is caught missing permissions (wrong date, bad domain), this will\r\n     * crash the current tab/process.\r\n     *\r\n     * - `true` - Crash the browser\r\n     * - `\"string\"` - Function name to call (pre obfuscated)\r\n     */\r\n    countermeasures?: boolean | string;\r\n  };\r\n\r\n  /**\r\n   * Logs each transformation, useful for debugging.\r\n   * - **`false`** *Default*.\r\n   */\r\n  verbose?: boolean;\r\n\r\n  /**\r\n   * Leaves debug comments within the obfuscated code for identifying errors.\r\n   * - **`false`** *Default*.\r\n   */\r\n  debugComments?: boolean;\r\n\r\n  /**\r\n   * Modes:\r\n   * - **`hexadecimal`** - `_0xa8db5`\r\n   * - **`randomized`** - `w$Tsu4G`\r\n   * - **`zeroWidth`** - `U+200D`\r\n   * - **`mangled`** - `a, b, c`\r\n   * - **`number`** - `var_1, var_2`\r\n   *\r\n   * - ```js\r\n   * // Custom implementation\r\n   * JsConfuser(code, {\r\n   *     identifierGenerator: ()=>\"$\" + Math.random().toString(36).substring(7)\r\n   * })\r\n   * ```\r\n   */\r\n  identifierGenerator?: ProbabilityMap<\r\n    \"hexadecimal\" | \"randomized\" | \"zeroWidth\" | \"mangled\" | \"number\"\r\n  >;\r\n\r\n  /**\r\n   * - **`false`** - Keep original names\r\n   * - **`true`** -  Rename variables.\r\n   * ```js\r\n   * // Custom implementation\r\n   * JsConfuser(code, {\r\n   *     renameVariables: function(x){\r\n   *         return x != \"jQuery\";\r\n   *     }\r\n   * })\r\n   * ```\r\n   */\r\n  renameVariables?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * Renames top-level variables.\r\n   *\r\n   * - Keep this setting disabled for web-related scripts.\r\n   * - `window.key = ...` will be remain unchanged.\r\n   */\r\n  renameGlobals?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * - **`false`** - Keep original function flow. *Default*.\r\n   * - **`true`** - Creates a dispatcher function to process function calls.\r\n   *\r\n   * A Dispatcher middle-mans function calls.\r\n   */\r\n  dispatcher?: ProbabilityMap<false | true>;\r\n\r\n  flatten?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * RGF (Runtime-Generated-Functions) uses the `new Function(code...)` to construct executable code from strings.\r\n   *\r\n   * **This can break your code. This is also as dangerous as `eval` (eval is evil!)**\r\n   *\r\n   * ```js\r\n   * // Input\r\n   * function log(x) {\r\n   *   console.log(x);\r\n   * }\r\n   * log(\"hi\");\r\n   *\r\n   * // Output\r\n   * var refs = [new Function('refs', 'x', 'console.log(x);')];\r\n   * (function () {\r\n   *   return refs[0](refs, ...arguments);\r\n   * }('hi'));\r\n   * ```\r\n   */\r\n  rgf?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * Defines all variables at the top of the scope.\r\n   */\r\n  movedDeclarations?: boolean;\r\n\r\n  /**\r\n   * - **`false`** - No calculator function\r\n   * - **`true`** - Processes arithmetic and logical expressions.\r\n   *\r\n   * A calculator function helps obfuscate logic\r\n   */\r\n  calculator?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * [Control-flow Flattening](https://docs.jscrambler.com/code-integrity/documentation/transformations/control-flow-flattening) obfuscates the program's control-flow by\r\n   * adding opaque predicates; flattening the control-flow; and adding irrelevant code clones.\r\n   *\r\n   * - Potency: High\r\n   * - Resilience: High\r\n   * - Cost: High\r\n   */\r\n  controlFlowFlattening?: ProbabilityMap<true | false>;\r\n\r\n  /**\r\n   * Adds Dead Code.\r\n   */\r\n  deadCode?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * - **`false`** - Keep objects in untouched form.\r\n   * - **`true`** - Extract object's properties to help flatten the scope.\r\n   * ```js\r\n   * // Custom implementation to exclude certain objects\r\n   * var options = {\r\n   *     objectExtraction: function(name){\r\n   *         return name != \"$\";\r\n   *     }\r\n   * }\r\n   * ```\r\n   */\r\n  objectExtraction?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * Converts the code to ES5.\r\n   */\r\n  es5?: boolean;\r\n\r\n  /**\r\n   * [String Concealing](https://docs.jscrambler.com/code-integrity/documentation/transformations/string-concealing) involves encoding strings to\r\n   * conceal plain-text values. This is useful for both automated tools and reverse engineers.\r\n   *\r\n   * - Potency High\r\n   * - Resilience Medium\r\n   * - Cost Medium\r\n   */\r\n  stringConcealing?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * Global Concealing hides global variables being accessed.\r\n   *\r\n   * - Any variable that is not defined is considered \"global\"\r\n   */\r\n  globalConcealing?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * [String Encoding](https://docs.jscrambler.com/code-integrity/documentation/transformations/string-encoding) transforms a string into an encoded representation.\r\n   *\r\n   * - Potency Low\r\n   * - Resilience Low\r\n   * - Cost Low\r\n   */\r\n  stringEncoding?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * [Duplicate Literals Removal](https://docs.jscrambler.com/code-integrity/documentation/transformations/duplicate-literals-removal) replaces duplicate literals with a variable name.\r\n   *\r\n   * - Potency Medium\r\n   * - Resilience Medium\r\n   * - Cost Medium\r\n   */\r\n  duplicateLiteralsRemoval?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * [String Splitting](https://docs.jscrambler.com/code-integrity/documentation/transformations/string-splitting) splits your strings into multiple expressions.\r\n   *\r\n   * - Potency Medium\r\n   * - Resilience Medium\r\n   * - Cost Medium\r\n   */\r\n  stringSplitting?: ProbabilityMap<false | true>;\r\n\r\n  /**\r\n   * ## **`Security Warning`**\r\n   * From [MDN]((https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)**): Executing JavaScript from a string is an enormous security risk. It is far too easy\r\n   * for a bad actor to run arbitrary code when you use eval(). Never use eval()!\r\n   *\r\n   * Wraps defined functions within eval statements.\r\n   * - **`false`** - Avoids using the `eval` function. *Default*.\r\n   * - **`true`** - Wraps function's code into an `eval` statement.\r\n   * - **`0.5`** - Example to limit the frequency (50% percent)\r\n   *\r\n   * ```js\r\n   * // Output.js\r\n   * var Q4r1__ = {\r\n   *     'Oo$Oz8t': eval('(function(YjVpAp){var gniSBq6=kHmsJrhOO;switch(gniSBq6){case\\'RW11Hj5x\\':return console;}});')\r\n   * }\r\n   * Q4r1__.Oo$Oz8t('RW11Hj5x')\r\n   * ```\r\n   */\r\n  eval?: ProbabilityMap<false | true>;\r\n}\r\n\r\n/**\r\n * **JsConfuser**: Obfuscates JavaScript.\r\n * @param code - The code to be obfuscated.\r\n * @param options - An object of obfuscation options: `{preset: \"medium\", target: \"browser\"}`.\r\n */\r\nexport default async function JsConfuser(\r\n  code: string,\r\n  options: ObfuscateOptions\r\n) {\r\n  assert.ok(options, \"options cannot be null\");\r\n  assert.ok(options.target, \"Missing options.target option (required)\");\r\n  assert.ok(\r\n    [\"browser\", \"electron\", \"node\"].includes(options.target),\r\n    `'${options.target}' is not a valid target mode`\r\n  );\r\n\r\n  if (Object.keys(options).length == 1) {\r\n    /**\r\n     * Give a welcoming introduction to those who skipped the documentation.\r\n     */\r\n    var line = `You provided zero obfuscation options. By default everything is disabled.\\nYou can use a preset with:\\n\\n> {target: '${options.target}', preset: 'high' | 'medium' | 'low'}.\\n\\n\\nYou can also specify individual options you need.`;\r\n    throw new Error(\r\n      `\\n\\n` +\r\n        line\r\n          .split(\"\\n\")\r\n          .map((x) => `\\t${x}`)\r\n          .join(\"\\n\") +\r\n        `\\n\\n`\r\n    );\r\n  }\r\n\r\n  options = await correctOptions(options);\r\n\r\n  var tree = await parseJS(code);\r\n\r\n  var obfuscator = new Obfuscator(options);\r\n\r\n  await obfuscator.apply(tree);\r\n\r\n  options.verbose && console.log(\"* Removing $ properties\");\r\n\r\n  remove$Properties(tree);\r\n\r\n  options.verbose && console.log(\"* Generating code\");\r\n\r\n  var result = await compileJs(tree, options);\r\n\r\n  return result;\r\n}\r\n\r\nexport async function correctOptions(\r\n  options: ObfuscateOptions\r\n): Promise<ObfuscateOptions> {\r\n  if (options.preset) {\r\n    assert.ok(\r\n      presets[options.preset],\r\n      \"Unknown preset of '\" + options.preset + \"'\"\r\n    );\r\n\r\n    // Clone and allow overriding\r\n    options = Object.assign({}, presets[options.preset], options);\r\n  }\r\n\r\n  if (!options.hasOwnProperty(\"debugComments\")) {\r\n    options.debugComments = false; // debugComments is off by default\r\n  }\r\n\r\n  if (!options.hasOwnProperty(\"compact\")) {\r\n    options.compact = true; // Compact is on by default\r\n  }\r\n\r\n  if (options.globalVariables && !(options.globalVariables instanceof Set)) {\r\n    options.globalVariables = new Set(Object.keys(options.globalVariables));\r\n  }\r\n\r\n  // options.globalVariables was never used.\r\n  // GlobalConcealing implicitly determines a global to be a variable referenced but never defined or modified.\r\n  if (!options.hasOwnProperty(\"globalVariables\")) {\r\n    options.globalVariables = new Set([]);\r\n\r\n    if (options.target == \"browser\") {\r\n      // browser\r\n      [\r\n        \"window\",\r\n        \"document\",\r\n        \"postMessage\",\r\n        \"alert\",\r\n        \"confirm\",\r\n        \"location\",\r\n      ].forEach((x) => options.globalVariables.add(x));\r\n    } else {\r\n      // node and electron\r\n      [\r\n        \"global\",\r\n        \"Buffer\",\r\n        \"require\",\r\n        \"process\",\r\n        \"__dirname\",\r\n        \"__filename\",\r\n      ].forEach((x) => options.globalVariables.add(x));\r\n    }\r\n\r\n    [\r\n      \"globalThis\",\r\n      \"console\",\r\n      \"parseInt\",\r\n      \"parseFloat\",\r\n      \"Math\",\r\n      \"Promise\",\r\n      \"String\",\r\n      \"Boolean\",\r\n      \"Function\",\r\n      \"Object\",\r\n      \"Array\",\r\n      \"Proxy\",\r\n      \"Error\",\r\n      \"setTimeout\",\r\n      \"clearTimeout\",\r\n      \"setInterval\",\r\n      \"clearInterval\",\r\n      \"setImmediate\",\r\n      \"clearImmediate\",\r\n      \"queueMicrotask\",\r\n      \"exports\",\r\n      \"module\",\r\n    ].forEach((x) => options.globalVariables.add(x));\r\n  }\r\n\r\n  return options;\r\n}\r\n\r\nexport async function debugTransformations(\r\n  code: string,\r\n  options: ObfuscateOptions\r\n): Promise<{ name: string; code: string }[]> {\r\n  options = await correctOptions(options);\r\n\r\n  var frames = [];\r\n\r\n  var tree = parseSync(code);\r\n  var obfuscator = new Obfuscator(options);\r\n\r\n  obfuscator.on(\"debug\", (name: string, tree: Node) => {\r\n    frames.push({\r\n      name: name,\r\n      code: compileJsSync(tree, options),\r\n    });\r\n  });\r\n\r\n  await obfuscator.apply(tree);\r\n\r\n  return frames;\r\n}\r\n\r\n/**\r\n * Removes all `$`-prefixed properties on a deeply nested object.\r\n *\r\n * - Modifies the object.\r\n */\r\nexport function remove$Properties(object: any, seen = new Set<Node>()) {\r\n  if (typeof object === \"object\" && object) {\r\n    if (seen.has(object)) {\r\n      // console.log(object);\r\n      // throw new Error(\"Already seen\");\r\n    }\r\n    seen.add(object);\r\n\r\n    Object.keys(object).forEach((key) => {\r\n      if (key.charAt(0) == \"$\") {\r\n        delete object[key];\r\n      } else {\r\n        remove$Properties(object[key], seen);\r\n      }\r\n    });\r\n  }\r\n}\r\n","import { Button, Modal } from \"rsuite\";\r\nimport { OptionContext } from \"../App\";\r\nimport { useContext } from \"react\";\r\n\r\nexport default function ModalConfig({show, onHide}){\r\n  \r\n  var {options} = useContext(OptionContext);\r\n\r\n  var orderedKeys = Object.keys(options).sort();\r\n  var display = Object.create(null);\r\n\r\n  orderedKeys.forEach(x=>options[x] ? display[x] = options[x] : undefined);\r\n  delete display.globalVariables;\r\n\r\n  if ( display.lock && Object.keys(display.lock).filter(x=>!display.lock[x] || !display.lock[x].length).length == 0 ) {\r\n    delete display.lock;\r\n  }\r\n\r\n\r\n  return <Modal show={show} onHide={onHide}>\r\n\r\n    <Modal.Header>\r\n        <Modal.Title>Config</Modal.Title>\r\n      </Modal.Header>\r\n    <Modal.Body>\r\n    \r\n      <pre>\r\n        {JSON.stringify(display, null, 4)}\r\n      </pre>\r\n\r\n    </Modal.Body>\r\n    <Modal.Footer>\r\n      <Button onClick={onHide} appearance=\"subtle\">\r\n        Close\r\n      </Button>\r\n    </Modal.Footer>\r\n  </Modal>\r\n\r\n};","import Code, { themeMap } from \"./components/Code\";\r\nimport \"./App.scss\";\r\nimport { Alert, Button, Dropdown, Icon, Loader, Panel } from \"rsuite\";\r\nimport { createContext, useMemo, useState } from \"react\";\r\nimport ModalOptions from \"./modals/ModalOptions\";\r\nimport useCookie from \"./useCookie\";\r\nimport JsConfuser, { debugTransformations } from \"./js-confuser/index.ts\";\r\nimport Presets from \"./js-confuser/presets.ts\";\r\nimport ModalConfig from \"./modals/ModalConfig\";\r\n\r\nconst acorn = require(\"acorn\");\r\n\r\nconst defaultCode = `/**\r\n* Welcome to Js Confuser!\r\n* \r\n* The ultimate JavaScript Obfuscation Tool.\r\n* \r\n* You can obfuscate the code with the top right button 'Obfuscate'.\r\n* \r\n* You can customize the obfuscator with the button 'Options'.\r\n*\r\n* Happy Hacking!\r\n*/\r\n\r\nfunction greet(name){\r\n    var output = \"Hello \" + name + \"!\";\r\n    console.log(output);\r\n}\r\n\r\ngreet(\"Internet User\");`;\r\n\r\nexport const ThemeContext = createContext({ theme: \"\", setTheme: () => {} });\r\nexport const OptionContext = createContext({\r\n  options: {},\r\n  setOptions: () => {},\r\n});\r\n\r\nexport const groups = {\r\n  \"Build Settings\": [\r\n    {\r\n      type: \"probability\",\r\n      name: \"target\",\r\n      modes: [\"browser\", \"node\"],\r\n      description: \"The context where the program will run.\",\r\n    },\r\n    {\r\n      type: \"boolean\",\r\n      name: \"es5\",\r\n      displayName: \"ES5\",\r\n      description: \"ES5 Support\",\r\n    },\r\n  ],\r\n  Identifiers: [\r\n    {\r\n      type: \"probability\",\r\n      name: \"identifierGenerator\",\r\n      modes: [\"hexadecimal\", \"randomized\", \"zeroWidth\", \"mangled\", \"number\"],\r\n      description: \"Controls how replaced variable names will look like.\",\r\n    },\r\n    {\r\n      type: \"boolean\",\r\n      name: \"renameVariables\",\r\n      description:\r\n        \"Renames variables with meaningless randomly generated names.\",\r\n    },\r\n  ],\r\n  Strings: [\r\n    {\r\n      type: \"probability\",\r\n      name: \"stringSplitting\",\r\n      description:\r\n        \"String Splitting splits your strings into multiple expressions.\",\r\n    },\r\n    {\r\n      type: \"probability\",\r\n      name: \"stringEncoding\",\r\n      description:\r\n        \"String Encoding transforms a string into an encoded representation.\",\r\n    },\r\n    {\r\n      type: \"probability\",\r\n      name: \"stringConcealing\",\r\n      description:\r\n        \"String Concealing hides strings by encryption. The strings are then deciphered at runtime.\",\r\n    },\r\n  ],\r\n  Data: [\r\n    {\r\n      type: \"probability\",\r\n      name: \"calculator\",\r\n      description:\r\n        \"Calculator creates a convoluted function where arithmetic and logical expressions are solved.\",\r\n    },\r\n    {\r\n      type: \"probability\",\r\n      name: \"objectExtraction\",\r\n      description:\r\n        \"Attempts to a extract object properties, otherwise it leaves the object alone.\",\r\n    },\r\n    {\r\n      type: \"probability\",\r\n      name: \"globalConcealing\",\r\n      description: \"Changes global variables to `window['prop']`\",\r\n    },\r\n    {\r\n      type: \"probability\",\r\n      name: \"shuffle\",\r\n      description:\r\n        \"Shuffles the elements in arrays. The array is then 'unshuffled' at runtime.\",\r\n    },\r\n    {\r\n      type: \"probability\",\r\n      name: \"duplicateLiteralsRemoval\",\r\n      description: \"Removes stuff. Works good with Shuffle.\",\r\n    },\r\n  ],\r\n  \"Control-Flow\": [\r\n    {\r\n      type: \"probability\",\r\n      name: \"controlFlowFlattening\",\r\n      description:\r\n        \"Control Flow Flattening (CFF) conceals the control-flow of the program.\",\r\n    },\r\n    {\r\n      type: \"probability\",\r\n      name: \"dispatcher\",\r\n      description:\r\n        \"Dispatcher masks functions calls and payloads by creating a proxy function.\",\r\n    },\r\n    {\r\n      type: \"probability\",\r\n      name: \"opaquePredicates\",\r\n      description: \"Adds opaque predicates which makes static analysis harder.\",\r\n    },\r\n    {\r\n      type: \"probability\",\r\n      name: \"deadCode\",\r\n      description: \"Injects random dead code throughout the program.\",\r\n    },\r\n  ],\r\n  Functions: [\r\n    {\r\n      type: \"probability\",\r\n      name: \"eval\",\r\n      description:\r\n        \"Wraps function's code into eval() statements. From MDN: Executing JavaScript from a string is an enormous security risk. It is far too easy for a bad actor to run arbitrary code when you use eval(). Never use eval()!\",\r\n    },\r\n    {\r\n      type: \"probability\",\r\n      name: \"rgf\",\r\n      description:\r\n        \"Uses the 'new Function' syntax to construct functions from strings. Just as dangerous as eval.\",\r\n    },\r\n  ],\r\n  Lock: [\r\n    {\r\n      type: \"regex[]\",\r\n      name: \"domainLock\",\r\n      parentField: \"lock\",\r\n      description:\r\n        \"Ensures the script can only execute on the specified domain. Set the Counter Measures option to control what happens if violated.\",\r\n    },\r\n    {\r\n      type: \"date\",\r\n      parentField: \"lock\",\r\n      name: \"startDate\",\r\n      description: \"The minimum date the program is able to run.\",\r\n    },\r\n    {\r\n      type: \"date\",\r\n      parentField: \"lock\",\r\n      name: \"endDate\",\r\n      description: \"The maximum date the program is able to run.\",\r\n    },\r\n    {\r\n      type: \"probability\",\r\n      parentField: \"lock\",\r\n      name: \"integrity\",\r\n      description:\r\n        \"Integrity uses checksum techniques to validate the code is unchanged.\",\r\n    },\r\n    {\r\n      type: \"boolean\",\r\n      parentField: \"lock\",\r\n      name: \"countermeasures\",\r\n    },\r\n  ],\r\n  Output: [\r\n    {\r\n      type: \"boolean\",\r\n      name: \"compact\",\r\n      description: \"Trims whitespace and empty lines from the final output\",\r\n    },\r\n    {\r\n      type: \"boolean\",\r\n      name: \"minify\",\r\n      description: \"Removes redundant code for a smaller bundle size\",\r\n    },\r\n  ],\r\n};\r\n\r\nexport default function App() {\r\n  var [theme, setTheme] = useCookie(\"jsconfuser_theme\", \"Material\");\r\n  var [code, setCode] = useState(defaultCode);\r\n  var [indent, setIndent] = useCookie(\"jsconfuser_indent\", 4);\r\n  var [options, setOptions] = useCookie(\"jsconfuser_options\", {\r\n    ...Presets.medium,\r\n  });\r\n  var [debug, setDebug] = useCookie(\"jsconfuser_debugger\", false);\r\n  var [frames, setFrames] = useState([]);\r\n\r\n  var themeValue = useMemo(() => {\r\n    return {\r\n      theme,\r\n      setTheme,\r\n    };\r\n  }, [theme]);\r\n  var optionsValue = useMemo(() => {\r\n    return {\r\n      options,\r\n      setOptions,\r\n    };\r\n  }, [options]);\r\n\r\n  var [show, setShow] = useState(false);\r\n  var [showConfig, setShowConfig] = useState(false);\r\n  var alternate = indent == 2 ? 4 : 2;\r\n\r\n  return (\r\n    <ThemeContext.Provider value={themeValue}>\r\n      <OptionContext.Provider value={optionsValue}>\r\n        <Code\r\n          indent={indent}\r\n          className='app-codeview'\r\n          code={code}\r\n          onChange={setCode}\r\n        ></Code>\r\n        <ModalOptions show={show} onHide={() => setShow(false)} />\r\n        <ModalConfig show={showConfig} onHide={() => setShowConfig(false)} />\r\n\r\n        <div className='app-toolbar'>\r\n          {debug ? (\r\n            <Dropdown\r\n              appearance='link'\r\n              size='lg'\r\n              title='Debugger'\r\n              placement='bottomEnd'\r\n            >\r\n              {frames.map((x, i) => {\r\n                return (\r\n                  <Dropdown.Item onSelect={() => setCode(x.code)}>\r\n                    {i + 1}/{frames.length} {x.name}\r\n                    {x.error ? \" (error)\" : \"\"}\r\n                  </Dropdown.Item>\r\n                );\r\n              })}\r\n              <Dropdown.Item\r\n                onSelect={() => {\r\n                  navigator.clipboard.writeText(\r\n                    JSON.stringify(\r\n                      acorn.parse(code, {\r\n                        ecmaVersion: \"latest\",\r\n                        sourceType: \"module\",\r\n                      })\r\n                    )\r\n                  );\r\n                  Alert.success(\"Copied AST to clipboard.\");\r\n                }}\r\n              >\r\n                Export AST\r\n              </Dropdown.Item>\r\n              <Dropdown.Item onSelect={() => setDebug(false)}>\r\n                Disable Debug Mode\r\n              </Dropdown.Item>\r\n            </Dropdown>\r\n          ) : null}\r\n\r\n          <Dropdown\r\n            appearance='default'\r\n            size='lg'\r\n            title='Options'\r\n            placement='bottomEnd'\r\n          >\r\n            <Dropdown.Item\r\n              onSelect={() => {\r\n                setIndent(alternate);\r\n              }}\r\n            >\r\n              Set indention to {alternate} spaces\r\n            </Dropdown.Item>\r\n            <Dropdown.Item\r\n              onSelect={() => {\r\n                setShow(true);\r\n                Alert.closeAll();\r\n              }}\r\n            >\r\n              Obfuscator Options\r\n            </Dropdown.Item>\r\n            <Dropdown.Item onSelect={() => setShowConfig(true)}>\r\n              Export Config\r\n            </Dropdown.Item>\r\n            <Dropdown.Item onSelect={() => setCode(\"\")}>\r\n              Clear Editor\r\n            </Dropdown.Item>\r\n            <Dropdown.Menu title='Theme' pullLeft>\r\n              {Object.keys(themeMap).map((x) => {\r\n                return (\r\n                  <Dropdown.Item\r\n                    onSelect={() => {\r\n                      setTheme(x);\r\n                    }}\r\n                  >\r\n                    {theme == x ? <Icon icon='check'></Icon> : null}\r\n                    {x}\r\n                  </Dropdown.Item>\r\n                );\r\n              })}\r\n            </Dropdown.Menu>\r\n\r\n            <Dropdown.Item onSelect={(x) => setDebug(!debug)}>\r\n              {!debug ? \"Enable\" : \"Disable\"} Debug Mode\r\n            </Dropdown.Item>\r\n            <Dropdown.Item\r\n              onSelect={(x) =>\r\n                alert(\r\n                  \"JsConfuser is a JavaScript obfuscator. Paste your code in and click 'Obfuscate' to make your code unreadable.\"\r\n                )\r\n              }\r\n            >\r\n              Help\r\n            </Dropdown.Item>\r\n          </Dropdown>\r\n\r\n          <Button\r\n            className='mx-1'\r\n            size='lg'\r\n            appearance='primary'\r\n            onClick={() => {\r\n              if (!code) {\r\n                Alert.error(\"No code to obfuscate.\");\r\n                return;\r\n              }\r\n              if (code.length > 1000) {\r\n                Alert.warning(\"This may take some time\");\r\n              }\r\n\r\n              if (!options.target) {\r\n                options.target = \"browser\";\r\n              }\r\n\r\n              if (!options.hasOwnProperty(\"compact\")) {\r\n                options.compact = false;\r\n              }\r\n\r\n              var lines = code.split(\"\\n\").length;\r\n              var startedAt = Date.now();\r\n\r\n              if (debug) {\r\n                debugTransformations(code, options)\r\n                  .then(async (frames) => {\r\n                    setFrames(frames);\r\n                    var hitError = false;\r\n\r\n                    for (var i = 0; i < frames.length; i++) {\r\n                      var frame = frames[i];\r\n                      frame.index = i;\r\n\r\n                      try {\r\n                        acorn.parse(frame.code, {\r\n                          ecmaVersion: \"latest\",\r\n                          sourceType: \"module\",\r\n                        });\r\n                      } catch (e) {\r\n                        frame.error = true;\r\n                        if (!hitError) {\r\n                          hitError = frame;\r\n                        }\r\n                      }\r\n\r\n                      setCode(\r\n                        \"// \" +\r\n                          (i + 1) +\r\n                          \"/\" +\r\n                          frames.length +\r\n                          \" frames captured\"\r\n                      );\r\n                    }\r\n\r\n                    if (hitError) {\r\n                      setCode(\r\n                        \"// An error occurred at transform \" +\r\n                          hitError.name +\r\n                          \" (\" +\r\n                          frame.index +\r\n                          \")\"\r\n                      );\r\n                      Alert.error(\"Syntax error detected.\");\r\n                    }\r\n                  })\r\n                  .catch((err) => {\r\n                    console.error(err);\r\n                    Alert.error(err);\r\n                  });\r\n              } else {\r\n                JsConfuser(code, {\r\n                  ...options,\r\n                  verbose: true,\r\n                })\r\n                  .then((output) => {\r\n                    Alert.closeAll();\r\n                    Alert.success(\r\n                      \"Obfuscated \" +\r\n                        lines +\r\n                        \" lines of code in \" +\r\n                        (Date.now() - startedAt) +\r\n                        \" ms\",\r\n                      8000\r\n                    );\r\n\r\n                    var error = false;\r\n                    try {\r\n                      acorn.parse(output, {\r\n                        ecmaVersion: \"latest\",\r\n                        sourceType: \"module\",\r\n                      });\r\n                    } catch (e) {\r\n                      error = true;\r\n                      try {\r\n                        acorn.parse(output, {\r\n                          ecmaVersion: \"latest\",\r\n                          sourceType: \"script\",\r\n                        });\r\n                        error = false;\r\n                      } catch (e) {}\r\n                    }\r\n                    setCode(output);\r\n\r\n                    if (error) {\r\n                      Alert.error(\r\n                        \"An error occurred during the code generation\"\r\n                      );\r\n                    }\r\n                  })\r\n                  .catch((err) => {\r\n                    console.error(err);\r\n                    Alert.error(err.toString());\r\n                  });\r\n              }\r\n            }}\r\n          >\r\n            Obfuscate\r\n          </Button>\r\n        </div>\r\n      </OptionContext.Provider>\r\n    </ThemeContext.Provider>\r\n  );\r\n}\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nimport 'rsuite/dist/styles/rsuite-dark.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import { ok } from \"assert\";\r\nimport { writeFileSync } from \"fs\";\r\nimport { ObfuscateOptions, remove$Properties } from \"./index\";\r\nimport { Node } from \"./util/gen\";\r\n\r\nconst escodegen = require(\"escodegen\");\r\n\r\nexport default async function compileJs(tree: any, options: ObfuscateOptions) {\r\n  return compileJsSync(tree, options);\r\n}\r\n\r\nexport function compileJsSync(tree: any, options: ObfuscateOptions): string {\r\n  var api: any = { format: escodegen.FORMAT_MINIFY };\r\n\r\n  if (!options.compact) {\r\n    api = {};\r\n\r\n    if (options.indent && options.indent != 4) {\r\n      api.format = {};\r\n      api.format.indent = {\r\n        style: { 2: \"  \", tabs: \"\\t\" }[options.indent] || \"    \",\r\n      };\r\n    }\r\n  }\r\n\r\n  if (options.debugComments) {\r\n    api.comment = true;\r\n  }\r\n\r\n  return escodegen.generate(tree, api);\r\n}\r\n\r\nexport function getToStringValue(\r\n  tree: Node,\r\n  syntax: (code: string) => string,\r\n  options: ObfuscateOptions\r\n) {\r\n  ok(tree);\r\n  ok(tree.type);\r\n  ok(!Array.isArray(tree));\r\n  ok(typeof syntax === \"function\");\r\n\r\n  var generated = escodegen.generate(tree);\r\n  ok(typeof generated === \"string\");\r\n\r\n  var fullCode = syntax(generated);\r\n  ok(typeof fullCode === \"string\");\r\n\r\n  try {\r\n    var result = eval(fullCode);\r\n  } catch (e) {\r\n    console.log(\">>\", fullCode);\r\n    throw e;\r\n  }\r\n\r\n  return result && result.toString();\r\n}\r\n"],"sourceRoot":""}